{"db_id": "concert_singer", "question": "Сколько у нас певцов?", "query": "select count ( * ) from singer", "predicted_sql": "select count ( * ) from singer", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Сколько у нас певцов? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Сколько всего певцов?", "query": "select count ( * ) from singer", "predicted_sql": "select count ( singer_id ) from singer", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Сколько всего певцов? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Показать имя, страну, возраст для всех певцов, отсортированных по возрасту от самого старшего до самого младшего.", "query": "select name , country , age from singer order by age desc", "predicted_sql": "select singer.name  , singer.country  , singer.age from singer order by singer.age desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Показать имя, страну, возраст для всех певцов, отсортированных по возрасту от самого старшего до самого младшего. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Какие имена, страны и возраст у каждого певца в порядке убывания возраста?", "query": "select name , country , age from singer order by age desc", "predicted_sql": "select singer.name  , singer.country  , singer.age from singer order by singer.age desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Какие имена, страны и возраст у каждого певца в порядке убывания возраста? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Каков средний, минимальный и максимальный возраст всех певцов из России?", "query": "select avg ( age ) , min ( age ) , max ( age ) from singer where country = 'Россия'", "predicted_sql": "select avg ( age ) as average_age  , min ( age ) as min_age  , max ( age ) as max_age from singer where country = 'Russia'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Каков средний, минимальный и максимальный возраст всех певцов из России? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Какой средний, минимальный и максимальный возраст для всех российских певцов?", "query": "select avg ( age ) , min ( age ) , max ( age ) from singer where country = 'Россия'", "predicted_sql": "select avg ( age ) as average_age  , min ( age ) as min_age  , max ( age ) as max_age from singer where country = 'Russia'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Какой средний, минимальный и максимальный возраст для всех российских певцов? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Укажите название и год выпуска песни самого молодого певца.", "query": "select song_name , song_release_year from singer order by age asc limit 1", "predicted_sql": "select singer.name  , singer.song_release_year from singer where singer.age = ( select min ( age ) from singer )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Укажите название и год выпуска песни самого молодого певца. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Названия и годы релизов всех песен самого молодого певца", "query": "select song_name , song_release_year from singer order by age asc limit 1", "predicted_sql": "select singer.name  , singer.song_release_year from singer where singer.age = ( select min ( age ) from singer )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Названия и годы релизов всех песен самого молодого певца \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Из каких стран певцы старше 20 лет?", "query": "select distinct country from singer where age > 20", "predicted_sql": "select singer.country from singer where singer.age > 20", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Из каких стран певцы старше 20 лет? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Из каких стран есть певцы старше 20 лет?", "query": "select distinct country from singer where age > 20", "predicted_sql": "select distinct country from singer where age > 20", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Из каких стран есть певцы старше 20 лет? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Показать все страны и количество певцов из каждой страны.", "query": "select country , count ( * ) from singer group by country", "predicted_sql": "select singer.country  , count ( singer.singer_id ) as count from singer group by singer.country", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Показать все страны и количество певцов из каждой страны. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Сколько певцов от каждой страны?", "query": "select country , count ( * ) from singer group by country", "predicted_sql": "select singer.country  , count ( singer.singer_id ) as count from singer group by singer.country", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Сколько певцов от каждой страны? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Перечислите все названия песен исполнителей старше среднего возраста.", "query": "select song_name from singer where age > ( select avg ( age ) from singer )", "predicted_sql": "select singer.song_name from singer where singer.age > ( select avg ( age ) from singer )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Перечислите все названия песен исполнителей старше среднего возраста. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Как называются все песни певцов старше среднего?", "query": "select song_name from singer where age > ( select avg ( age ) from singer )", "predicted_sql": "select singer.song_name from singer where singer.age > ( select avg ( age ) from singer )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Как называются все песни певцов старше среднего? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Укажите расположение и название для всех стадионов вместимостью от 5000 до 10000 человек.", "query": "select location , name from stadium where capacity between 5000 and 10000", "predicted_sql": "select stadium.location  , stadium.name from stadium where stadium.capacity >= 5000 and stadium.capacity <= 10000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Укажите расположение и название для всех стадионов вместимостью от 5000 до 10000 человек. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Каково расположение и названия всех станций вместимостью от 5000 до 10000?", "query": "select location , name from stadium where capacity between 5000 and 10000", "predicted_sql": "select stadium.location  , stadium.name from stadium where stadium.capacity >= 5000 and stadium.capacity <= 10000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Каково расположение и названия всех станций вместимостью от 5000 до 10000? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Какова максимальная вместимость и средняя вместимость всех стадионов?", "query": "select max ( capacity ) , average from stadium", "predicted_sql": "select max ( capacity ) as max_capacity  , avg ( capacity ) as avg_capacity from stadium", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Какова максимальная вместимость и средняя вместимость всех стадионов? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Какова средняя и максимальная вместимость всех стадионов?", "query": "select avg ( capacity ) , max ( capacity ) from stadium", "predicted_sql": "select avg ( capacity )  , max ( capacity ) from stadium", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Какова средняя и максимальная вместимость всех стадионов? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Название и вместимость стадиона с самой высокой средней посещаемостью?", "query": "select name , capacity from stadium order by average desc limit 1", "predicted_sql": "select stadium.name  , stadium.capacity from stadium order by stadium.average desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Название и вместимость стадиона с самой высокой средней посещаемостью? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Название и вместимость стадиона с самой высокой средней посещаемостью?", "query": "select name , capacity from stadium order by average desc limit 1", "predicted_sql": "select stadium.name  , stadium.capacity from stadium order by stadium.average desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Название и вместимость стадиона с самой высокой средней посещаемостью? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Сколько концертов было в 2014 или 2015 годах?", "query": "select count ( * ) from concert where year = 2014 or year = 2015", "predicted_sql": "select count ( * ) from concert where year = 2014 or year = 2015", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Сколько концертов было в 2014 или 2015 годах? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Сколько концертов состоялось в 2014 или 2015?", "query": "select count ( * ) from concert where year = 2014 or year = 2015", "predicted_sql": "select count ( * ) from concert where year = 2014 or year = 2015", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Сколько концертов состоялось в 2014 или 2015? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Покажите название стадиона и количество концертов на каждом стадионе.", "query": "select stadium.name , count ( * ) from concert join stadium on concert.stadium_id = stadium.stadium_id group by concert.stadium_id", "predicted_sql": "select stadium.name  , count ( concert.concert_id ) as concert_count from stadium inner join concert on concert.stadium_id = stadium.stadium_id group by stadium.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Покажите название стадиона и количество концертов на каждом стадионе. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Сколько было сыграно концертов на каждом стадионе?", "query": "select stadium.name , count ( * ) from concert join stadium on concert.stadium_id = stadium.stadium_id group by concert.stadium_id", "predicted_sql": "select stadium.name  , count ( concert.concert_id ) as num_concerts from stadium inner join concert on stadium.stadium_id = concert.stadium_id group by stadium.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Сколько было сыграно концертов на каждом стадионе? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Укажите название и вместимость стадиона, на котором будет проведено наибольшее количество концертов в 2014 году или позже.", "query": "select stadium.name , stadium.capacity from concert join stadium on concert.stadium_id = stadium.stadium_id where concert.year >= 2014 group by stadium.stadium_id order by count ( * ) desc limit 1", "predicted_sql": "select stadium.name  , stadium.capacity from stadium join concert on concert.stadium_id = stadium.stadium_id where concert.year >= 2014 group by stadium.stadium_id order by count ( concert.concert_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Укажите название и вместимость стадиона, на котором будет проведено наибольшее количество концертов в 2014 году или позже. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Название и вместимость стадиона, на котором прошло больше всего концертов после 2013 года?", "query": "select stadium.name , stadium.capacity from concert join stadium on concert.stadium_id = stadium.stadium_id where concert.year > 2013 group by stadium.stadium_id order by count ( * ) desc limit 1", "predicted_sql": "select stadium.name  , stadium.capacity from stadium join concert on concert.stadium_id = stadium.stadium_id where concert.year > 2013 group by stadium.stadium_id order by count ( concert.concert_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Название и вместимость стадиона, на котором прошло больше всего концертов после 2013 года? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "В каком году больше всего концертов?", "query": "select year from concert group by year order by count ( * ) desc limit 1", "predicted_sql": "select concert.year from concert group by concert.year order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### В каком году больше всего концертов? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "В каком году было больше всего концертов?", "query": "select year from concert group by year order by count ( * ) desc limit 1", "predicted_sql": "select concert.year from concert group by concert.year order by count ( concert.concert_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### В каком году было больше всего концертов? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Показывать названия стадионов без концертов.", "query": "select name from stadium where stadium_id not in ( select stadium_id from concert )", "predicted_sql": "select stadium.name from stadium left join concert on stadium.stadium_id = concert.stadium_id where concert.concert_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Показывать названия стадионов без концертов. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Как называются стадионы без проведенных концертов?", "query": "select name from stadium where stadium_id not in ( select stadium_id from concert )", "predicted_sql": "select stadium.name from stadium left join concert on stadium.stadium_id = concert.stadium_id where concert.concert_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Как называются стадионы без проведенных концертов? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Показать страны происхождения певца старше 40 лет и певца младше 30 лет.", "query": "select country from singer where age > 40 intersect select country from singer where age < 30", "predicted_sql": "select singer.country from singer where singer.age > 40 and singer.age < 30", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Показать страны происхождения певца старше 40 лет и певца младше 30 лет. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Укажите названия всех стадионов, кроме стадионов, на которых в 2014 году состоялся концерт.", "query": "select name from stadium except select stadium.name from concert join stadium on concert.stadium_id = stadium.stadium_id where concert.year = 2014", "predicted_sql": "select stadium.name from stadium where stadium.stadium_id not in ( select concert.stadium_id from concert where concert.year = 2014 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Укажите названия всех стадионов, кроме стадионов, на которых в 2014 году состоялся концерт. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Как называются все стадионы, на которых не было концертов в 2014 году?", "query": "select name from stadium except select stadium.name from concert join stadium on concert.stadium_id = stadium.stadium_id where concert.year = 2014", "predicted_sql": "select stadium.name from stadium where stadium.stadium_id not in ( select concert.stadium_id from concert where concert.year = 2014 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Как называются все стадионы, на которых не было концертов в 2014 году? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Укажите название и тему для всех концертов, а также количество певцов на каждом концерте.", "query": "select concert.concert_name , concert.theme , count ( * ) from singer_in_concert join concert on singer_in_concert.concert_id = concert.concert_id group by concert.concert_id", "predicted_sql": "select concert.concert_name  , concert.theme  , count ( singer_in_concert.singer_id ) as singer_count from concert join singer_in_concert on concert.concert_id = singer_in_concert.concert_id group by concert.concert_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Укажите название и тему для всех концертов, а также количество певцов на каждом концерте. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Какие имена певцов, темы выступлений и количество певцов на каждом концерте?", "query": "select concert.concert_name , concert.theme , count ( * ) from singer_in_concert join concert on singer_in_concert.concert_id = concert.concert_id group by concert.concert_id", "predicted_sql": "select singer.name  , concert.theme  , count ( singer_in_concert.singer_id ) as num_singers from singer join singer_in_concert on singer.singer_id = singer_in_concert.singer_id join concert on singer_in_concert.concert_id = concert.concert_id group by concert.concert_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Какие имена певцов, темы выступлений и количество певцов на каждом концерте? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Перечислите имена певцов и количество концертов для каждого певца.", "query": "select singer.name , count ( * ) from singer_in_concert join singer on singer_in_concert.singer_id = singer.singer_id group by singer.singer_id", "predicted_sql": "select singer.name  , count ( concert.concert_id ) as concert_count from singer join singer_in_concert on singer.singer_id = singer_in_concert.singer_id join concert on singer_in_concert.concert_id = concert.concert_id group by singer.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Перечислите имена певцов и количество концертов для каждого певца. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Как зовут певцов и сколько концертов у каждого человека?", "query": "select singer.name , count ( * ) from singer_in_concert join singer on singer_in_concert.singer_id = singer.singer_id group by singer.singer_id", "predicted_sql": "select singer.name  , count ( concert.concert_id ) as concert_count from singer join singer_in_concert on singer.singer_id = singer_in_concert.singer_id join concert on singer_in_concert.concert_id = concert.concert_id group by singer.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Как зовут певцов и сколько концертов у каждого человека? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Перечислите имена всех певцов на концертах в 2014 году.", "query": "select singer.name from singer_in_concert join singer on singer_in_concert.singer_id = singer.singer_id join concert on singer_in_concert.concert_id = concert.concert_id where concert.year = 2014", "predicted_sql": "select singer.name from singer join singer_in_concert on singer.singer_id = singer_in_concert.singer_id join concert on singer_in_concert.concert_id = concert.concert_id where concert.year = 2014", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Перечислите имена всех певцов на концертах в 2014 году. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Как зовут певцов, выступавших на концерте в 2014 году?", "query": "select singer.name from singer_in_concert join singer on singer_in_concert.singer_id = singer.singer_id join concert on singer_in_concert.concert_id = concert.concert_id where concert.year = 2014", "predicted_sql": "select singer.name from singer join singer_in_concert on singer.singer_id = singer_in_concert.singer_id join concert on singer_in_concert.concert_id = concert.concert_id where concert.year = 2014", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Как зовут певцов, выступавших на концерте в 2014 году? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Имя и национальность певца, у которого есть песня со словом «Всё» в названии?", "query": "select name , country from singer where song_name like '%Всё%'", "predicted_sql": "select singer.name  , singer.country from singer where singer.song_name like '%Всё%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Имя и национальность певца, у которого есть песня со словом «Всё» в названии? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Имя и страна происхождения каждого певца, у которого есть песня со словом «Всё» в названии?", "query": "select name , country from singer where song_name like '%Всё%'", "predicted_sql": "select singer.name  , singer.country from singer where singer.song_name like '%Всё%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Имя и страна происхождения каждого певца, у которого есть песня со словом «Всё» в названии? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Найдите название и расположение стадионов, на которых проходили некоторые концерты в 2014 и 2015 годах.", "query": "select stadium.name , stadium.location from concert join stadium on concert.stadium_id = stadium.stadium_id where concert.year = 2014 intersect select stadium.name , stadium.location from concert join stadium on concert.stadium_id = stadium.stadium_id where concert.year = 2015", "predicted_sql": "select stadium.name  , stadium.location from stadium join concert on concert.stadium_id = stadium.stadium_id where concert.year in ( 2014  , 2015 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Найдите название и расположение стадионов, на которых проходили некоторые концерты в 2014 и 2015 годах. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Как называются и где находятся стадионы, на которых проходили концерты в 2014 и 2015 годах?", "query": "select stadium.name , stadium.location from concert join stadium on concert.stadium_id = stadium.stadium_id where concert.year = 2014 intersect select stadium.name , stadium.location from concert join stadium on concert.stadium_id = stadium.stadium_id where concert.year = 2015", "predicted_sql": "select stadium.name  , stadium.location from concert join stadium on concert.stadium_id = stadium.stadium_id where concert.year in ( 2014  , 2015 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Как называются и где находятся стадионы, на которых проходили концерты в 2014 и 2015 годах? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Найдите количество концертов на стадионе с наибольшей вместимостью.", "query": "select count ( * ) from concert where stadium_id = ( select stadium_id from stadium order by capacity desc limit 1 )", "predicted_sql": "select count ( concert.concert_id ) from concert join stadium on concert.stadium_id = stadium.stadium_id where stadium.capacity = ( select max ( capacity ) from stadium )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Найдите количество концертов на стадионе с наибольшей вместимостью. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "concert_singer", "question": "Сколько концертов прошло на стадионе с наибольшей вместимостью?", "query": "select count ( * ) from concert where stadium_id = ( select stadium_id from stadium order by capacity desc limit 1 )", "predicted_sql": "select count ( concert.concert_id ) from concert join stadium on concert.stadium_id = stadium.stadium_id where stadium.capacity = ( select max ( capacity ) from stadium )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Сколько концертов прошло на стадионе с наибольшей вместимостью? \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "pets_1", "question": "Найдите количество домашних животных, вес которых превышает 10.", "query": "select count ( * ) from pets where weight > 10", "predicted_sql": "select count ( * ) from has_pet join pets on has_pet.petid = pets.petid where pets.weight > 10", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найдите количество домашних животных, вес которых превышает 10. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Сколько домашних животных имеют вес больше 10?", "query": "select count ( * ) from pets where weight > 10", "predicted_sql": "select count ( * ) from has_pet join pets on has_pet.petid = pets.petid where pets.weight > 10", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Сколько домашних животных имеют вес больше 10? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найдите вес самой молодой собаки.", "query": "select weight from pets order by pet_age asc limit 1", "predicted_sql": "select min ( pets.weight ) from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where pets.pettype = 'dog' and student.age = ( select min ( age ) from student )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найдите вес самой молодой собаки. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Сколько весит самая молодая собака?", "query": "select weight from pets order by pet_age asc limit 1", "predicted_sql": "select min ( pets.weight ) from pets where pets.pettype = 'dog'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Сколько весит самая молодая собака? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найдите максимальный вес для каждого типа питомца. Укажите максимальный вес и тип питомца.", "query": "select max ( weight ) , pettype from pets group by pettype", "predicted_sql": "select pets.pettype  , max ( pets.weight ) as max_weight from pets group by pets.pettype", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найдите максимальный вес для каждого типа питомца. Укажите максимальный вес и тип питомца. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Укажи максимальный вес и тип для каждого типа питомца.", "query": "select max ( weight ) , pettype from pets group by pettype", "predicted_sql": "select pets.pettype  , max ( pets.weight ) as max_weight from pets group by pets.pettype", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Укажи максимальный вес и тип для каждого типа питомца. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найди количество домашних животных, принадлежащих учащимся старше 20 лет.", "query": "select count ( * ) from student join has_pet on student.stuid = has_pet.stuid where student.age > 20", "predicted_sql": "select count ( has_pet.petid ) from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where student.age > 20", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найди количество домашних животных, принадлежащих учащимся старше 20 лет. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Сколько домашних животных принадлежит учащимся старше 20 лет?", "query": "select count ( * ) from student join has_pet on student.stuid = has_pet.stuid where student.age > 20", "predicted_sql": "select count ( has_pet.petid ) from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where student.age > 20", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Сколько домашних животных принадлежит учащимся старше 20 лет? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найдите количество домашних питомцев, которых имеют студентки (с полом Ж).", "query": "select count ( * ) from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where student.sex = 'Ж'", "predicted_sql": "select count ( has_pet.petid ) from has_pet join student on has_pet.stuid = student.stuid where student.sex = 'Ж'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найдите количество домашних питомцев, которых имеют студентки (с полом Ж). \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Сколько домашних питомцев имеют студентки?", "query": "select count ( * ) from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where student.sex = 'Ж'", "predicted_sql": "select count ( * ) from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where student.sex = 'female'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Сколько домашних питомцев имеют студентки? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найдите количество различных видов домашних животных.", "query": "select count ( distinct pettype ) from pets", "predicted_sql": "select count ( distinct pets.pettype ) from pets", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найдите количество различных видов домашних животных. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Сколько существует разных видов домашних животных?", "query": "select count ( distinct pettype ) from pets", "predicted_sql": "select count ( distinct pettype ) from pets", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Сколько существует разных видов домашних животных? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Имена учеников, у которых есть черепаха или попугай.", "query": "select distinct student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'черепаха' or pets.pettype = 'попугай'", "predicted_sql": "select student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where pets.pettype = 'черепаха' or pets.pettype = 'попугай'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype ( попугай , черепаха ) , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Имена учеников, у которых есть черепаха или попугай. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Как зовут каждого ученика, у которого в качестве домашнего питомца есть черепаха или попугай?", "query": "select distinct student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'черепаха' or pets.pettype = 'попугай'", "predicted_sql": "select student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where pets.pettype = 'черепаха' or pets.pettype = 'попугай'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype ( попугай , черепаха ) , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Как зовут каждого ученика, у которого в качестве домашнего питомца есть черепаха или попугай? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найдите имена учеников, у которых есть и черепахи, и попугаи.", "query": "select student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'черепаха' intersect select student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'попугай'", "predicted_sql": "select student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where pets.pettype = 'попугай' intersect select student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where pets.pettype = 'черепаха'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype ( попугай , черепаха ) , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найдите имена учеников, у которых есть и черепахи, и попугаи. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Как зовут учеников, у которых в качестве домашних животных есть и черепахи, и попугаи?", "query": "select student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'черепаха' intersect select student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'попугай'", "predicted_sql": "select student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where pets.pettype = 'черепаха' and pets.pettype = 'попугай'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype ( попугай , черепаха ) , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Как зовут учеников, у которых в качестве домашних животных есть и черепахи, и попугаи? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найдите специальность и возраст студентов, у которых нет черепах.", "query": "select major , age from student where stuid not in ( select student.stuid from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'черепаха' )", "predicted_sql": "select student.major  , student.age from student where student.stuid not in ( select has_pet.stuid from has_pet join pets on has_pet.petid = pets.petid where pets.pettype = 'черепаха' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype ( черепаха ) , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найдите специальность и возраст студентов, у которых нет черепах. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Какую специальность имеет каждый студент, у которого нет черепахи в качестве домашнего животного, и сколько им лет?", "query": "select major , age from student where stuid not in ( select student.stuid from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'черепаха' )", "predicted_sql": "select student.major  , student.age from student where student.stuid not in ( select has_pet.stuid from has_pet join pets on has_pet.petid = pets.petid where pets.pettype = 'черепаха' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype ( черепаха ) , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Какую специальность имеет каждый студент, у которого нет черепахи в качестве домашнего животного, и сколько им лет? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найди id студентов, у которых нет черепах.", "query": "select stuid from student except select student.stuid from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'черепаха'", "predicted_sql": "select student.stuid from student where student.stuid not in ( select has_pet.stuid from has_pet inner join pets on has_pet.petid = pets.petid where pets.pettype = 'черепаха' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype ( черепаха ) , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найди id студентов, у которых нет черепах. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Каковы id студентов, у которых нет черепах в качестве домашних животных?", "query": "select stuid from student except select student.stuid from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'черепаха'", "predicted_sql": "select student.stuid from student where student.stuid not in ( select has_pet.stuid from has_pet inner join pets on has_pet.petid = pets.petid where pets.pettype = 'черепаха' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype ( черепаха ) , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Каковы id студентов, у которых нет черепах в качестве домашних животных? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найдите имя и возраст учеников, у которых есть черепаха, но нет попугая в качестве домашнего питомца.", "query": "select student.fname , student.age from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'черепаха' and student.stuid not in ( select student.stuid from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'попугай' )", "predicted_sql": "select student.fname  , student.age from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where pets.pettype = 'черепаха' and pets.pettype  != 'попугай'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype ( попугай , черепаха ) , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найдите имя и возраст учеников, у которых есть черепаха, но нет попугая в качестве домашнего питомца. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Как зовут каждого ученика, у которого есть черепаха, но нет попугая?", "query": "select student.fname , student.age from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'черепаха' and student.stuid not in ( select student.stuid from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pettype = 'попугай' )", "predicted_sql": "select student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where pets.pettype = 'черепаха' and student.stuid not in ( select student.stuid from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where pets.pettype = 'попугай' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype ( попугай , черепаха ) , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Как зовут каждого ученика, у которого есть черепаха, но нет попугая? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Тип и вес самого молодого питомца.", "query": "select pettype , weight from pets order by pet_age asc limit 1", "predicted_sql": "select pets.pettype  , min ( pets.pet_age ) as youngest_pet_age  , pets.weight from pets group by pets.pettype order by youngest_pet_age asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Тип и вес самого молодого питомца. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Какой тип домашнего животного самый молодой и сколько оно весит?", "query": "select pettype , weight from pets order by pet_age asc limit 1", "predicted_sql": "select pets.pettype  , min ( pets.pet_age ) as youngest_age  , pets.weight from pets group by pets.pettype order by youngest_age asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Какой тип домашнего животного самый молодой и сколько оно весит? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найди id и вес всех домашних животных старше 1 года.", "query": "select petid , weight from pets where pet_age > 1", "predicted_sql": "select has_pet.petid  , pets.weight from has_pet join pets on has_pet.petid = pets.petid where pets.pet_age > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найди id и вес всех домашних животных старше 1 года. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Каков id и вес каждого питомца старше 1 года?", "query": "select petid , weight from pets where pet_age > 1", "predicted_sql": "select pets.petid  , pets.weight from pets where pets.pet_age > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Каков id и вес каждого питомца старше 1 года? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найдите средний и максимальный возраст для каждого типа домашних животных.", "query": "select avg ( pet_age ) , max ( pet_age ) , pettype from pets group by pettype", "predicted_sql": "select pets.pettype  , avg ( student.age ) as average_age  , max ( student.age ) as max_age from pets join has_pet on pets.petid = has_pet.petid join student on has_pet.stuid = student.stuid group by pets.pettype", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найдите средний и максимальный возраст для каждого типа домашних животных. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Каков средний и максимальный возраст для каждого типа домашних животных?", "query": "select avg ( pet_age ) , max ( pet_age ) , pettype from pets group by pettype", "predicted_sql": "select pets.pettype  , avg ( pets.pet_age ) as average_age  , max ( pets.pet_age ) as max_age from pets group by pets.pettype", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Каков средний и максимальный возраст для каждого типа домашних животных? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Средний вес для каждого типа питомца.", "query": "select avg ( weight ) , pettype from pets group by pettype", "predicted_sql": "select pets.pettype  , avg ( pets.weight ) as average_weight from pets group by pets.pettype", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Средний вес для каждого типа питомца. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Каков средний вес для каждого вида домашних животных?", "query": "select avg ( weight ) , pettype from pets group by pettype", "predicted_sql": "select pets.pettype  , avg ( pets.weight ) as average_weight from pets group by pets.pettype", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Каков средний вес для каждого вида домашних животных? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Имя и возраст учеников, у которых есть домашнее животное.", "query": "select distinct student.fname , student.age from student join has_pet on student.stuid = has_pet.stuid", "predicted_sql": "select student.fname  , student.age from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Имя и возраст учеников, у которых есть домашнее животное. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Каковы разные имена и возраст учеников, у которых есть домашние животные?", "query": "select distinct student.fname , student.age from student join has_pet on student.stuid = has_pet.stuid", "predicted_sql": "select student.fname  , student.age from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Каковы разные имена и возраст учеников, у которых есть домашние животные? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найти id животного, принадлежащего студенту по фамилии «Спиридонов» .", "query": "select has_pet.petid from student join has_pet on student.stuid = has_pet.stuid where student.lname = 'Спиридонов'", "predicted_sql": "select has_pet.petid from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where student.lname = 'Спиридонов'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найти id животного, принадлежащего студенту по фамилии «Спиридонов» . \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Каков id домашнего животного, принадлежащего студенту по фамилии Спиридонов?", "query": "select has_pet.petid from student join has_pet on student.stuid = has_pet.stuid where student.lname = 'Спиридонов'", "predicted_sql": "select has_pet.petid from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where student.lname = 'Спиридонов'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname ( Спиридонов ) , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Каков id домашнего животного, принадлежащего студенту по фамилии Спиридонов? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Количество домашних животных у каждого учащегося и id учащегося.", "query": "select count ( * ) , student.stuid from student join has_pet on student.stuid = has_pet.stuid group by student.stuid", "predicted_sql": "select student.stuid  , count ( has_pet.petid ) as num_pets from student join has_pet on student.stuid = has_pet.stuid group by student.stuid", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Количество домашних животных у каждого учащегося и id учащегося. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Для студентов, у которых есть домашние животные, сколько домашних животных имеет каждый студент? перечислите их id вместо имен.", "query": "select count ( * ) , student.stuid from student join has_pet on student.stuid = has_pet.stuid group by student.stuid", "predicted_sql": "select student.stuid  , count ( has_pet.petid ) as num_pets from student join has_pet on student.stuid = has_pet.stuid group by student.stuid", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Для студентов, у которых есть домашние животные, сколько домашних животных имеет каждый студент? перечислите их id вместо имен. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найдите имя и пол ученика, у которого более одного домашнего животного.", "query": "select student.fname , student.sex from student join has_pet on student.stuid = has_pet.stuid group by student.stuid having count ( * ) > 1", "predicted_sql": "select student.fname  , student.sex from student join has_pet on student.stuid = has_pet.stuid group by student.stuid having count ( has_pet.petid ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найдите имя и пол ученика, у которого более одного домашнего животного. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Имя и пол всех учеников, у которых есть более одного домашнего животного?", "query": "select student.fname , student.sex from student join has_pet on student.stuid = has_pet.stuid group by student.stuid having count ( * ) > 1", "predicted_sql": "select student.fname  , student.sex from student join has_pet on student.stuid = has_pet.stuid group by student.stuid having count ( has_pet.petid ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Имя и пол всех учеников, у которых есть более одного домашнего животного? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найдите фамилию ученика, у которого есть попугай трехлетнего возраста.", "query": "select student.lname from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pet_age = 3 and pets.pettype = 'попугай'", "predicted_sql": "select student.lname from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where pets.pettype = 'попугай' and pets.pet_age = 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype ( попугай ) , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найдите фамилию ученика, у которого есть попугай трехлетнего возраста. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Как зовут ученика, у которого есть попугай 3-х летнего возраста?", "query": "select student.lname from student join has_pet on student.stuid = has_pet.stuid join pets on pets.petid = has_pet.petid where pets.pet_age = 3 and pets.pettype = 'попугай'", "predicted_sql": "select student.fname from student join has_pet on student.stuid = has_pet.stuid join pets on has_pet.petid = pets.petid where pets.pettype = 'попугай' and pets.pet_age = 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype ( попугай ) , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Как зовут ученика, у которого есть попугай 3-х летнего возраста? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Найдите средний возраст студентов, у которых нет домашних животных.", "query": "select avg ( age ) from student where stuid not in ( select stuid from has_pet )", "predicted_sql": "select avg ( age ) from student where stuid not in ( select stuid from has_pet )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Найдите средний возраст студентов, у которых нет домашних животных. \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "pets_1", "question": "Каков средний возраст всех учеников, у которых нет домашних животных?", "query": "select avg ( age ) from student where stuid not in ( select stuid from has_pet )", "predicted_sql": "select avg ( age ) from student where stuid not in ( select stuid from has_pet )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | student : student.stuid , student.lname , student.fname , student.age , student.sex , student.major , student.advisor , student.city_code | has_pet : has_pet.stuid , has_pet.petid | pets : pets.petid , pets.pettype , pets.pet_age , pets.weight | has_pet.stuid = student.stuid | has_pet.petid = pets.petid# \n ### Каков средний возраст всех учеников, у которых нет домашних животных? \n SELECT\n        ", "tc_original": ["student.*", "student.stuid", "student.lname", "student.fname", "student.age", "student.sex", "student.major", "student.advisor", "student.city_code", "has_pet.*", "has_pet.stuid", "has_pet.petid", "pets.*", "pets.petid", "pets.pettype", "pets.pet_age", "pets.weight"]}
{"db_id": "car_1", "question": "Сколько всего континентов?", "query": "select count ( * ) from continents", "predicted_sql": "select count ( * ) from continents", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько всего континентов? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько континентов?", "query": "select count ( * ) from continents", "predicted_sql": "select count ( * ) from continents", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько континентов? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько стран есть на каждом континенте? Показать id континента, название континента и количество стран.", "query": "select continents.contid , continents.continent , count ( * ) from continents join countries on continents.contid = countries.continent group by continents.contid", "predicted_sql": "select continents.contid  , continents.continent  , count ( countries.countryid ) as country_count from continents join countries on countries.continent = continents.contid group by continents.contid  , continents.continent", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько стран есть на каждом континенте? Показать id континента, название континента и количество стран. \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Для каждого континента укажите его id, название и количество стран", "query": "select continents.contid , continents.continent , count ( * ) from continents join countries on continents.contid = countries.continent group by continents.contid", "predicted_sql": "select continents.contid  , continents.continent  , count ( countries.countryid ) as country_count from continents join countries on countries.continent = continents.contid group by continents.contid  , continents.continent", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Для каждого континента укажите его id, название и количество стран \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько стран указано в списке?", "query": "select count ( * ) from countries", "predicted_sql": "select count ( distinct countries.countryname ) from countries", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько стран указано в списке? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько стран существует?", "query": "select count ( * ) from countries", "predicted_sql": "select count ( * ) from countries", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько стран существует? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько моделей выпускает каждый автопроизводитель? Полное имя производителя, id и количество моделей.", "query": "select car_makers.fullname , car_makers.id , count ( * ) from car_makers join model_list on car_makers.id = model_list.maker group by car_makers.id", "predicted_sql": "select car_makers.fullname  , car_makers.id  , count ( model_list.model ) as number_of_models from car_makers join model_list on model_list.maker = car_makers.id group by car_makers.fullname  , car_makers.id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько моделей выпускает каждый автопроизводитель? Полное имя производителя, id и количество моделей. \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какое полное название каждого автопроизводителя, а также его id и сколько моделей он производит?", "query": "select car_makers.fullname , car_makers.id , count ( * ) from car_makers join model_list on car_makers.id = model_list.maker group by car_makers.id", "predicted_sql": "select car_makers.id  , car_makers.fullname  , count ( model_list.modelid ) as num_models from car_makers join model_list on model_list.maker = car_makers.id group by car_makers.id  , car_makers.fullname", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какое полное название каждого автопроизводителя, а также его id и сколько моделей он производит? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая модель автомобиля имеет минимальную мощность?", "query": "select car_names.model from car_names join cars_data on car_names.makeid = cars_data.id order by cars_data.horsepower asc limit 1", "predicted_sql": "select model_list.model from cars_data join car_names on cars_data.id = car_names.makeid join model_list on car_names.model = model_list.model where cars_data.horsepower = ( select min ( horsepower ) from cars_data )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая модель автомобиля имеет минимальную мощность? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая модель автомобиля с наименьшей мощностью?", "query": "select car_names.model from car_names join cars_data on car_names.makeid = cars_data.id order by cars_data.horsepower asc limit 1", "predicted_sql": "select model_list.model from cars_data join car_names on cars_data.id = car_names.makeid join model_list on car_names.model = model_list.model order by cars_data.horsepower asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая модель автомобиля с наименьшей мощностью? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Найдите модель автомобиля, вес которой меньше среднего.", "query": "select car_names.model from car_names join cars_data on car_names.makeid = cars_data.id where cars_data.weight < ( select avg ( weight ) from cars_data )", "predicted_sql": "select model_list.model from model_list join car_names on model_list.modelid = car_names.model join cars_data on car_names.makeid = cars_data.id where cars_data.weight < ( select avg ( weight ) from cars_data )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Найдите модель автомобиля, вес которой меньше среднего. \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая модель машины имеет массу меньше средней?", "query": "select car_names.model from car_names join cars_data on car_names.makeid = cars_data.id where cars_data.weight < ( select avg ( weight ) from cars_data )", "predicted_sql": "select model_list.model from model_list join car_names on model_list.modelid = car_names.model join cars_data on car_names.makeid = cars_data.id where cars_data.weight < ( select avg ( weight ) from cars_data )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая модель машины имеет массу меньше средней? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Найдите имена производителей, которые выпустили несколько автомобилей в 1970 году", "query": "select distinct car_makers.maker from car_makers join model_list on car_makers.id = model_list.maker join car_names on model_list.model = car_names.model join cars_data on car_names.makeid = cars_data.id where cars_data.year = '1970'", "predicted_sql": "select car_makers.maker from car_makers join model_list on car_makers.id = model_list.maker join car_names on model_list.modelid = car_names.model join cars_data on car_names.makeid = cars_data.id where cars_data.year = 1970 group by car_makers.maker having count ( distinct car_names.makeid ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Найдите имена производителей, которые выпустили несколько автомобилей в 1970 году \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Как назывались различные автопроизводители, которые выпустили автомобиль в 1970 году?", "query": "select distinct car_makers.maker from car_makers join model_list on car_makers.id = model_list.maker join car_names on model_list.model = car_names.model join cars_data on car_names.makeid = cars_data.id where cars_data.year = '1970'", "predicted_sql": "select car_makers.maker from car_makers join model_list on car_makers.id = model_list.maker join car_names on model_list.model = car_names.model join cars_data on car_names.makeid = cars_data.id where cars_data.year = 1970", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Как назывались различные автопроизводители, которые выпустили автомобиль в 1970 году? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Узнать марку и время выпуска автомобилей, выпущенных в самый ранний год", "query": "select car_names.make , cars_data.year from cars_data join car_names on cars_data.id = car_names.makeid where cars_data.year = ( select min ( year ) from cars_data )", "predicted_sql": "select car_makers.maker  , cars_data.year from car_makers join model_list on car_makers.id = model_list.maker join car_names on model_list.model = car_names.model join cars_data on car_names.makeid = cars_data.id where cars_data.year = ( select min ( year ) from cars_data )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Узнать марку и время выпуска автомобилей, выпущенных в самый ранний год \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какой производитель автомобилей выпустил автомобиль первым и в каком году это было?", "query": "select car_names.make , cars_data.year from cars_data join car_names on cars_data.id = car_names.makeid where cars_data.year = ( select min ( year ) from cars_data )", "predicted_sql": "select car_makers.maker  , min ( cars_data.year ) from car_makers join model_list on car_makers.id = model_list.maker join car_names on model_list.model = car_names.model join cars_data on car_names.makeid = cars_data.id group by car_makers.maker order by min ( cars_data.year ) asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какой производитель автомобилей выпустил автомобиль первым и в каком году это было? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какие модели автомобилей выпускаются после 1980 года?", "query": "select distinct model_list.model from model_list join car_names on model_list.model = car_names.model join cars_data on car_names.makeid = cars_data.id where cars_data.year > 1980", "predicted_sql": "select model_list.model from model_list join cars_data on model_list.modelid = cars_data.id where cars_data.year > 1980", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какие модели автомобилей выпускаются после 1980 года? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какие существуют модели автомобилей, выпущенных после 1980 года?", "query": "select distinct model_list.model from model_list join car_names on model_list.model = car_names.model join cars_data on car_names.makeid = cars_data.id where cars_data.year > 1980", "predicted_sql": "select model_list.model from model_list join cars_data on model_list.modelid = cars_data.id where cars_data.year > 1980", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какие существуют модели автомобилей, выпущенных после 1980 года? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько автопроизводителей существует на каждом континенте? Указывать название континента и количество.", "query": "select continents.continent , count ( * ) from continents join countries on continents.contid = countries.continent join car_makers on countries.countryid = car_makers.country group by continents.continent", "predicted_sql": "select continents.continent  , count ( distinct car_makers.id ) as num_car_makers from continents inner join countries on countries.continent = continents.contid inner join car_makers on car_makers.country = countries.countryid group by continents.continent", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько автопроизводителей существует на каждом континенте? Указывать название континента и количество. \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Как называется каждый континент и сколько производителей автомобилей на каждом из них?", "query": "select continents.continent , count ( * ) from continents join countries on continents.contid = countries.continent join car_makers on countries.countryid = car_makers.country group by continents.continent", "predicted_sql": "select continents.continent  , count ( car_makers.id ) as num_car_makers from continents inner join countries on countries.continent = continents.contid inner join car_makers on car_makers.country = countries.countryid group by continents.continent", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Как называется каждый континент и сколько производителей автомобилей на каждом из них? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "В какой из стран больше всего автопроизводителей? Укажите название страны.", "query": "select countries.countryname from car_makers join countries on car_makers.country = countries.countryid group by car_makers.country order by count ( * ) desc limit 1", "predicted_sql": "select countries.countryname from countries join car_makers on car_makers.country = countries.countryid group by countries.countryname order by count ( car_makers.id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### В какой из стран больше всего автопроизводителей? Укажите название страны. \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Как называется страна с наибольшим количеством производителей автомобилей?", "query": "select countries.countryname from car_makers join countries on car_makers.country = countries.countryid group by car_makers.country order by count ( * ) desc limit 1", "predicted_sql": "select countries.countryname from countries join car_makers on countries.countryid = car_makers.country group by countries.countryname order by count ( car_makers.id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Как называется страна с наибольшим количеством производителей автомобилей? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько моделей автомобилей выпускает каждый производитель? Укажите только количество и полное имя производителя.", "query": "select count ( * ) , car_makers.fullname from model_list join car_makers on model_list.maker = car_makers.id group by car_makers.id", "predicted_sql": "select car_makers.fullname  , count ( model_list.modelid ) as total_models from car_makers join model_list on model_list.maker = car_makers.id group by car_makers.fullname", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько моделей автомобилей выпускает каждый производитель? Укажите только количество и полное имя производителя. \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какое количество моделей автомобилей выпускает каждый производитель, и каковы id и полное название каждого производителя?", "query": "select count ( * ) , car_makers.fullname , car_makers.id from model_list join car_makers on model_list.maker = car_makers.id group by car_makers.id", "predicted_sql": "select car_makers.id  , car_makers.fullname  , count ( model_list.modelid ) as number_of_models from car_makers inner join model_list on model_list.maker = car_makers.id group by car_makers.id  , car_makers.fullname", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какое количество моделей автомобилей выпускает каждый производитель, и каковы id и полное название каждого производителя? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "С каким ускорением разгоняется модель amc hornet sportabout (sw)?", "query": "select cars_data.accelerate from cars_data join car_names on cars_data.id = car_names.makeid where car_names.make = 'amc hornet sportabout (sw)'", "predicted_sql": "select cars_data.accelerate from continents join countries on countries.continent = continents.contid join car_makers on car_makers.country = countries.countryid join model_list on model_list.maker = car_makers.id join car_names on car_names.model = model_list.model join cars_data on cars_data.id = car_names.makeid where car_names.model = 'amc hornet sportabout (sw)'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker ( amc ) , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model ( amc ) | car_names : car_names.makeid , car_names.model ( amc ) , car_names.make ( amc hornet , amc hornet sportabout (sw) ) | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### С каким ускорением разгоняется модель amc hornet sportabout (sw)? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Насколько может разогнаться модель amc hornet sportabout (sw)?", "query": "select cars_data.accelerate from cars_data join car_names on cars_data.id = car_names.makeid where car_names.make = 'amc hornet sportabout (sw)'", "predicted_sql": "select max ( accelerate ) from cars_data join car_names on cars_data.id = car_names.makeid join model_list on car_names.model = model_list.model where model_list.model = 'amc hornet sportabout (sw)'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker ( amc ) , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model ( amc ) | car_names : car_names.makeid , car_names.model ( amc ) , car_names.make ( amc hornet , amc hornet sportabout (sw) ) | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Насколько может разогнаться модель amc hornet sportabout (sw)? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько автопроизводителей в Китае?", "query": "select count ( * ) from car_makers join countries on car_makers.country = countries.countryid where countries.countryname = 'Китай'", "predicted_sql": "select count ( car_makers.id ) from car_makers join countries on car_makers.country = countries.countryid where countries.countryname = 'Китай'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько автопроизводителей в Китае? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько производителей автомобилей есть в Китае?", "query": "select count ( * ) from car_makers join countries on car_makers.country = countries.countryid where countries.countryname = 'Китай'", "predicted_sql": "select count ( car_makers.id ) from car_makers join countries on car_makers.country = countries.countryid where countries.countryname = 'Китай'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько производителей автомобилей есть в Китае? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько моделей автомобилей производится в Чехии?", "query": "select count ( * ) from model_list join car_makers on model_list.maker = car_makers.id join countries on car_makers.country = countries.countryid where countries.countryname = 'Чехия'", "predicted_sql": "select count ( model_list.model ) from model_list join car_makers on model_list.maker = car_makers.id join countries on car_makers.country = countries.countryid where countries.countryname = 'Чехия'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько моделей автомобилей производится в Чехии? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько моделей автомобилей произведено в Чехии?", "query": "select count ( * ) from model_list join car_makers on model_list.maker = car_makers.id join countries on car_makers.country = countries.countryid where countries.countryname = 'Чехия'", "predicted_sql": "select count ( model_list.model ) from model_list join car_makers on model_list.maker = car_makers.id join countries on car_makers.country = countries.countryid where countries.countryname = 'Czech Republic'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько моделей автомобилей произведено в Чехии? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько в среднем расходуется км на литр (км/л) у автомобилей с 4 цилиндрами?", "query": "select avg ( mpg ) from cars_data where cylinders = 4", "predicted_sql": "select avg ( mpg ) from cars_data where cylinders = 4", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько в среднем расходуется км на литр (км/л) у автомобилей с 4 цилиндрами? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какое среднее значение километров на литр для всех автомобилей с 4 цилиндрами?", "query": "select avg ( mpg ) from cars_data where cylinders = 4", "predicted_sql": "select avg ( mpg ) from cars_data where cylinders = 4", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какое среднее значение километров на литр для всех автомобилей с 4 цилиндрами? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какой наименьший вес у автомобиля с 8 цилиндрами, выпущенного в 1974 году?", "query": "select min ( weight ) from cars_data where cylinders = 8 and year = 1974", "predicted_sql": "select min ( weight ) from cars_data where cylinders = 8 and year = 1974", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какой наименьший вес у автомобиля с 8 цилиндрами, выпущенного в 1974 году? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какой минимальный вес у автомобиля с 8 цилиндрами 1974 года выпуска?", "query": "select min ( weight ) from cars_data where cylinders = 8 and year = 1974", "predicted_sql": "select min ( weight ) from cars_data where cylinders = 8 and year = 1974", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какой минимальный вес у автомобиля с 8 цилиндрами 1974 года выпуска? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какие все производители и модели?", "query": "select maker , model from model_list", "predicted_sql": "select car_makers.maker  , model_list.model from car_makers join model_list on model_list.maker = car_makers.id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какие все производители и модели? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какие производители и модели?", "query": "select maker , model from model_list", "predicted_sql": "select car_makers.maker  , model_list.model from car_makers join model_list on model_list.maker = car_makers.id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какие производители и модели? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "В каких странах есть хотя бы один производитель автомобилей? Показать название и id.", "query": "select countries.countryname , countries.countryid from countries join car_makers on countries.countryid = car_makers.country group by countries.countryid having count ( * ) >= 1", "predicted_sql": "select countries.countryid  , countries.countryname from countries join car_makers on car_makers.country = countries.countryid", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### В каких странах есть хотя бы один производитель автомобилей? Показать название и id. \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какие названия и id всех стран, где есть хотя бы один производитель автомобилей?", "query": "select countries.countryname , countries.countryid from countries join car_makers on countries.countryid = car_makers.country group by countries.countryid having count ( * ) >= 1", "predicted_sql": "select countries.countryid  , countries.countryname from countries join car_makers on car_makers.country = countries.countryid", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какие названия и id всех стран, где есть хотя бы один производитель автомобилей? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько всего автомобилей мощностью более 150 лошадиных сил?", "query": "select count ( * ) from cars_data where horsepower > 150", "predicted_sql": "select count ( * ) from cars_data where horsepower > 150", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько всего автомобилей мощностью более 150 лошадиных сил? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какое количество машин мощностью более 150 лошадиных сил?", "query": "select count ( * ) from cars_data where horsepower > 150", "predicted_sql": "select count ( * ) from cars_data where horsepower > 150", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какое количество машин мощностью более 150 лошадиных сил? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Каков средний вес автомобилей каждый год?", "query": "select avg ( weight ) , year from cars_data group by year", "predicted_sql": "select cars_data.year  , avg ( cars_data.weight ) as average_weight from cars_data group by cars_data.year", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Каков средний вес автомобилей каждый год? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Каков средний вес и год для каждого года?", "query": "select avg ( weight ) , year from cars_data group by year", "predicted_sql": "select avg ( weight ) as average_weight  , year from cars_data group by year", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Каков средний вес и год для каждого года? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "В каких странах Южной Америки есть как минимум 3 производителя автомобилей?", "query": "select countries.countryname from countries join continents on countries.continent = continents.contid join car_makers on countries.countryid = car_makers.country where continents.continent = 'Южная Америка' group by countries.countryname having count ( * ) >= 3", "predicted_sql": "select countries.countryname from countries join continents on countries.continent = continents.contid join car_makers on countries.countryid = car_makers.country group by countries.countryname having count ( distinct car_makers.id ) >= 3 and continents.continent = 'South America'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### В каких странах Южной Америки есть как минимум 3 производителя автомобилей? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Как называются все южноамериканские страны, в которых есть как минимум 3 производителя?", "query": "select countries.countryname from countries join continents on countries.continent = continents.contid join car_makers on countries.countryid = car_makers.country where continents.continent = 'Южная Америка' group by countries.countryname having count ( * ) >= 3", "predicted_sql": "select countries.countryname from countries join continents on countries.continent = continents.contid join car_makers on countries.countryid = car_makers.country group by countries.countryname having count ( car_makers.id ) >= 3 and continents.continent = 'South America'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Как называются все южноамериканские страны, в которых есть как минимум 3 производителя? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая максимальная мощность и марка у моделей автомобилей с 3 цилиндрами?", "query": "select cars_data.horsepower , car_names.make from car_names join cars_data on car_names.makeid = cars_data.id where cars_data.cylinders = 3 order by cars_data.horsepower desc limit 1", "predicted_sql": "select max ( cars_data.horsepower ) as max_horsepower  , car_makers.maker as car_maker from cars_data join car_names on cars_data.id = car_names.makeid join model_list on car_names.model = model_list.model join car_makers on model_list.maker = car_makers.id where cars_data.cylinders = 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая максимальная мощность и марка у моделей автомобилей с 3 цилиндрами? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая максимальная мощность у моделей с 3 цилиндрами и какой они марки?", "query": "select cars_data.horsepower , car_names.make from car_names join cars_data on car_names.makeid = cars_data.id where cars_data.cylinders = 3 order by cars_data.horsepower desc limit 1", "predicted_sql": "select car_makers.maker  , max ( cars_data.horsepower ) from cars_data join car_names on cars_data.id = car_names.makeid join model_list on car_names.model = model_list.model join car_makers on model_list.maker = car_makers.id where cars_data.cylinders = 3 group by car_makers.maker", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая максимальная мощность у моделей с 3 цилиндрами и какой они марки? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая модель экономит бензин больше всего? То есть имеет максимальное количество километров на литр.", "query": "select car_names.model from car_names join cars_data on car_names.makeid = cars_data.id order by cars_data.mpg desc limit 1", "predicted_sql": "select model_list.model from model_list join car_names on model_list.modelid = car_names.model join cars_data on car_names.makeid = cars_data.id order by cars_data.mpg desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая модель экономит бензин больше всего? То есть имеет максимальное количество километров на литр. \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая модель автомобиля с максимальным расходом топлива на литр?", "query": "select car_names.model from car_names join cars_data on car_names.makeid = cars_data.id order by cars_data.mpg desc limit 1", "predicted_sql": "select model_list.model from model_list join car_names on model_list.modelid = car_names.model join cars_data on car_names.makeid = cars_data.id order by cars_data.mpg desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая модель автомобиля с максимальным расходом топлива на литр? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какова средняя мощность автомобилей до 1980 года?", "query": "select avg ( horsepower ) from cars_data where year < 1980", "predicted_sql": "select avg ( horsepower ) from cars_data where year < 1980", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какова средняя мощность автомобилей до 1980 года? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая средняя мощность в лошадиных силах у всех автомобилей, выпущенных до 1980 года?", "query": "select avg ( horsepower ) from cars_data where year < 1980", "predicted_sql": "select avg ( horsepower ) from cars_data where year < 1980", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая средняя мощность в лошадиных силах у всех автомобилей, выпущенных до 1980 года? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какой средний edispl у автомобилей модели Volvo?", "query": "select avg ( cars_data.edispl ) from car_names join cars_data on car_names.makeid = cars_data.id where car_names.model = 'volvo'", "predicted_sql": "select avg ( cars_data.edispl ) from continents join countries on countries.continent = continents.contid join car_makers on car_makers.country = countries.countryid join model_list on model_list.maker = car_makers.id join car_names on car_names.model = model_list.model join cars_data on cars_data.id = car_names.makeid where model_list.model = 'volvo'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker ( volvo ) , car_makers.fullname ( Volvo ) , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model ( volvo ) | car_names : car_names.makeid , car_names.model ( volvo ) , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какой средний edispl у автомобилей модели Volvo? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какое среднее значение edispl для всех автомобилей Volvo?", "query": "select avg ( cars_data.edispl ) from car_names join cars_data on car_names.makeid = cars_data.id where car_names.model = 'volvo'", "predicted_sql": "select avg ( cars_data.edispl ) from continents join countries on countries.continent = continents.contid join car_makers on car_makers.country = countries.countryid join model_list on model_list.maker = car_makers.id join car_names on car_names.model = model_list.model join cars_data on cars_data.id = car_names.makeid where car_makers.maker = 'volvo'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker ( volvo ) , car_makers.fullname ( Volvo ) , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model ( volvo ) | car_names : car_names.makeid , car_names.model ( volvo ) , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какое среднее значение edispl для всех автомобилей Volvo? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какое максимальное ускорение для разного количества цилиндров?", "query": "select max ( accelerate ) , cylinders from cars_data group by cylinders", "predicted_sql": "select cars_data.cylinders  , max ( cars_data.accelerate ) from cars_data group by cars_data.cylinders", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какое максимальное ускорение для разного количества цилиндров? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какое максимальное ускорение для всех цилиндров?", "query": "select max ( accelerate ) , cylinders from cars_data group by cylinders", "predicted_sql": "select max ( accelerate ) from cars_data", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какое максимальное ускорение для всех цилиндров? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая модель имеет наибольшее количество версий (марок) автомобилей?", "query": "select model from car_names group by model order by count ( * ) desc limit 1", "predicted_sql": "select model_list.model  , count ( car_names.make ) as num_versions from model_list join car_names on model_list.modelid = car_names.model group by model_list.model order by num_versions desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая модель имеет наибольшее количество версий (марок) автомобилей? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая модель имеет самые разные версии?", "query": "select model from car_names group by model order by count ( * ) desc limit 1", "predicted_sql": "select model_list.model from model_list group by model_list.model having count ( distinct model_list.modelid ) = ( select max ( count ) from ( select count ( distinct model_list.modelid ) as count from model_list group by model_list.model ) as subquery )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая модель имеет самые разные версии? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько автомобилей имеют более 4 цилиндров?", "query": "select count ( * ) from cars_data where cylinders > 4", "predicted_sql": "select count ( * ) from cars_data where cylinders > 4", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько автомобилей имеют более 4 цилиндров? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какое количество автомобилей с более чем 4 цилиндрами?", "query": "select count ( * ) from cars_data where cylinders > 4", "predicted_sql": "select count ( * ) from cars_data where cylinders > 4", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какое количество автомобилей с более чем 4 цилиндрами? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "сколько машин было выпущено в 1980 году?", "query": "select count ( * ) from cars_data where year = 1980", "predicted_sql": "select count ( * ) from cars_data where year = 1980", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### сколько машин было выпущено в 1980 году? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько машин было произведено в 1980 году?", "query": "select count ( * ) from cars_data where year = 1980", "predicted_sql": "select count ( * ) from cars_data where year = 1980", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько машин было произведено в 1980 году? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько моделей автомобилей выпустил производитель с полным названием АвтоВАЗ?", "query": "select count ( * ) from car_makers join model_list on car_makers.id = model_list.maker where car_makers.fullname = 'АвтоВАЗ'", "predicted_sql": "select count ( model_list.model ) from car_makers join model_list on model_list.maker = car_makers.id where car_makers.fullname = 'АвтоВАЗ'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker ( автоваз ) , car_makers.fullname ( АвтоВАЗ ) , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько моделей автомобилей выпустил производитель с полным названием АвтоВАЗ? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько моделей автомобилей выпускает автопроизводитель АвтоВАЗ?", "query": "select count ( * ) from car_makers join model_list on car_makers.id = model_list.maker where car_makers.fullname = 'АвтоВАЗ'", "predicted_sql": "select count ( model_list.model ) from car_makers join model_list on model_list.maker = car_makers.id where car_makers.fullname = 'АвтоВАЗ'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker ( автоваз ) , car_makers.fullname ( АвтоВАЗ ) , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько моделей автомобилей выпускает автопроизводитель АвтоВАЗ? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какие производители разработали более трех моделей автомобилей? Показать полное имя и id.", "query": "select car_makers.fullname , car_makers.id from car_makers join model_list on car_makers.id = model_list.maker group by car_makers.id having count ( * ) > 3", "predicted_sql": "select car_makers.id  , car_makers.fullname from car_makers join model_list on model_list.maker = car_makers.id group by car_makers.id  , car_makers.fullname having count ( model_list.model ) > 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какие производители разработали более трех моделей автомобилей? Показать полное имя и id. \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Как называются и какие id у всех производителей, выпускающих более трех моделей?", "query": "select car_makers.fullname , car_makers.id from car_makers join model_list on car_makers.id = model_list.maker group by car_makers.id having count ( * ) > 3", "predicted_sql": "select car_makers.maker  , car_makers.id from car_makers join model_list on model_list.maker = car_makers.id group by car_makers.maker having count ( model_list.model ) > 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Как называются и какие id у всех производителей, выпускающих более трех моделей? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какие разные модели выпускает производитель с полным названием General Motors или которые весят более 3500?", "query": "select distinct model_list.model from car_names join model_list on car_names.model = model_list.model join car_makers on model_list.maker = car_makers.id join cars_data on car_names.makeid = cars_data.id where car_makers.fullname = 'General Motors' or cars_data.weight > 3500", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname ( General Motors ) , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какие разные модели выпускает производитель с полным названием General Motors или которые весят более 3500? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какие разные модели созданы автопроизводителем General Motors или весят более 3500?", "query": "select distinct model_list.model from car_names join model_list on car_names.model = model_list.model join car_makers on model_list.maker = car_makers.id join cars_data on car_names.makeid = cars_data.id where car_makers.fullname = 'General Motors' or cars_data.weight > 3500", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname ( General Motors ) , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какие разные модели созданы автопроизводителем General Motors или весят более 3500? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "В какие годы выпускались автомобили массой не менее 3000 и не более 4000?", "query": "select distinct year from cars_data where weight between 3000 and 4000", "predicted_sql": "select cars_data.year from cars_data where cars_data.weight >= 3000 and cars_data.weight <= 4000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### В какие годы выпускались автомобили массой не менее 3000 и не более 4000? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "В какие разные годы выпускались автомобили весом менее 4000, а также автомобили весом более 3000?", "query": "select distinct year from cars_data where weight between 3000 and 4000", "predicted_sql": "select distinct year from cars_data where weight < 4000 or weight > 3000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### В какие разные годы выпускались автомобили весом менее 4000, а также автомобили весом более 3000? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая мощность у машины с наибольшим разгоном?", "query": "select cars_data.horsepower from cars_data order by cars_data.accelerate desc limit 1", "predicted_sql": "select cars_data.horsepower from cars_data order by cars_data.accelerate desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая мощность у машины с наибольшим разгоном? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая мощность у машины с наибольшим разгоном?", "query": "select cars_data.horsepower from cars_data order by cars_data.accelerate desc limit 1", "predicted_sql": "select cars_data.horsepower from cars_data order by cars_data.accelerate desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая мощность у машины с наибольшим разгоном? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Для модели Volvo, сколько цилиндров у автомобиля с наименьшим ускорением?", "query": "select cars_data.cylinders from cars_data join car_names on cars_data.id = car_names.makeid where car_names.model = 'volvo' order by cars_data.accelerate asc limit 1", "predicted_sql": "select min ( cars_data.accelerate ) as min_accelerate  , cars_data.cylinders from cars_data join car_names on cars_data.id = car_names.makeid join model_list on car_names.model = model_list.model join car_makers on model_list.maker = car_makers.id where car_makers.maker = 'volvo' group by cars_data.cylinders order by min_accelerate asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker ( volvo ) , car_makers.fullname ( Volvo ) , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model ( volvo ) | car_names : car_names.makeid , car_names.model ( volvo ) , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Для модели Volvo, сколько цилиндров у автомобиля с наименьшим ускорением? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько цилиндров у модели Volvo с наименьшим ускорением?", "query": "select cars_data.cylinders from cars_data join car_names on cars_data.id = car_names.makeid where car_names.model = 'volvo' order by cars_data.accelerate asc limit 1", "predicted_sql": "select cars_data.cylinders from cars_data join car_names on cars_data.id = car_names.makeid join model_list on car_names.model = model_list.model join car_makers on model_list.maker = car_makers.id where car_makers.maker = 'volvo' order by cars_data.accelerate asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker ( volvo ) , car_makers.fullname ( Volvo ) , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model ( volvo ) | car_names : car_names.makeid , car_names.model ( volvo ) , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько цилиндров у модели Volvo с наименьшим ускорением? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько автомобилей имеют больший разгон, чем автомобиль с самой большой мощностью?", "query": "select count ( * ) from cars_data where accelerate > ( select accelerate from cars_data order by horsepower desc limit 1 )", "predicted_sql": "select count ( * ) from cars_data where accelerate > ( select max ( horsepower ) from cars_data )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько автомобилей имеют больший разгон, чем автомобиль с самой большой мощностью? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какое количество автомобилей демонстрирует более высокий разгон, чем автомобиль с наибольшим количеством лошадиных сил?", "query": "select count ( * ) from cars_data where accelerate > ( select accelerate from cars_data order by horsepower desc limit 1 )", "predicted_sql": "select count ( * ) from cars_data where accelerate > ( select max ( horsepower ) from cars_data )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какое количество автомобилей демонстрирует более высокий разгон, чем автомобиль с наибольшим количеством лошадиных сил? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "В скольких странах более двух автопроизводителей?", "query": "select count ( * ) from countries join car_makers on countries.countryid = car_makers.country group by countries.countryid having count ( * ) > 2", "predicted_sql": "select count ( distinct countries.countryname ) from car_makers join countries on car_makers.country = countries.countryid group by countries.countryname having count ( distinct car_makers.id ) > 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### В скольких странах более двух автопроизводителей? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "В каком количестве стран имеется более двух автопроизводителей?", "query": "select count ( * ) from countries join car_makers on countries.countryid = car_makers.country group by countries.countryid having count ( * ) > 2", "predicted_sql": "select count ( distinct countries.countryname ) from countries join car_makers on countries.countryid = car_makers.country group by countries.countryname having count ( distinct car_makers.id ) > 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### В каком количестве стран имеется более двух автопроизводителей? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько автомобилей имеет более 6 цилиндров?", "query": "select count ( * ) from cars_data where cylinders > 6", "predicted_sql": "select count ( * ) from cars_data where cylinders > 6", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько автомобилей имеет более 6 цилиндров? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Сколько автомобилей с более чем 6 цилиндрами?", "query": "select count ( * ) from cars_data where cylinders > 6", "predicted_sql": "select count ( * ) from cars_data where cylinders > 6", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Сколько автомобилей с более чем 6 цилиндрами? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая модель имеет самую большую мощность для автомобилей с 4 цилиндрами?", "query": "select car_names.model from car_names join cars_data on car_names.makeid = cars_data.id where cars_data.cylinders = 4 order by cars_data.horsepower desc limit 1", "predicted_sql": "select model_list.model from model_list join cars_data on model_list.modelid = cars_data.id where cars_data.cylinders = 4 order by cars_data.horsepower desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая модель имеет самую большую мощность для автомобилей с 4 цилиндрами? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какая модель из всех 4-цилиндровых автомобилей имеет наибольшую мощность?", "query": "select car_names.model from car_names join cars_data on car_names.makeid = cars_data.id where cars_data.cylinders = 4 order by cars_data.horsepower desc limit 1", "predicted_sql": "select model_list.model from cars_data join car_names on cars_data.id = car_names.makeid join model_list on car_names.model = model_list.model where cars_data.cylinders = 4 order by cars_data.horsepower desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какая модель из всех 4-цилиндровых автомобилей имеет наибольшую мощность? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Среди автомобилей с более чем самой низкой мощностью у каких не более 3 цилиндров? Покажи марку автомобиля и id производителя.", "query": "select car_names.makeid , car_names.make from cars_data join car_names on cars_data.id = car_names.makeid where cars_data.horsepower > ( select min ( horsepower ) from cars_data ) and cars_data.cylinders <= 3", "predicted_sql": "select car_names.makeid  , car_makers.id from cars_data join car_names on cars_data.id = car_names.makeid join model_list on car_names.model = model_list.model join car_makers on model_list.maker = car_makers.id where cars_data.horsepower = ( select min ( horsepower ) from cars_data ) and cars_data.cylinders <= 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Среди автомобилей с более чем самой низкой мощностью у каких не более 3 цилиндров? Покажи марку автомобиля и id производителя. \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Среди автомобилей, которые не имеют минимальной мощности, каковы id производителей и названия всех автомобилей с менее чем 4 цилиндрами?", "query": "select car_names.makeid , car_names.make from cars_data join car_names on cars_data.id = car_names.makeid where cars_data.horsepower > ( select min ( horsepower ) from cars_data ) and cars_data.cylinders < 4", "predicted_sql": "select car_makers.id  , car_names.make from car_makers join model_list on model_list.maker = car_makers.id join car_names on car_names.model = model_list.model join cars_data on cars_data.id = car_names.makeid where cars_data.horsepower > ( select min ( horsepower ) from cars_data ) and cars_data.cylinders < 4", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Среди автомобилей, которые не имеют минимальной мощности, каковы id производителей и названия всех автомобилей с менее чем 4 цилиндрами? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какое максимальное количество километров на литр у автомобиля с 8 цилиндрами или произведенного до 1980 года?", "query": "select max ( mpg ) from cars_data where cylinders = 8 or year < 1980", "predicted_sql": "select max ( cars_data.mpg ) from cars_data where cars_data.cylinders = 8 and cars_data.year <= 1980", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какое максимальное количество километров на литр у автомобиля с 8 цилиндрами или произведенного до 1980 года? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Каков максимальный расход топлива для автомобилей с 8 цилиндрами или автомобилей, выпущенных до 1980 года?", "query": "select max ( mpg ) from cars_data where cylinders = 8 or year < 1980", "predicted_sql": "select max ( cars_data.mpg ) from cars_data where cars_data.cylinders = 8 or cars_data.year < 1980", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Каков максимальный расход топлива для автомобилей с 8 цилиндрами или автомобилей, выпущенных до 1980 года? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какие модели легче 3500, но не производятся Ford Motor Company?", "query": "select distinct model_list.model from model_list join car_names on model_list.model = car_names.model join cars_data on car_names.makeid = cars_data.id join car_makers on model_list.maker = car_makers.id where cars_data.weight < 3500 and car_makers.fullname != 'Ford Motor Company'", "predicted_sql": "select model_list.model from model_list join car_makers on model_list.maker = car_makers.id join car_names on model_list.model = car_names.model join cars_data on car_names.makeid = cars_data.id where cars_data.weight < 3500 and car_makers.fullname  != 'Ford Motor Company'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker ( ford ) , car_makers.fullname ( Ford Motor Company ) , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model ( ford ) | car_names : car_names.makeid , car_names.model ( ford ) , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какие модели легче 3500, но не производятся Ford Motor Company? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какие модели легче 3500, но не были произведены Ford Motor Company?", "query": "select distinct model_list.model from model_list join car_names on model_list.model = car_names.model join cars_data on car_names.makeid = cars_data.id join car_makers on model_list.maker = car_makers.id where cars_data.weight < 3500 and car_makers.fullname != 'Ford Motor Company'", "predicted_sql": "select model_list.model from model_list join car_makers on model_list.maker = car_makers.id join car_names on model_list.model = car_names.model join cars_data on car_names.makeid = cars_data.id where cars_data.weight < 3500 and car_makers.fullname  != 'Ford Motor Company'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker ( ford ) , car_makers.fullname ( Ford Motor Company ) , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model ( ford ) | car_names : car_names.makeid , car_names.model ( ford ) , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какие модели легче 3500, но не были произведены Ford Motor Company? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Как называются страны, где нет ни одного автопроизводителя?", "query": "select countryname from countries except select countries.countryname from countries join car_makers on countries.countryid = car_makers.country", "predicted_sql": "select countries.countryname from countries where countries.countryid not in ( select car_makers.country from car_makers )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Как называются страны, где нет ни одного автопроизводителя? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Как называются страны, в которых нет производителей автомобилей?", "query": "select countryname from countries except select countries.countryname from countries join car_makers on countries.countryid = car_makers.country", "predicted_sql": "select countries.countryname from countries where countries.countryid not in ( select car_makers.country from car_makers )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Как называются страны, в которых нет производителей автомобилей? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Какие производители автомобилей производят не менее 2 моделей и более 3 автомобилей? Показать id и марку машины.", "query": "select car_makers.id , car_makers.maker from car_makers join model_list on car_makers.id = model_list.maker group by car_makers.id having count ( * ) >= 2 intersect select car_makers.id , car_makers.maker from car_makers join model_list on car_makers.id = model_list.maker join car_names on model_list.model = car_names.model group by car_makers.id having count ( * ) > 3", "predicted_sql": "select car_makers.id  , car_makers.maker from car_makers join model_list on model_list.maker = car_makers.id join car_names on car_names.model = model_list.model group by car_makers.id  , car_makers.maker having count ( distinct model_list.modelid ) >= 2 and count ( distinct car_names.makeid ) > 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Какие производители автомобилей производят не менее 2 моделей и более 3 автомобилей? Показать id и марку машины. \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Каковы id и марки машин всех автопроизводителей, которые производят как минимум 2 модели и более 3 автомобилей?", "query": "select car_makers.id , car_makers.maker from car_makers join model_list on car_makers.id = model_list.maker group by car_makers.id having count ( * ) >= 2 intersect select car_makers.id , car_makers.maker from car_makers join model_list on car_makers.id = model_list.maker join car_names on model_list.model = car_names.model group by car_makers.id having count ( * ) > 3", "predicted_sql": "select car_makers.id  , car_makers.maker from car_makers join model_list on model_list.maker = car_makers.id join car_names on car_names.model = model_list.model group by car_makers.id  , car_makers.maker having count ( distinct model_list.modelid ) >= 2 and count ( distinct car_names.makeid ) > 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Каковы id и марки машин всех автопроизводителей, которые производят как минимум 2 модели и более 3 автомобилей? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Каковы id и названия стран, в которых имеется более 3 производителей автомобилей или которые производят модель «Fiat»?", "query": "select countries.countryid , countries.countryname from countries join car_makers on countries.countryid = car_makers.country group by countries.countryid having count ( * ) > 3 union select countries.countryid , countries.countryname from countries join car_makers on countries.countryid = car_makers.country join model_list on car_makers.id = model_list.maker where model_list.model = 'fiat'", "predicted_sql": "select countries.countryid  , countries.countryname from countries where countries.countryid in ( select car_makers.country from car_makers group by car_makers.country having count ( distinct car_makers.id ) > 3 ) or countries.countryid in ( select countries.countryid from countries inner join car_makers on car_makers.country = countries.countryid inner join model_list on model_list.maker = car_makers.id inner join car_names on car_names.model = model_list.model where car_names.make = 'Fiat' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker , car_makers.fullname , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model | car_names : car_names.makeid , car_names.model , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Каковы id и названия стран, в которых имеется более 3 производителей автомобилей или которые производят модель «Fiat»? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "car_1", "question": "Каковы id и названия всех стран, в которых либо более трех производителей автомобилей, либо производятся модели Fiat?", "query": "select countries.countryid , countries.countryname from countries join car_makers on countries.countryid = car_makers.country group by countries.countryid having count ( * ) > 3 union select countries.countryid , countries.countryname from countries join car_makers on countries.countryid = car_makers.country join model_list on car_makers.id = model_list.maker where model_list.model = 'fiat'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker ( fiat ) , car_makers.fullname ( Fiat ) , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model ( fiat ) | car_names : car_names.makeid , car_names.model ( fiat ) , car_names.make | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Каковы id и названия всех стран, в которых либо более трех производителей автомобилей, либо производятся модели Fiat? \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "flight_2", "question": "К какой стране принадлежит авиакомпания S7?", "query": "select country from airlines where airline = 'S7'", "predicted_sql": "select airlines.country from airlines where airlines.airline = 'S7'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( S7 ) , airlines.abbreviation ( S7 ) , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### К какой стране принадлежит авиакомпания S7? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Из какой страны авиакомпания S7?", "query": "select country from airlines where airline = 'S7'", "predicted_sql": "select airlines.country from airlines where airlines.airline = 'S7'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( S7 ) , airlines.abbreviation ( S7 ) , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Из какой страны авиакомпания S7? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какое сокращение у авиакомпании JetBlue Airways?", "query": "select abbreviation from airlines where airline = 'JetBlue Airways'", "predicted_sql": "select airlines.abbreviation from airlines where airlines.airline = 'JetBlue Airways'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( JetBlue Airways ) , airlines.abbreviation ( JetBlue ) , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какое сокращение у авиакомпании JetBlue Airways? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какая аббревиатура соответствует Jetblue Airways?", "query": "select abbreviation from airlines where airline = 'JetBlue Airways'", "predicted_sql": "select abbreviation from airlines where airline = 'JetBlue Airways'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( JetBlue Airways ) , airlines.abbreviation ( JetBlue ) , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какая аббревиатура соответствует Jetblue Airways? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Перечислите все названия авиакомпаний и их сокращения в «России».", "query": "select airline , abbreviation from airlines where country = 'Россия'", "predicted_sql": "select airlines.airline  , airlines.abbreviation from airlines where airlines.country = 'Россия'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Перечислите все названия авиакомпаний и их сокращения в «России». \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие названия авиакомпаний и аббревиатуры авиакомпаний в России?", "query": "select airline , abbreviation from airlines where country = 'Россия'", "predicted_sql": "select airlines.airline  , airlines.abbreviation from airlines where airlines.country = 'Russia'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие названия авиакомпаний и аббревиатуры авиакомпаний в России? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Укажите код и название аэропорта в городе Анапа.", "query": "select airportcode , airportname from airports where city = 'Анапа'", "predicted_sql": "select airports.airportcode  , airports.airportname from airports where airports.city = 'Анапа'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Анапа ) , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Укажите код и название аэропорта в городе Анапа. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Укажите код аэропорта и название аэропорта, соответствующие городу Анапа.", "query": "select airportcode , airportname from airports where city = 'Анапа'", "predicted_sql": "select airports.airportcode  , airports.airportname from airports where airports.city = 'Анапа'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Анапа ) , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Укажите код аэропорта и название аэропорта, соответствующие городу Анапа. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько у нас авиакомпаний?", "query": "select count ( * ) from airlines", "predicted_sql": "select count ( distinct airline ) from airlines", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько у нас авиакомпаний? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какое общее количество авиакомпаний?", "query": "select count ( * ) from airlines", "predicted_sql": "select count ( distinct airline ) from airlines", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какое общее количество авиакомпаний? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько у нас аэропортов?", "query": "select count ( * ) from airports", "predicted_sql": "select count ( * ) from airports", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько у нас аэропортов? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Показать количество аэропортов.", "query": "select count ( * ) from airports", "predicted_sql": "select count ( * ) from airports", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Показать количество аэропортов. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько у нас рейсов?", "query": "select count ( * ) from flights", "predicted_sql": "select count ( * ) from flights", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько у нас рейсов? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Показать количество рейсов.", "query": "select count ( * ) from flights", "predicted_sql": "select count ( * ) from flights", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Показать количество рейсов. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "У какой авиакомпании есть аббревиатура UAL?", "query": "select airline from airlines where abbreviation = 'UAL'", "predicted_sql": "select airline from airlines where abbreviation = 'UAL'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation ( UAL ) , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### У какой авиакомпании есть аббревиатура UAL? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Укажите авиакомпанию с сокращением «UAL».", "query": "select airline from airlines where abbreviation = 'UAL'", "predicted_sql": "select airline from airlines where abbreviation = 'UAL'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Укажите авиакомпанию с сокращением «UAL». \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько авиакомпаний из России?", "query": "select count ( * ) from airlines where country = 'Россия'", "predicted_sql": "select count ( * ) from airlines where country = 'Russia'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько авиакомпаний из России? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Показать количество авиакомпаний в России.", "query": "select count ( * ) from airlines where country = 'Россия'", "predicted_sql": "select count ( * ) from airlines where country = 'Russia'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Показать количество авиакомпаний в России. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "В каком городе и стране находится аэропорт Внуково?", "query": "select city , country from airports where airportname = 'Внуково'", "predicted_sql": "select airports.city  , airports.country from airports where airports.airportname = 'Внуково'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname ( Внуково ) , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### В каком городе и стране находится аэропорт Внуково? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Указать город и страну для аэропорта Внуково.", "query": "select city , country from airports where airportname = 'Внуково'", "predicted_sql": "select airports.city  , airports.country from airports where airports.airportname = 'Внуково'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname ( Внуково ) , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Указать город и страну для аэропорта Внуково. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Как называется аэропорт VKO?", "query": "select airportname from airports where airportcode = 'VKO'", "predicted_sql": "select airportname from airports where airportcode = 'VKO'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( VKO ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( VKO ) , flights.destairport ( VKO ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Как называется аэропорт VKO? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Верните название аэропорта с кодом «VКО».", "query": "select airportname from airports where airportcode = 'VKO'", "predicted_sql": "select airportname from airports where airportcode = 'VКО'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Верните название аэропорта с кодом «VКО». \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Как называются аэропорты в городе Москва?", "query": "select airportname from airports where city = 'Москва'", "predicted_sql": "select airports.airportname from airports where airports.city = 'Москва'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Москва ) , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Как называются аэропорты в городе Москва? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Как называются аэропорты в Москве?", "query": "select airportname from airports where city = 'Москва'", "predicted_sql": "select airports.airportname from airports where airports.city = 'Москва'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Как называются аэропорты в Москве? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько рейсов отправляется из APG?", "query": "select count ( * ) from flights where sourceairport = 'APG'", "predicted_sql": "select count ( * ) from flights where sourceairport = 'APG'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( APG ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( APG ) , flights.destairport ( APG ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько рейсов отправляется из APG? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Подсчитайте количество рейсов, вылетающих из «APG».", "query": "select count ( * ) from flights where sourceairport = 'APG'", "predicted_sql": "select count ( * ) from flights where sourceairport = 'APG'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Подсчитайте количество рейсов, вылетающих из «APG». \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько рейсов имеет пункт назначения ATO?", "query": "select count ( * ) from flights where destairport = 'ATO'", "predicted_sql": "select count ( * ) from flights where destairport = 'ATO'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( ATO ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( ATO ) , flights.destairport ( ATO ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько рейсов имеет пункт назначения ATO? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Подсчитайте количество рейсов в АТО.", "query": "select count ( * ) from flights where destairport = 'ATO'", "predicted_sql": "select count ( * ) from flights where flights.airline = 'ATO'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Подсчитайте количество рейсов в АТО. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько рейсов вылетает из города Челябинск?", "query": "select count ( * ) from flights join airports on flights.sourceairport = airports.airportcode where airports.city = 'Челябинск'", "predicted_sql": "select count ( * ) from flights where sourceairport = ( select airportcode from airports where city = 'Челябинск' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Челябинск ) , airports.airportcode , airports.airportname ( Челябинск ) , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько рейсов вылетает из города Челябинск? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Показать количество рейсов, вылетающих из Челябинска.", "query": "select count ( * ) from flights join airports on flights.sourceairport = airports.airportcode where airports.city = 'Челябинск'", "predicted_sql": "select count ( * ) from flights where sourceairport = ( select airportcode from airports where city = 'Челябинск' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Челябинск ) , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Показать количество рейсов, вылетающих из Челябинска. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько рейсов прибывает в город Челябинск?", "query": "select count ( * ) from flights join airports on flights.destairport = airports.airportcode where airports.city = 'Челябинск'", "predicted_sql": "select count ( * ) from flights join airports on flights.destairport = airports.airportcode where airports.city = 'Челябинск'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Челябинск ) , airports.airportcode , airports.airportname ( Челябинск ) , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько рейсов прибывает в город Челябинск? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Показать количество рейсов, прибывающих в Челябинск.", "query": "select count ( * ) from flights join airports on flights.destairport = airports.airportcode where airports.city = 'Челябинск'", "predicted_sql": "select count ( * ) from flights where flights.destairport = ( select airports.airportcode from airports where airports.city = 'Челябинск' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Челябинск ) , airports.airportcode , airports.airportname ( Челябинск ) , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Показать количество рейсов, прибывающих в Челябинск. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько рейсов отправляется из города Воронеж в город Калининград?", "query": "select count ( * ) from flights join airports on flights.destairport = airports.airportcode join airports on flights.sourceairport = airports.airportcode where airports.city = 'Калининград' and airports.city = 'Воронеж'", "predicted_sql": "select count ( * ) from flights where flights.sourceairport = ( select airports.airportcode from airports where airports.city = 'Воронеж' ) and flights.destairport = ( select airports.airportcode from airports where airports.city = 'Калининград' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Воронеж , Калининград ) , airports.airportcode , airports.airportname ( Воронеж ) , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько рейсов отправляется из города Воронеж в город Калининград? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько рейсов летают по направлению Воронеж - Калининград?", "query": "select count ( * ) from flights join airports on flights.destairport = airports.airportcode join airports on flights.sourceairport = airports.airportcode where airports.city = 'Калининград' and airports.city = 'Воронеж'", "predicted_sql": "select count ( * ) from flights where flights.sourceairport = ( select airports.airportcode from airports where airports.city = 'Воронеж' ) and flights.destairport = ( select airports.airportcode from airports where airports.city = 'Калининград' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Воронеж , Калининград ) , airports.airportcode , airports.airportname ( Воронеж ) , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько рейсов летают по направлению Воронеж - Калининград? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько рейсов выполняет авиакомпания Аэрофлот?", "query": "select count ( * ) from flights join airlines on flights.airline = airlines.uid where airlines.airline = 'Аэрофлот'", "predicted_sql": "select count ( * ) from flights where airline = 'Аэрофлот'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( Аэрофлот ) , airlines.abbreviation ( Аэрофлот ) , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько рейсов выполняет авиакомпания Аэрофлот? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Укажите количество рейсов Аэрофлота.", "query": "select count ( * ) from flights join airlines on flights.airline = airlines.uid where airlines.airline = 'Аэрофлот'", "predicted_sql": "select count ( * ) from flights where airline = 'Аэрофлот'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( Аэрофлот ) , airlines.abbreviation ( Аэрофлот ) , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Укажите количество рейсов Аэрофлота. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько рейсов Аэрофлота летает в аэропорт KGD?", "query": "select count ( * ) from airlines join flights on flights.airline = airlines.uid where airlines.airline = 'Аэрофлот' and flights.destairport = 'KGD'", "predicted_sql": "select count ( * ) from flights where flights.airline = 'Аэрофлот' and flights.destairport = 'KGD'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( Аэрофлот ) , airlines.abbreviation ( Аэрофлот ) , airlines.country | airports : airports.city , airports.airportcode ( KGD ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( KGD ) , flights.destairport ( KGD ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько рейсов Аэрофлота летает в аэропорт KGD? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Подсчитайте количество рейсов Аэрофлота, прибывающих в аэропорт KGD.", "query": "select count ( * ) from airlines join flights on flights.airline = airlines.uid where airlines.airline = 'Аэрофлот' and flights.destairport = 'KGD'", "predicted_sql": "select count ( * ) from flights where flights.airline = 'Аэрофлот' and flights.destairport = 'KGD'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( Аэрофлот ) , airlines.abbreviation ( Аэрофлот ) , airlines.country | airports : airports.city , airports.airportcode ( KGD ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( KGD ) , flights.destairport ( KGD ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Подсчитайте количество рейсов Аэрофлота, прибывающих в аэропорт KGD. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько рейсов Победа отправляется из аэропорта CEK?", "query": "select count ( * ) from airlines join flights on flights.airline = airlines.uid where airlines.airline = 'Победа' and flights.sourceairport = 'CEK'", "predicted_sql": "select count ( * ) from flights where flights.airline = 'Победа' and flights.sourceairport = 'CEK'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( Победа ) , airlines.abbreviation ( Победа ) , airlines.country | airports : airports.city , airports.airportcode ( CEK ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( CEK ) , flights.destairport ( CEK ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько рейсов Победа отправляется из аэропорта CEK? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Показать количество рейсов Аэрофлота, вылетающих из аэропорта KGD.", "query": "select count ( * ) from airlines join flights on flights.airline = airlines.uid where airlines.airline = 'Аэрофлот' and flights.sourceairport = 'KGD'", "predicted_sql": "select count ( * ) from flights where flights.airline = 'Аэрофлот' and flights.sourceairport = 'KGD'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( Аэрофлот ) , airlines.abbreviation ( Аэрофлот ) , airlines.country | airports : airports.city , airports.airportcode ( KGD ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( KGD ) , flights.destairport ( KGD ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Показать количество рейсов Аэрофлота, вылетающих из аэропорта KGD. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько рейсов S7 летает в город Челябинск?", "query": "select count ( * ) from flights join airports on flights.destairport = airports.airportcode join airlines on airlines.uid = flights.airline where airports.city = 'Челябинск' and airlines.airline = 'S7'", "predicted_sql": "select count ( * ) from flights where flights.airline = 'S7' and flights.destairport = 'Челябинск'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( S7 ) , airlines.abbreviation ( S7 ) , airlines.country | airports : airports.city ( Челябинск ) , airports.airportcode , airports.airportname ( Челябинск ) , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько рейсов S7 летает в город Челябинск? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Подсчитайте количество рейсов S7, прибывающих в Москву.", "query": "select count ( * ) from flights join airports on flights.destairport = airports.airportcode join airlines on airlines.uid = flights.airline where airports.city = 'Москва' and airlines.airline = 'S7'", "predicted_sql": "select count ( * ) from flights where flights.airline = 'S7' and flights.destairport = 'MOW'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( S7 ) , airlines.abbreviation ( S7 ) , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Подсчитайте количество рейсов S7, прибывающих в Москву. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "В какой город прибывает больше всего рейсов?", "query": "select airports.city from airports join flights on airports.airportcode = flights.destairport group by airports.city order by count ( * ) desc limit 1", "predicted_sql": "select flights.destairport as city  , count ( * ) as num_flights from flights group by flights.destairport order by num_flights desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### В какой город прибывает больше всего рейсов? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "В какой аэропорт города чаще всего прибывают рейсы?", "query": "select airports.city from airports join flights on airports.airportcode = flights.destairport group by airports.city order by count ( * ) desc limit 1", "predicted_sql": "select airports.city  , count ( flights.destairport ) as arrival_count from airports join flights on flights.destairport = airports.airportcode group by airports.city order by arrival_count desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### В какой аэропорт города чаще всего прибывают рейсы? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Из какого города вылетает больше всего рейсов?", "query": "select airports.city from airports join flights on airports.airportcode = flights.sourceairport group by airports.city order by count ( * ) desc limit 1", "predicted_sql": "select flights.sourceairport  , count ( * ) as num_flights from flights group by flights.sourceairport order by num_flights desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Из какого города вылетает больше всего рейсов? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Из аэропорта какого города чаще всего отправляются рейсы?", "query": "select airports.city from airports join flights on airports.airportcode = flights.sourceairport group by airports.city order by count ( * ) desc limit 1", "predicted_sql": "select airports.city from flights join airports on flights.sourceairport = airports.airportcode group by airports.city order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Из аэропорта какого города чаще всего отправляются рейсы? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Каков код аэропорта, в котором больше всего рейсов?", "query": "select airports.airportcode from airports join flights on airports.airportcode = flights.destairport or airports.airportcode = flights.sourceairport group by airports.airportcode order by count ( * ) desc limit 1", "predicted_sql": "select airports.airportcode from airports join flights on flights.destairport = airports.airportcode group by airports.airportcode order by count ( flights.flightno ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Каков код аэропорта, в котором больше всего рейсов? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Каков код аэропорта с наибольшим количеством рейсов?", "query": "select airports.airportcode from airports join flights on airports.airportcode = flights.destairport or airports.airportcode = flights.sourceairport group by airports.airportcode order by count ( * ) desc limit 1", "predicted_sql": "select airports.airportcode from airports join flights on flights.destairport = airports.airportcode group by airports.airportcode order by count ( flights.flightno ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Каков код аэропорта с наибольшим количеством рейсов? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Каков код аэропорта, в котором меньше всего рейсов?", "query": "select airports.airportcode from airports join flights on airports.airportcode = flights.destairport or airports.airportcode = flights.sourceairport group by airports.airportcode order by count ( * ) asc limit 1", "predicted_sql": "select airports.airportcode from airports join flights on flights.destairport = airports.airportcode group by airports.airportcode order by count ( flights.flightno ) asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Каков код аэропорта, в котором меньше всего рейсов? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Укажите код аэропорта с наименьшим количеством рейсов.", "query": "select airports.airportcode from airports join flights on airports.airportcode = flights.destairport or airports.airportcode = flights.sourceairport group by airports.airportcode order by count ( * ) asc limit 1", "predicted_sql": "select airports.airportcode from airports join flights on flights.destairport = airports.airportcode group by airports.airportcode order by count ( flights.flightno ) asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Укажите код аэропорта с наименьшим количеством рейсов. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "У какой авиакомпании больше всего рейсов?", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline group by airlines.airline order by count ( * ) desc limit 1", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline group by airlines.airline order by count ( flights.flightno ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### У какой авиакомпании больше всего рейсов? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какая авиакомпания обслуживает больше всего рейсов?", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline group by airlines.airline order by count ( * ) desc limit 1", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline group by airlines.airline order by count ( flights.flightno ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какая авиакомпания обслуживает больше всего рейсов? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Найдите аббревиатуру и страну авиакомпании, у которой меньше всего рейсов", "query": "select airlines.abbreviation , airlines.country from airlines join flights on airlines.uid = flights.airline group by airlines.airline order by count ( * ) asc limit 1", "predicted_sql": "select airlines.abbreviation  , airlines.country from airlines join flights on airlines.uid = flights.airline group by airlines.abbreviation  , airlines.country order by count ( flights.flightno ) asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Найдите аббревиатуру и страну авиакомпании, у которой меньше всего рейсов \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какая аббревиатура авиакомпании имеет наименьшее количество рейсов и в какой стране она находится?", "query": "select airlines.abbreviation , airlines.country from airlines join flights on airlines.uid = flights.airline group by airlines.airline order by count ( * ) asc limit 1", "predicted_sql": "select airlines.abbreviation  , airlines.country from airlines join flights on flights.airline = airlines.airline group by airlines.abbreviation  , airlines.country order by count ( flights.flightno ) asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какая аббревиатура авиакомпании имеет наименьшее количество рейсов и в какой стране она находится? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие авиакомпании вылетают некоторыми рейсами из аэропорта AHD?", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.sourceairport = 'AHD'", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline join airports on flights.sourceairport = airports.airportcode where airports.airportcode = 'AHD'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( AHD ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( AHD ) , flights.destairport ( AHD ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие авиакомпании вылетают некоторыми рейсами из аэропорта AHD? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие авиакомпании летают из аэропорта AHD?", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.sourceairport = 'AHD'", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline join airports on flights.sourceairport = airports.airportcode where airports.airportcode = 'AHD'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( AHD ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( AHD ) , flights.destairport ( AHD ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие авиакомпании летают из аэропорта AHD? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие авиакомпании имеют рейсы, прибывающие в аэропорт AHD?", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.destairport = 'AHD'", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline join airports on flights.destairport = airports.airportcode where airports.airportcode = 'AHD'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( AHD ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( AHD ) , flights.destairport ( AHD ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие авиакомпании имеют рейсы, прибывающие в аэропорт AHD? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие авиакомпании летают в аэропорт назначения AHD?", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.destairport = 'AHD'", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline join airports on flights.destairport = airports.airportcode where airports.airportcode = 'AHD'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( AHD ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( AHD ) , flights.destairport ( AHD ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие авиакомпании летают в аэропорт назначения AHD? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Найдите все авиакомпании, у которых есть рейсы из обоих аэропортов \"APG\" и \"CVO\".", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.sourceairport = 'APG' intersect select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.sourceairport = 'CVO'", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.sourceairport = 'APG' and flights.destairport = 'CVO' group by airlines.airline", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( APG , CVO ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( APG , CVO ) , flights.destairport ( APG , CVO ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Найдите все авиакомпании, у которых есть рейсы из обоих аэропортов \"APG\" и \"CVO\". \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие авиакомпании вылетают из аэропортов APG и CVO?", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.sourceairport = 'APG' intersect select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.sourceairport = 'CVO'", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.sourceairport in ( 'APG'  , 'CVO' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( APG , CVO ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( APG , CVO ) , flights.destairport ( APG , CVO ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие авиакомпании вылетают из аэропортов APG и CVO? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Найдите все авиакомпании, у которых есть рейсы из аэропорта \"CVO\", но не из аэропорта \"APG\".", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.sourceairport = 'CVO' except select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.sourceairport = 'APG'", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline join airports on flights.sourceairport = airports.airportcode where airports.airportcode = 'CVO' and airlines.airline not in ( select airlines.airline from airlines join flights on airlines.uid = flights.airline join airports on flights.sourceairport = airports.airportcode where airports.airportcode = 'APG' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( APG , CVO ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( APG , CVO ) , flights.destairport ( APG , CVO ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Найдите все авиакомпании, у которых есть рейсы из аэропорта \"CVO\", но не из аэропорта \"APG\". \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие авиакомпании вылетают из CVO, но не из аэропортов APG?", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.sourceairport = 'CVO' except select airlines.airline from airlines join flights on airlines.uid = flights.airline where flights.sourceairport = 'APG'", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline join airports on flights.sourceairport = airports.airportcode where airports.city = 'CVO' and airports.airportcode  != 'APG'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( APG , CVO ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( APG , CVO ) , flights.destairport ( APG , CVO ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие авиакомпании вылетают из CVO, но не из аэропортов APG? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Найдите все авиакомпании, у которых есть не менее 10 рейсов.", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline group by airlines.airline having count ( * ) > 10", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline group by airlines.airline having count ( flights.flightno ) >= 10", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Найдите все авиакомпании, у которых есть не менее 10 рейсов. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "У каких авиакомпаний есть не менее 10 рейсов?", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline group by airlines.airline having count ( * ) > 10", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline group by airlines.airline having count ( flights.flightno ) >= 10", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### У каких авиакомпаний есть не менее 10 рейсов? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Найдите все авиакомпании, у которых меньше 200 рейсов.", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline group by airlines.airline having count ( * ) < 200", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline group by airlines.airline having count ( flights.flightno ) < 200", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Найдите все авиакомпании, у которых меньше 200 рейсов. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "У каких авиакомпаний меньше 200 рейсов?", "query": "select airlines.airline from airlines join flights on airlines.uid = flights.airline group by airlines.airline having count ( * ) < 200", "predicted_sql": "select airlines.airline from airlines join flights on airlines.uid = flights.airline group by airlines.airline having count ( flights.flightno ) < 200", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### У каких авиакомпаний меньше 200 рейсов? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие номера рейсов у авиакомпании Победа?", "query": "select flights.flightno from flights join airlines on airlines.uid = flights.airline where airlines.airline = 'Победа'", "predicted_sql": "select flights.flightno from flights join airlines on flights.airline = airlines.uid where airlines.airline = 'Победа'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( Победа ) , airlines.abbreviation ( Победа ) , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие номера рейсов у авиакомпании Победа? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие номера рейсов соответствуют рейсам Победа?", "query": "select flights.flightno from flights join airlines on airlines.uid = flights.airline where airlines.airline = 'Победа'", "predicted_sql": "select flights.flightno from flights join airlines on flights.airline = airlines.uid where airlines.airline = 'Победа'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline ( Победа ) , airlines.abbreviation ( Победа ) , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие номера рейсов соответствуют рейсам Победа? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие номера рейсов вылетают из аэропорта «APG»?", "query": "select flightno from flights where sourceairport = 'APG'", "predicted_sql": "select flights.flightno from flights where flights.sourceairport = 'APG'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие номера рейсов вылетают из аэропорта «APG»? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Укажите номера рейсов вылетающих из APG.", "query": "select flightno from flights where sourceairport = 'APG'", "predicted_sql": "select flights.flightno from flights where flights.sourceairport = 'APG'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( APG ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( APG ) , flights.destairport ( APG ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Укажите номера рейсов вылетающих из APG. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие номера рейсов прибывают в аэропорт «APG»?", "query": "select flightno from flights where destairport = 'APG'", "predicted_sql": "select flights.flightno from flights join airports on flights.destairport = airports.airportcode where airports.airportcode = 'APG'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие номера рейсов прибывают в аэропорт «APG»? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Приведите номера рейсов, прилетающих в APG.", "query": "select flightno from flights where destairport = 'APG'", "predicted_sql": "select flights.flightno from flights join airports on flights.destairport = airports.airportcode where airports.airportcode = 'APG'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode ( APG ) , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport ( APG ) , flights.destairport ( APG ) | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Приведите номера рейсов, прилетающих в APG. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие номера рейсов вылетают из города «Калининград»?", "query": "select flights.flightno from flights join airports on flights.sourceairport = airports.airportcode where airports.city = 'Калининград'", "predicted_sql": "select flights.flightno from flights join airports on flights.sourceairport = airports.airportcode where airports.city = 'Калининград'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие номера рейсов вылетают из города «Калининград»? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сообщите номера рейсов, вылетающих из Калининграда.", "query": "select flights.flightno from flights join airports on flights.sourceairport = airports.airportcode where airports.city = 'Калининград'", "predicted_sql": "select flights.flightno from flights join airports on flights.sourceairport = airports.airportcode where airports.city = 'Калининград'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Калининград ) , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сообщите номера рейсов, вылетающих из Калининграда. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Какие номера рейсов прибывают в город \"Москва\"?", "query": "select flights.flightno from flights join airports on flights.destairport = airports.airportcode where airports.city = 'Москва'", "predicted_sql": "select flights.flightno from flights join airports on flights.destairport = airports.airportcode where airports.city = 'Москва'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Москва ) , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Какие номера рейсов прибывают в город \"Москва\"? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сообщите номера рейсов, прибывающих в Москву.", "query": "select flights.flightno from flights join airports on flights.destairport = airports.airportcode where airports.city = 'Москва'", "predicted_sql": "select flights.flightno from flights join airports on flights.destairport = airports.airportcode where airports.city = 'Moscow'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сообщите номера рейсов, прибывающих в Москву. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Найдите количество рейсов, которые приземляются в городе Анапа или Воронеж.", "query": "select count ( * ) from flights join airports on flights.destairport = airports.airportcode where airports.city = 'Анапа' or airports.city = 'Воронеж'", "predicted_sql": "select count ( * ) from flights join airports on flights.destairport = airports.airportcode where airports.city in ( 'Анапа'  , 'Воронеж' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Анапа , Воронеж ) , airports.airportcode , airports.airportname ( Воронеж ) , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Найдите количество рейсов, которые приземляются в городе Анапа или Воронеж. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Сколько рейсов приземляется в Анапе или Воронеже?", "query": "select count ( * ) from flights join airports on flights.destairport = airports.airportcode where airports.city = 'Анапа' or airports.city = 'Воронеж'", "predicted_sql": "select count ( * ) from flights where destairport in ( select airportcode from airports where city in ( 'Анапа'  , 'Воронеж' ) )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city ( Воронеж ) , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Сколько рейсов приземляется в Анапе или Воронеже? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "Найдите названия аэропортов, в которые нет рейсов.", "query": "select airportname from airports where airportcode not in ( select sourceairport from flights union select destairport from flights )", "predicted_sql": "select airports.airportname from airports left join flights on airports.airportcode = flights.destairport where flights.destairport is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### Найдите названия аэропортов, в которые нет рейсов. \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "flight_2", "question": "В какие аэропорты не отправляются и не прилетают рейсы?", "query": "select airportname from airports where airportcode not in ( select sourceairport from flights union select destairport from flights )", "predicted_sql": "select airports.airportname from airports left join flights on airports.airportcode = flights.sourceairport or airports.airportcode = flights.destairport where flights.flightno is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### В какие аэропорты не отправляются и не прилетают рейсы? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "employee_hire_evaluation", "question": "Сколько там сотрудников?", "query": "select count ( * ) from employee", "predicted_sql": "select count ( employee.employee_id ) from employee", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Сколько там сотрудников? \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Подсчитайте количество сотрудников", "query": "select count ( * ) from employee", "predicted_sql": "select count ( employee.employee_id ) from employee", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Подсчитайте количество сотрудников \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Отсортируйте имена сотрудников по возрасту в порядке возрастания.", "query": "select name from employee order by age asc", "predicted_sql": "select employee.name from employee order by employee.age asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Отсортируйте имена сотрудников по возрасту в порядке возрастания. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Перечислите имена сотрудников и отсортируйте их в порядке возрастания возраста.", "query": "select name from employee order by age asc", "predicted_sql": "select employee.name from employee order by employee.age asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Перечислите имена сотрудников и отсортируйте их в порядке возрастания возраста. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Какое количество сотрудников из каждого города?", "query": "select count ( * ) , city from employee group by city", "predicted_sql": "select employee.city  , count ( employee.employee_id ) as num_employees from employee group by employee.city", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Какое количество сотрудников из каждого города? \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Подсчитайте количество сотрудников в каждом городе.", "query": "select count ( * ) , city from employee group by city", "predicted_sql": "select employee.city  , count ( employee.employee_id ) as employee_count from employee group by employee.city", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Подсчитайте количество сотрудников в каждом городе. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Из каких городов приезжает более одного сотрудника в возрасте до 30 лет?", "query": "select city from employee where age < 30 group by city having count ( * ) > 1", "predicted_sql": "select employee.city from employee where employee.age < 30 group by employee.city having count ( employee.employee_id ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Из каких городов приезжает более одного сотрудника в возрасте до 30 лет? \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Найдите города, в которых работает более одного сотрудника младше 30 лет.", "query": "select city from employee where age < 30 group by city having count ( * ) > 1", "predicted_sql": "select employee.city from employee where employee.age < 30 group by employee.city having count ( * ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Найдите города, в которых работает более одного сотрудника младше 30 лет. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Найдите количество магазинов в каждом месте.", "query": "select count ( * ) , location from shop group by location", "predicted_sql": "select shop.location  , count ( shop.shop_id ) as num_shops from shop group by shop.location", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Найдите количество магазинов в каждом месте. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Сколько магазинов в каждом месте?", "query": "select count ( * ) , location from shop group by location", "predicted_sql": "select shop.location  , count ( shop.shop_id ) as num_shops from shop group by shop.location", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Сколько магазинов в каждом месте? \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Найдите имя менеджера и район магазина, в котором больше всего товаров.", "query": "select manager_name , district from shop order by number_products desc limit 1", "predicted_sql": "select shop.manager_name  , shop.district from shop where shop.number_products = ( select max ( number_products ) from shop )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Найдите имя менеджера и район магазина, в котором больше всего товаров. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Как зовут менеджера и какой район у магазина, в котором продается наибольшее количество товаров?", "query": "select manager_name , district from shop order by number_products desc limit 1", "predicted_sql": "select shop.manager_name  , shop.district from shop where shop.number_products = ( select max ( number_products ) from shop )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Как зовут менеджера и какой район у магазина, в котором продается наибольшее количество товаров? \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "найти минимальное и максимальное количество товаров во всех магазинах.", "query": "select min ( number_products ) , max ( number_products ) from shop", "predicted_sql": "select min ( shop.number_products )  , max ( shop.number_products ) from shop", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### найти минимальное и максимальное количество товаров во всех магазинах. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Какое минимальное и максимальное количество товаров во всех магазинах?", "query": "select min ( number_products ) , max ( number_products ) from shop", "predicted_sql": "select min ( shop.number_products )  , max ( shop.number_products ) from shop", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Какое минимальное и максимальное количество товаров во всех магазинах? \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Покажи название, местонахождение и район всех магазинов в порядке убывания количества товаров.", "query": "select name , location , district from shop order by number_products desc", "predicted_sql": "select shop.name  , shop.location  , shop.district from shop order by shop.number_products desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Покажи название, местонахождение и район всех магазинов в порядке убывания количества товаров. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Отсортируй все магазины по количеству товаров в порядке убывания и покажи название, местонахождение и район каждого магазина.", "query": "select name , location , district from shop order by number_products desc", "predicted_sql": "select shop.name  , shop.location  , shop.district from shop order by shop.number_products desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Отсортируй все магазины по количеству товаров в порядке убывания и покажи название, местонахождение и район каждого магазина. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Найти названия магазинов, количество товаров которых превышает среднее количество товаров.", "query": "select name from shop where number_products > ( select avg ( number_products ) from shop )", "predicted_sql": "select shop.name from shop where shop.number_products > ( select avg ( number_products ) from shop )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Найти названия магазинов, количество товаров которых превышает среднее количество товаров. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Количество товаров в каких магазинах выше среднего? Отобразить названия магазинов.", "query": "select name from shop where number_products > ( select avg ( number_products ) from shop )", "predicted_sql": "select shop.name from shop where shop.number_products > ( select avg ( shop.number_products ) from shop )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Количество товаров в каких магазинах выше среднего? Отобразить названия магазинов. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "найдите имя сотрудника, который получил наибольшее количество наград при оценке.", "query": "select employee.name from employee join evaluation on employee.employee_id = evaluation.employee_id group by evaluation.employee_id order by count ( * ) desc limit 1", "predicted_sql": "select employee.name from employee join evaluation on employee.employee_id = evaluation.employee_id group by employee.name order by count ( evaluation.year_awarded ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### найдите имя сотрудника, который получил наибольшее количество наград при оценке. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Какой сотрудник получил больше всего наград в результате оценки? Показать имя сотрудника.", "query": "select employee.name from employee join evaluation on employee.employee_id = evaluation.employee_id group by evaluation.employee_id order by count ( * ) desc limit 1", "predicted_sql": "select employee.name from employee join evaluation on employee.employee_id = evaluation.employee_id group by employee.name order by count ( evaluation.year_awarded ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Какой сотрудник получил больше всего наград в результате оценки? Показать имя сотрудника. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Найдите имя сотрудника, получившего самый высокий разовый бонус.", "query": "select employee.name from employee join evaluation on employee.employee_id = evaluation.employee_id order by evaluation.bonus desc limit 1", "predicted_sql": "select employee.name from employee join evaluation on employee.employee_id = evaluation.employee_id where evaluation.bonus = ( select max ( bonus ) from evaluation )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Найдите имя сотрудника, получившего самый высокий разовый бонус. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Какой сотрудник получил самый большой бонус? Имя сотрудника.", "query": "select employee.name from employee join evaluation on employee.employee_id = evaluation.employee_id order by evaluation.bonus desc limit 1", "predicted_sql": "select employee.name from employee join evaluation on employee.employee_id = evaluation.employee_id where evaluation.bonus = ( select max ( bonus ) from evaluation )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Какой сотрудник получил самый большой бонус? Имя сотрудника. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Имена сотрудников, которые никогда не получали награды в результате оценки персонала.", "query": "select name from employee where employee_id not in ( select employee_id from evaluation )", "predicted_sql": "select employee.name from employee where employee.employee_id not in ( select evaluation.employee_id from evaluation )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Имена сотрудников, которые никогда не получали награды в результате оценки персонала. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Как зовут сотрудников, которые никогда не получали оценок?", "query": "select name from employee where employee_id not in ( select employee_id from evaluation )", "predicted_sql": "select employee.name from employee where employee.employee_id not in ( select evaluation.employee_id from evaluation )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Как зовут сотрудников, которые никогда не получали оценок? \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Как называется магазин, в котором работает больше всего сотрудников?", "query": "select shop.name from hiring join shop on hiring.shop_id = shop.shop_id group by hiring.shop_id order by count ( * ) desc limit 1", "predicted_sql": "select shop.name from shop join hiring on shop.shop_id = hiring.shop_id group by shop.name order by count ( hiring.employee_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Как называется магазин, в котором работает больше всего сотрудников? \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "В каком магазине больше всего сотрудников? Название магазина.", "query": "select shop.name from hiring join shop on hiring.shop_id = shop.shop_id group by hiring.shop_id order by count ( * ) desc limit 1", "predicted_sql": "select shop.name from shop join hiring on shop.shop_id = hiring.shop_id group by shop.name order by count ( hiring.employee_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### В каком магазине больше всего сотрудников? Название магазина. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Найти названия магазинов, в которых нет сотрудников.", "query": "select name from shop where shop_id not in ( select shop_id from hiring )", "predicted_sql": "select shop.name from shop left join hiring on shop.shop_id = hiring.shop_id where hiring.employee_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time ( Нет ) | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Найти названия магазинов, в которых нет сотрудников. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Какие магазины работают без сотрудников? Найди названия магазинов", "query": "select name from shop where shop_id not in ( select shop_id from hiring )", "predicted_sql": "select shop.name from shop left join hiring on shop.shop_id = hiring.shop_id where hiring.employee_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Какие магазины работают без сотрудников? Найди названия магазинов \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Количество сотрудников, нанятых в каждом магазине; также указать название магазина.", "query": "select count ( * ) , shop.name from hiring join shop on hiring.shop_id = shop.shop_id group by shop.name", "predicted_sql": "select shop.name  , count ( hiring.employee_id ) as num_employees from shop join hiring on shop.shop_id = hiring.shop_id group by shop.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Количество сотрудников, нанятых в каждом магазине; также указать название магазина. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Для каждого магазина показать количество работающих в нем сотрудников и название магазина.", "query": "select count ( * ) , shop.name from hiring join shop on hiring.shop_id = shop.shop_id group by shop.name", "predicted_sql": "select shop.name  , count ( hiring.employee_id ) as num_employees from shop join hiring on shop.shop_id = hiring.shop_id group by shop.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Для каждого магазина показать количество работающих в нем сотрудников и название магазина. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Какой общий бонус предоставляется во всех оценках?", "query": "select sum ( bonus ) from evaluation", "predicted_sql": "select sum ( bonus ) from evaluation", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Какой общий бонус предоставляется во всех оценках? \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Найдите общую сумму бонуса, полученного во всех оценках.", "query": "select sum ( bonus ) from evaluation", "predicted_sql": "select sum ( bonus ) from evaluation", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Найдите общую сумму бонуса, полученного во всех оценках. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Показывать всю информацию о найме.", "query": "select * from hiring", "predicted_sql": "select * from hiring", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Показывать всю информацию о найме. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Какая есть вся информация о найме?", "query": "select * from hiring", "predicted_sql": "select hiring.shop_id  , hiring.employee_id  , hiring.start_from  , hiring.is_full_time from hiring", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Какая есть вся информация о найме? \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "В каком районе есть магазины с менее чем 3000 товаров и магазины с более чем 10000 товаров?", "query": "select district from shop where number_products < 3000 intersect select district from shop where number_products > 10000", "predicted_sql": "select shop.district from shop where shop.number_products < 3000 or shop.number_products > 10000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### В каком районе есть магазины с менее чем 3000 товаров и магазины с более чем 10000 товаров? \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Найдите районы, в которых есть магазины, продающие менее 3000 товаров, и магазины, продающие более 10000 товаров.", "query": "select district from shop where number_products < 3000 intersect select district from shop where number_products > 10000", "predicted_sql": "select distinct shop.district from shop where shop.number_products < 3000 and shop.number_products > 10000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Найдите районы, в которых есть магазины, продающие менее 3000 товаров, и магазины, продающие более 10000 товаров. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Сколько есть всего разных магазинов?", "query": "select count ( distinct location ) from shop", "predicted_sql": "select count ( distinct shop.shop_id ) from shop", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Сколько есть всего разных магазинов? \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "employee_hire_evaluation", "question": "Подсчитайте количество различных магазинов.", "query": "select count ( distinct location ) from shop", "predicted_sql": "select count ( distinct shop.shop_id ) from shop", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Подсчитайте количество различных магазинов. \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Сколько у нас документов?", "query": "select count ( * ) from documents", "predicted_sql": "select count ( * ) from documents", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Сколько у нас документов? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Подсчитайте количество документов.", "query": "select count ( * ) from documents", "predicted_sql": "select count ( * ) from documents", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Подсчитайте количество документов. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Перечислите id документов, названия документов и описания документов для всех документов.", "query": "select document_id , document_name , document_description from documents", "predicted_sql": "select documents.document_id  , documents.document_name  , documents.document_description from documents", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Перечислите id документов, названия документов и описания документов для всех документов. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какие id, названия и описания у всех документов?", "query": "select document_id , document_name , document_description from documents", "predicted_sql": "select documents.document_id  , documents.document_name  , documents.document_description from documents", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какие id, названия и описания у всех документов? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какое название документа и id шаблона для документа с описанием, содержащим букву 'д\"?", "query": "select document_name , template_id from documents where document_description like '%д%'", "predicted_sql": "select documents.document_name  , documents.template_id from documents where documents.document_description like '%д%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какое название документа и id шаблона для документа с описанием, содержащим букву 'д\"? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Отобразить названия и id шаблонов для документов, которые содержат букву \"д\" в своем описании.", "query": "select document_name , template_id from documents where document_description like '%д%'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Отобразить названия и id шаблонов для документов, которые содержат букву \"д\" в своем описании. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каков id документа, id шаблона и описание документа с именем \"Куприн CV\"?", "query": "select document_id , template_id , document_description from documents where document_name = 'Куприн CV'", "predicted_sql": "select documents.document_id  , documents.template_id  , documents.document_description from documents where documents.document_name = 'Куприн CV'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code ( CV ) , ref_template_types.template_type_description ( CV ) | templates : templates.template_id , templates.version_number , templates.template_type_code ( CV ) , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name ( Куприн CV ) , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каков id документа, id шаблона и описание документа с именем \"Куприн CV\"? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показывать id документа, id шаблона и описание для документа с названием Куприн CV.", "query": "select document_id , template_id , document_description from documents where document_name = 'Куприн CV'", "predicted_sql": "select documents.document_id  , documents.template_id  , documents.document_description from documents where documents.document_name = 'Куприн CV'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code ( CV ) , ref_template_types.template_type_description ( CV ) | templates : templates.template_id , templates.version_number , templates.template_type_code ( CV ) , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name ( Куприн CV ) , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показывать id документа, id шаблона и описание для документа с названием Куприн CV. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Сколько различных шаблонов используется во всех документах?", "query": "select count ( distinct template_id ) from documents", "predicted_sql": "select count ( distinct templates.template_id ) from templates join documents on documents.template_id = templates.template_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Сколько различных шаблонов используется во всех документах? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Подсчитать количество различных шаблонов, используемых для документов.", "query": "select count ( distinct template_id ) from documents", "predicted_sql": "select count ( distinct templates.template_id ) as count_of_templates from templates join documents on documents.template_id = templates.template_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Подсчитать количество различных шаблонов, используемых для документов. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Сколько документов используют шаблон с кодом типа \"PPT\"?", "query": "select count ( * ) from documents join templates on documents.template_id = templates.template_id where templates.template_type_code = 'PPT'", "predicted_sql": "select count ( * ) from documents where template_id in ( select template_id from templates where template_type_code = 'PPT' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code ( PPT ) , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code ( PPT ) , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Сколько документов используют шаблон с кодом типа \"PPT\"? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Подсчитайте количество документов, использующих тип шаблона PPT.", "query": "select count ( * ) from documents join templates on documents.template_id = templates.template_id where templates.template_type_code = 'PPT'", "predicted_sql": "select count ( * ) from documents join templates on documents.template_id = templates.template_id join ref_template_types on templates.template_type_code = ref_template_types.template_type_code where ref_template_types.template_type_description = 'PPT'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code ( PPT ) , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code ( PPT ) , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Подсчитайте количество документов, использующих тип шаблона PPT. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать все id шаблонов и количество документов, использующих каждый шаблон.", "query": "select template_id , count ( * ) from documents group by template_id", "predicted_sql": "select templates.template_id  , count ( documents.document_id ) as num_documents from templates left join documents on templates.template_id = documents.template_id group by templates.template_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать все id шаблонов и количество документов, использующих каждый шаблон. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какие id различных шаблонов используются для документов и сколько раз каждый из них использовался?", "query": "select template_id , count ( * ) from documents group by template_id", "predicted_sql": "select templates.template_id  , count ( * ) as usage_count from documents join templates on documents.template_id = templates.template_id group by templates.template_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какие id различных шаблонов используются для документов и сколько раз каждый из них использовался? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какой id и код типа для шаблона используется в большинстве документов?", "query": "select documents.template_id , templates.template_type_code from documents join templates on documents.template_id = templates.template_id group by documents.template_id order by count ( * ) desc limit 1", "predicted_sql": "select templates.template_id  , templates.template_type_code from templates join documents on documents.template_id = templates.template_id group by templates.template_id  , templates.template_type_code order by count ( documents.document_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какой id и код типа для шаблона используется в большинстве документов? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать id и код типа шаблона, который используется для наибольшего количества документов.", "query": "select documents.template_id , templates.template_type_code from documents join templates on documents.template_id = templates.template_id group by documents.template_id order by count ( * ) desc limit 1", "predicted_sql": "select templates.template_type_code  , count ( documents.document_id ) as document_count from templates join documents on documents.template_id = templates.template_id group by templates.template_type_code order by document_count desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать id и код типа шаблона, который используется для наибольшего количества документов. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать id для всех шаблонов, которые используются более чем в одном документе.", "query": "select template_id from documents group by template_id having count ( * ) > 1", "predicted_sql": "select templates.template_id from templates join documents on documents.template_id = templates.template_id group by templates.template_id having count ( distinct documents.document_id ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать id для всех шаблонов, которые используются более чем в одном документе. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы id любых шаблонов, используемых более чем в одном документе?", "query": "select template_id from documents group by template_id having count ( * ) > 1", "predicted_sql": "select templates.template_id from templates join documents on templates.template_id = documents.template_id group by templates.template_id having count ( distinct documents.document_id ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы id любых шаблонов, используемых более чем в одном документе? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать id для всех шаблонов, которые не используются ни в одном документе.", "query": "select template_id from templates except select template_id from documents", "predicted_sql": "select templates.template_id from templates left join documents on templates.template_id = documents.template_id where documents.template_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать id для всех шаблонов, которые не используются ни в одном документе. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какие id у шаблонов, которые не используются ни в каких документах?", "query": "select template_id from templates except select template_id from documents", "predicted_sql": "select templates.template_id from templates left join documents on templates.template_id = documents.template_id where documents.template_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какие id у шаблонов, которые не используются ни в каких документах? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Сколько у нас шаблонов?", "query": "select count ( * ) from templates", "predicted_sql": "select count ( * ) from templates", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Сколько у нас шаблонов? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Подсчитайте количество шаблонов.", "query": "select count ( * ) from templates", "predicted_sql": "select count ( template_id ) from templates", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Подсчитайте количество шаблонов. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Отображение id шаблонов, номеров версий и кодов типов шаблонов для всех шаблонов.", "query": "select template_id , version_number , template_type_code from templates", "predicted_sql": "select templates.template_id  , templates.version_number  , templates.template_type_code from templates", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Отображение id шаблонов, номеров версий и кодов типов шаблонов для всех шаблонов. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы id, номера версий и коды типов для каждого шаблона?", "query": "select template_id , version_number , template_type_code from templates", "predicted_sql": "select templates.template_id  , templates.version_number  , templates.template_type_code from templates", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы id, номера версий и коды типов для каждого шаблона? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать все коды типов отдельных шаблонов для всех шаблонов.", "query": "select distinct template_type_code from templates", "predicted_sql": "select templates.template_type_code from templates", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать все коды типов отдельных шаблонов для всех шаблонов. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какие существуют коды типов шаблонов?", "query": "select distinct template_type_code from templates", "predicted_sql": "select ref_template_types.template_type_code from ref_template_types", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какие существуют коды типов шаблонов? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы id шаблонов с кодом типа шаблона PP или PPT?", "query": "select template_id from templates where template_type_code = 'PP' or template_type_code = 'PPT'", "predicted_sql": "select templates.template_id from templates where templates.template_type_code = 'PP' or templates.template_type_code = 'PPT'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code ( PP , PPT ) , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code ( PP , PPT ) , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы id шаблонов с кодом типа шаблона PP или PPT? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "id шаблонов с кодом PP или PPT.", "query": "select template_id from templates where template_type_code = 'PP' or template_type_code = 'PPT'", "predicted_sql": "select templates.template_id from templates where templates.template_type_code = 'PP' or templates.template_type_code = 'PPT'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code ( PP , PPT ) , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code ( PP , PPT ) , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### id шаблонов с кодом PP или PPT. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Сколько шаблонов имеют код типа CV?", "query": "select count ( * ) from templates where template_type_code = 'CV'", "predicted_sql": "select count ( * ) from templates where template_type_code = 'CV'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code ( CV ) , ref_template_types.template_type_description ( CV ) | templates : templates.template_id , templates.version_number , templates.template_type_code ( CV ) , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Сколько шаблонов имеют код типа CV? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Количество шаблонов типа CV.", "query": "select count ( * ) from templates where template_type_code = 'CV'", "predicted_sql": "select count ( * ) from templates where template_type_code = 'CV'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code ( CV ) , ref_template_types.template_type_description ( CV ) | templates : templates.template_id , templates.version_number , templates.template_type_code ( CV ) , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Количество шаблонов типа CV. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какой номер версии и код типа шаблона для шаблона с номером версии старше 5?", "query": "select version_number , template_type_code from templates where version_number > 5", "predicted_sql": "select templates.version_number  , templates.template_type_code from templates where templates.version_number > 5", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какой номер версии и код типа шаблона для шаблона с номером версии старше 5? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показывать номера версий и коды типов шаблонов для шаблонов с номером версии больше 5.", "query": "select version_number , template_type_code from templates where version_number > 5", "predicted_sql": "select templates.version_number  , templates.template_type_code from templates where templates.version_number > 5", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показывать номера версий и коды типов шаблонов для шаблонов с номером версии больше 5. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показывать все коды типов шаблонов и количество шаблонов для каждого типа.", "query": "select template_type_code , count ( * ) from templates group by template_type_code", "predicted_sql": "select ref_template_types.template_type_code  , count ( templates.template_id ) as num_templates from ref_template_types left join templates on ref_template_types.template_type_code = templates.template_type_code group by ref_template_types.template_type_code", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показывать все коды типов шаблонов и количество шаблонов для каждого типа. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы разные коды типов шаблонов и сколько шаблонов соответствует каждому из них?", "query": "select template_type_code , count ( * ) from templates group by template_type_code", "predicted_sql": "select ref_template_types.template_type_code  , count ( templates.template_id ) as num_templates from ref_template_types join templates on templates.template_type_code = ref_template_types.template_type_code group by ref_template_types.template_type_code", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы разные коды типов шаблонов и сколько шаблонов соответствует каждому из них? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Код какого типа шаблона имеет наибольшее количество шаблонов?", "query": "select template_type_code from templates group by template_type_code order by count ( * ) desc limit 1", "predicted_sql": "select templates.template_type_code from templates group by templates.template_type_code order by count ( templates.template_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Код какого типа шаблона имеет наибольшее количество шаблонов? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Код типа шаблона, которому принадлежит большинство шаблонов.", "query": "select template_type_code from templates group by template_type_code order by count ( * ) desc limit 1", "predicted_sql": "select templates.template_type_code from templates group by templates.template_type_code order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Код типа шаблона, которому принадлежит большинство шаблонов. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать все коды типов шаблонов с менее чем тремя шаблонами.", "query": "select template_type_code from templates group by template_type_code having count ( * ) < 3", "predicted_sql": "select ref_template_types.template_type_code from ref_template_types left join templates on ref_template_types.template_type_code = templates.template_type_code group by ref_template_types.template_type_code having count ( templates.template_id ) < 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать все коды типов шаблонов с менее чем тремя шаблонами. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какие коды типов шаблонов имеют менее 3 шаблонов?", "query": "select template_type_code from templates group by template_type_code having count ( * ) < 3", "predicted_sql": "select ref_template_types.template_type_code from ref_template_types where ref_template_types.template_type_code in ( select templates.template_type_code from templates group by templates.template_type_code having count ( * ) < 3 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какие коды типов шаблонов имеют менее 3 шаблонов? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какой наименьший номер версии и ее код типа шаблона?", "query": "select min ( version_number ) , template_type_code from templates", "predicted_sql": "select min ( templates.version_number ) as min_version_number  , templates.template_type_code as template_type_code from templates group by templates.template_type_code order by min_version_number asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какой наименьший номер версии и ее код типа шаблона? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать наименьший номер версии вместе с соответствующим кодом типа шаблона.", "query": "select min ( version_number ) , template_type_code from templates", "predicted_sql": "select templates.version_number  , templates.template_type_code from templates order by templates.version_number asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать наименьший номер версии вместе с соответствующим кодом типа шаблона. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какой код типа шаблона используется документом с названием «Список клиентов»?", "query": "select templates.template_type_code from templates join documents on templates.template_id = documents.template_id where documents.document_name = 'Список клиентов'", "predicted_sql": "select templates.template_type_code from documents join templates on documents.template_id = templates.template_id where documents.document_name = 'Список клиентов'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какой код типа шаблона используется документом с названием «Список клиентов»? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать код типа шаблона у шаблона, который используется документом с названием Список клиентов.", "query": "select templates.template_type_code from templates join documents on templates.template_id = documents.template_id where documents.document_name = 'Список клиентов'", "predicted_sql": "select ref_template_types.template_type_code from ref_template_types join templates on templates.template_type_code = ref_template_types.template_type_code join documents on documents.template_id = templates.template_id where documents.document_name = 'Список клиентов'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name ( Список клиентов ) , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать код типа шаблона у шаблона, который используется документом с названием Список клиентов. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать все названия документов с использованием шаблонов с кодом типа шаблона BK.", "query": "select documents.document_name from templates join documents on templates.template_id = documents.template_id where templates.template_type_code = 'BK'", "predicted_sql": "select documents.document_name from documents join templates on documents.template_id = templates.template_id join ref_template_types on templates.template_type_code = ref_template_types.template_type_code where ref_template_types.template_type_code = 'BK'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code ( BK ) , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code ( BK ) , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать все названия документов с использованием шаблонов с кодом типа шаблона BK. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Как называются документы, в которых используются шаблоны с кодом BK?", "query": "select documents.document_name from templates join documents on templates.template_id = documents.template_id where templates.template_type_code = 'BK'", "predicted_sql": "select documents.document_name from documents join templates on documents.template_id = templates.template_id where templates.template_type_code = 'BK'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code ( BK ) , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code ( BK ) , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Как называются документы, в которых используются шаблоны с кодом BK? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать все коды типов шаблонов и количество документов, использующих каждый тип.", "query": "select templates.template_type_code , count ( * ) from templates join documents on templates.template_id = documents.template_id group by templates.template_type_code", "predicted_sql": "select ref_template_types.template_type_code  , count ( documents.document_id ) as document_count from ref_template_types join templates on templates.template_type_code = ref_template_types.template_type_code join documents on documents.template_id = templates.template_id group by ref_template_types.template_type_code", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать все коды типов шаблонов и количество документов, использующих каждый тип. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы разные коды типов шаблонов и в скольких документах используется каждый тип?", "query": "select templates.template_type_code , count ( * ) from templates join documents on templates.template_id = documents.template_id group by templates.template_type_code", "predicted_sql": "select ref_template_types.template_type_code  , count ( distinct documents.document_id ) as num_documents from ref_template_types join templates on templates.template_type_code = ref_template_types.template_type_code join documents on documents.template_id = templates.template_id group by ref_template_types.template_type_code", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы разные коды типов шаблонов и в скольких документах используется каждый тип? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Код какого типа шаблона используется в большинстве документов?", "query": "select templates.template_type_code from templates join documents on templates.template_id = documents.template_id group by templates.template_type_code order by count ( * ) desc limit 1", "predicted_sql": "select templates.template_type_code from templates join documents on documents.template_id = templates.template_id group by templates.template_type_code order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Код какого типа шаблона используется в большинстве документов? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать код типа шаблона, который чаще всего используется в документах.", "query": "select templates.template_type_code from templates join documents on templates.template_id = documents.template_id group by templates.template_type_code order by count ( * ) desc limit 1", "predicted_sql": "select templates.template_type_code from templates join documents on documents.template_id = templates.template_id group by templates.template_type_code order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать код типа шаблона, который чаще всего используется в документах. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать все коды типов шаблонов, которые не используются ни в одном документе.", "query": "select template_type_code from templates except select template_type_code from templates join documents on templates.template_id = documents.template_id", "predicted_sql": "select ref_template_types.template_type_code from ref_template_types left join templates on ref_template_types.template_type_code = templates.template_type_code left join documents on templates.template_id = documents.template_id where documents.document_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать все коды типов шаблонов, которые не используются ни в одном документе. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какие коды типов шаблонов не используются ни для одного документа?", "query": "select template_type_code from templates except select template_type_code from templates join documents on templates.template_id = documents.template_id", "predicted_sql": "select ref_template_types.template_type_code from ref_template_types where ref_template_types.template_type_code not in ( select templates.template_type_code from templates inner join documents on documents.template_id = templates.template_id )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какие коды типов шаблонов не используются ни для одного документа? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать все коды и описания типов шаблонов.", "query": "select template_type_code , template_type_description from ref_template_types", "predicted_sql": "select ref_template_types.template_type_code  , ref_template_types.template_type_description from ref_template_types", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать все коды и описания типов шаблонов. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы коды типов и описания для всех типов шаблонов?", "query": "select template_type_code , template_type_description from ref_template_types", "predicted_sql": "select ref_template_types.template_type_code  , ref_template_types.template_type_description from ref_template_types", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы коды типов и описания для всех типов шаблонов? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Описания типа шаблона для кода типа шаблона \"AD\".", "query": "select template_type_description from ref_template_types where template_type_code = 'AD'", "predicted_sql": "select ref_template_types.template_type_description from ref_template_types where ref_template_types.template_type_code = 'AD'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code ( AD ) , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code ( AD ) , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Описания типа шаблона для кода типа шаблона \"AD\". \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать описание типа шаблона для типа шаблона с кодом AD.", "query": "select template_type_description from ref_template_types where template_type_code = 'AD'", "predicted_sql": "select ref_template_types.template_type_description from ref_template_types where ref_template_types.template_type_code = 'AD'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code ( AD ) , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code ( AD ) , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать описание типа шаблона для типа шаблона с кодом AD. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какой код типа шаблона для описания типа шаблона \"Каталог\".", "query": "select template_type_code from ref_template_types where template_type_description = 'Каталог'", "predicted_sql": "select ref_template_types.template_type_code from ref_template_types where ref_template_types.template_type_description = 'Каталог'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description ( Каталог ) | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какой код типа шаблона для описания типа шаблона \"Каталог\". \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать код типа шаблона типа с описанием «Каталог».", "query": "select template_type_code from ref_template_types where template_type_description = 'Каталог'", "predicted_sql": "select ref_template_types.template_type_code  , ref_template_types.template_type_description from ref_template_types where ref_template_types.template_type_description = 'Каталог'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать код типа шаблона типа с описанием «Каталог». \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы отдельные описания типов шаблонов для шаблонов, когда-либо использовавшихся в каком-либо документе?", "query": "select distinct ref_template_types.template_type_description from ref_template_types join templates on ref_template_types.template_type_code = templates.template_type_code join documents on templates.template_id = documents.template_id", "predicted_sql": "select ref_template_types.template_type_description from ref_template_types join templates on templates.template_type_code = ref_template_types.template_type_code join documents on documents.template_id = templates.template_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы отдельные описания типов шаблонов для шаблонов, когда-либо использовавшихся в каком-либо документе? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Покажи различные описания для шаблонов, которые использовались в документе.", "query": "select distinct ref_template_types.template_type_description from ref_template_types join templates on ref_template_types.template_type_code = templates.template_type_code join documents on templates.template_id = documents.template_id", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Покажи различные описания для шаблонов, которые использовались в документе. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы id шаблона с описанием типа шаблона \"Буклет\".", "query": "select templates.template_id from ref_template_types join templates on ref_template_types.template_type_code = templates.template_type_code where ref_template_types.template_type_description = 'Буклет'", "predicted_sql": "select templates.template_id from ref_template_types join templates on templates.template_type_code = ref_template_types.template_type_code where ref_template_types.template_type_description = 'Буклет'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description ( Буклет ) | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы id шаблона с описанием типа шаблона \"Буклет\". \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать id, соответствующие шаблонам с описанием «Буклет».", "query": "select templates.template_id from ref_template_types join templates on ref_template_types.template_type_code = templates.template_type_code where ref_template_types.template_type_description = 'Буклет'", "predicted_sql": "select templates.template_id from templates join ref_template_types on templates.template_type_code = ref_template_types.template_type_code where ref_template_types.template_type_description = 'Буклет'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать id, соответствующие шаблонам с описанием «Буклет». \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Сколько всего абзацев?", "query": "select count ( * ) from paragraphs", "predicted_sql": "select count ( paragraph_id ) from paragraphs", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Сколько всего абзацев? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Подсчитайте количество абзацев.", "query": "select count ( * ) from paragraphs", "predicted_sql": "select count ( paragraph_id ) from paragraphs", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Подсчитайте количество абзацев. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Сколько абзацев в документе с названием «Зимнее представление»?", "query": "select count ( * ) from paragraphs join documents on paragraphs.document_id = documents.document_id where documents.document_name = 'Зимнее представление'", "predicted_sql": "select count ( paragraphs.paragraph_id ) from documents join paragraphs on documents.document_id = paragraphs.document_id where documents.document_name = 'Зимнее представление'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Сколько абзацев в документе с названием «Зимнее представление»? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Подсчитайте количество абзацев в документе под названием «Зимнее представление».", "query": "select count ( * ) from paragraphs join documents on paragraphs.document_id = documents.document_id where documents.document_name = 'Зимнее представление'", "predicted_sql": "select count ( paragraphs.paragraph_id ) from documents join paragraphs on documents.document_id = paragraphs.document_id where documents.document_name = 'Зимнее представление'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Подсчитайте количество абзацев в документе под названием «Зимнее представление». \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать детали абзаца для абзаца с текстом \"Россия\".", "query": "select other_details from paragraphs where paragraph_text like 'Россия'", "predicted_sql": "select paragraphs.paragraph_id  , paragraphs.document_id  , paragraphs.paragraph_text  , paragraphs.other_details from paragraphs where paragraphs.paragraph_text = 'Россия'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text ( Россия ) , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать детали абзаца для абзаца с текстом \"Россия\". \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы подробности абзаца, включающего текст «Россия»?", "query": "select other_details from paragraphs where paragraph_text like 'Россия'", "predicted_sql": "select paragraphs.paragraph_id  , paragraphs.document_id  , paragraphs.paragraph_text  , paragraphs.other_details from paragraphs where paragraphs.paragraph_text like '%Россия%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы подробности абзаца, включающего текст «Россия»? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать все id абзацев и тексты для документа с названием «Достопримечательности Лондона».", "query": "select paragraphs.paragraph_id , paragraphs.paragraph_text from paragraphs join documents on paragraphs.document_id = documents.document_id where documents.document_name = 'Достопримечательности Лондона'", "predicted_sql": "select paragraphs.paragraph_id  , paragraphs.paragraph_text from documents join paragraphs on paragraphs.document_id = documents.document_id where documents.document_name = 'Достопримечательности Лондона'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать все id абзацев и тексты для документа с названием «Достопримечательности Лондона». \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы id и текст абзацев в документе «Достопримечательности Лондона»?", "query": "select paragraphs.paragraph_id , paragraphs.paragraph_text from paragraphs join documents on paragraphs.document_id = documents.document_id where documents.document_name = 'Достопримечательности Лондона'", "predicted_sql": "select paragraphs.paragraph_id  , paragraphs.paragraph_text from documents join paragraphs on documents.document_id = paragraphs.document_id where documents.document_name = 'Достопримечательности Лондона'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы id и текст абзацев в документе «Достопримечательности Лондона»? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать все тексты параграфов документа «Советы пользователей».", "query": "select paragraphs.paragraph_text from paragraphs join documents on paragraphs.document_id = documents.document_id where documents.document_name = 'Советы пользователей'", "predicted_sql": "select paragraph_text from paragraphs join documents on paragraphs.document_id = documents.document_id where documents.document_name = 'Советы пользователей'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать все тексты параграфов документа «Советы пользователей». \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы тексты параграфов документа с названием «Советы пользователей»?", "query": "select paragraphs.paragraph_text from paragraphs join documents on paragraphs.document_id = documents.document_id where documents.document_name = 'Советы пользователей'", "predicted_sql": "select paragraphs.paragraph_text from paragraphs join documents on paragraphs.document_id = documents.document_id where documents.document_name = 'Советы пользователей'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы тексты параграфов документа с названием «Советы пользователей»? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать все id документов и количество абзацев в каждом документе. Сортировать по id документа.", "query": "select document_id , count ( * ) from paragraphs group by document_id order by document_id asc", "predicted_sql": "select documents.document_id  , count ( paragraphs.paragraph_id ) as paragraph_count from documents left join paragraphs on documents.document_id = paragraphs.document_id group by documents.document_id order by documents.document_id asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать все id документов и количество абзацев в каждом документе. Сортировать по id документа. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать различные id документов вместе с количеством абзацев, соответствующих каждому, в порядке id.", "query": "select document_id , count ( * ) from paragraphs group by document_id order by document_id asc", "predicted_sql": "select documents.document_id  , count ( paragraphs.paragraph_id ) as paragraph_count from documents join paragraphs on documents.document_id = paragraphs.document_id group by documents.document_id order by documents.document_id asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать различные id документов вместе с количеством абзацев, соответствующих каждому, в порядке id. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать все id документов, имена и количество абзацев в каждом документе.", "query": "select paragraphs.document_id , documents.document_name , count ( * ) from paragraphs join documents on paragraphs.document_id = documents.document_id group by paragraphs.document_id", "predicted_sql": "select documents.document_id  , documents.document_name  , count ( paragraphs.paragraph_id ) as paragraph_count from documents join paragraphs on documents.document_id = paragraphs.document_id group by documents.document_id  , documents.document_name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать все id документов, имена и количество абзацев в каждом документе. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы id и названия каждого документа, а также количество абзацев в каждом?", "query": "select paragraphs.document_id , documents.document_name , count ( * ) from paragraphs join documents on paragraphs.document_id = documents.document_id group by paragraphs.document_id", "predicted_sql": "select documents.document_id  , documents.document_name  , count ( paragraphs.paragraph_id ) as paragraph_count from documents join paragraphs on documents.document_id = paragraphs.document_id group by documents.document_id  , documents.document_name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы id и названия каждого документа, а также количество абзацев в каждом? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Перечислите все id документов как минимум с двумя абзацами.", "query": "select document_id from paragraphs group by document_id having count ( * ) >= 2", "predicted_sql": "select documents.document_id from documents join paragraphs on paragraphs.document_id = documents.document_id group by documents.document_id having count ( paragraphs.paragraph_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Перечислите все id документов как минимум с двумя абзацами. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каковы id документов, содержащих 2 или более абзаца?", "query": "select document_id from paragraphs group by document_id having count ( * ) >= 2", "predicted_sql": "select documents.document_id from documents join paragraphs on documents.document_id = paragraphs.document_id group by documents.document_id having count ( paragraphs.paragraph_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каковы id документов, содержащих 2 или более абзаца? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Каков id и название документа с наибольшим количеством абзацев?", "query": "select paragraphs.document_id , documents.document_name from paragraphs join documents on paragraphs.document_id = documents.document_id group by paragraphs.document_id order by count ( * ) desc limit 1", "predicted_sql": "select documents.document_id  , documents.document_name from documents join paragraphs on documents.document_id = paragraphs.document_id group by documents.document_id  , documents.document_name order by count ( paragraphs.paragraph_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Каков id и название документа с наибольшим количеством абзацев? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать id и имя документа с наибольшим количеством абзацев.", "query": "select paragraphs.document_id , documents.document_name from paragraphs join documents on paragraphs.document_id = documents.document_id group by paragraphs.document_id order by count ( * ) desc limit 1", "predicted_sql": "select documents.document_id  , documents.document_name from documents join paragraphs on documents.document_id = paragraphs.document_id group by documents.document_id  , documents.document_name order by count ( paragraphs.paragraph_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать id и имя документа с наибольшим количеством абзацев. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какой id у документа с наименьшим количеством абзацев?", "query": "select document_id from paragraphs group by document_id order by count ( * ) asc limit 1", "predicted_sql": "select documents.document_id from documents join paragraphs on documents.document_id = paragraphs.document_id group by documents.document_id order by count ( paragraphs.paragraph_id ) asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какой id у документа с наименьшим количеством абзацев? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать id документа с наименьшим количеством абзацев.", "query": "select document_id from paragraphs group by document_id order by count ( * ) asc limit 1", "predicted_sql": "select documents.document_id from documents join paragraphs on documents.document_id = paragraphs.document_id group by documents.document_id order by count ( paragraphs.paragraph_id ) asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать id документа с наименьшим количеством абзацев. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какой id документа состоит из 1-2 абзацев?", "query": "select document_id from paragraphs group by document_id having count ( * ) between 1 and 2", "predicted_sql": "select documents.document_id from documents join paragraphs on documents.document_id = paragraphs.document_id group by documents.document_id having count ( paragraphs.paragraph_id ) = 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какой id документа состоит из 1-2 абзацев? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Укажите id документов, содержащих от одного до двух абзацев.", "query": "select document_id from paragraphs group by document_id having count ( * ) between 1 and 2", "predicted_sql": "select documents.document_id from documents join paragraphs on documents.document_id = paragraphs.document_id group by documents.document_id having count ( paragraphs.paragraph_id ) >= 1 and count ( paragraphs.paragraph_id ) <= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Укажите id документов, содержащих от одного до двух абзацев. \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Показать id документа с текстом абзаца «Испания» и «Франция».", "query": "select document_id from paragraphs where paragraph_text = 'Испания' intersect select document_id from paragraphs where paragraph_text = 'Франция'", "predicted_sql": "select documents.document_id from documents join paragraphs on paragraphs.document_id = documents.document_id where paragraphs.paragraph_text in ( 'Испания'  , 'Франция' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Показать id документа с текстом абзаца «Испания» и «Франция». \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какие id документов содержат текст абзаца «Испания» и «Франция»?", "query": "select document_id from paragraphs where paragraph_text = 'Испания' intersect select document_id from paragraphs where paragraph_text = 'Франция'", "predicted_sql": "select documents.document_id from paragraphs join documents on paragraphs.document_id = documents.document_id where paragraphs.paragraph_text = 'Испания' or paragraphs.paragraph_text = 'Франция'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какие id документов содержат текст абзаца «Испания» и «Франция»? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "course_teach", "question": "Сколько всего учителей?", "query": "select count ( * ) from teacher", "predicted_sql": "select count ( * ) from teacher", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Сколько всего учителей? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Каково общее количество учителей?", "query": "select count ( * ) from teacher", "predicted_sql": "select count ( teacher.teacher_id ) from teacher", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Каково общее количество учителей? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Перечислите имена учителей в порядке возрастания их возраста.", "query": "select name from teacher order by age asc", "predicted_sql": "select teacher.name from teacher order by teacher.age asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Перечислите имена учителей в порядке возрастания их возраста. \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Как зовут учителей по возрасту?", "query": "select name from teacher order by age asc", "predicted_sql": "select teacher.name from teacher where teacher.age = 'age'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Как зовут учителей по возрасту? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Какого возраста и из какого города учителя?", "query": "select age , hometown from teacher", "predicted_sql": "select teacher.age  , teacher.hometown from teacher", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Какого возраста и из какого города учителя? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Какого возраста и из какого города каждый учитель?", "query": "select age , hometown from teacher", "predicted_sql": "select teacher.age  , teacher.hometown from teacher", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Какого возраста и из какого города каждый учитель? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Перечислите имена учителей, чей родной город не является 'Абакан'.", "query": "select name from teacher where hometown != 'Абакан'", "predicted_sql": "select teacher.name from teacher where teacher.hometown <> 'Абакан'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown ( Абакан ) | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Перечислите имена учителей, чей родной город не является 'Абакан'. \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Как зовут учителей, чей родной город не Абакан", "query": "select name from teacher where hometown != 'Абакан'", "predicted_sql": "select teacher.name from teacher where teacher.hometown <> 'Абакан'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown ( Абакан ) | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Как зовут учителей, чей родной город не Абакан \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Укажите имена учителей в возрасте 32 или 33 лет?", "query": "select name from teacher where age = 32 or age = 33", "predicted_sql": "select teacher.name from teacher where teacher.age = 32 or teacher.age = 33", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Укажите имена учителей в возрасте 32 или 33 лет? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Как зовут учителей в возрасте 32 или 33 лет?", "query": "select name from teacher where age = 32 or age = 33", "predicted_sql": "select teacher.name from teacher where teacher.age = 32 or teacher.age = 33", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Как зовут учителей в возрасте 32 или 33 лет? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Из какого города самый молодой учитель?", "query": "select hometown from teacher order by age asc limit 1", "predicted_sql": "select teacher.hometown from teacher where teacher.age = ( select min ( age ) from teacher )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Из какого города самый молодой учитель? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Откуда самый молодой учитель?", "query": "select hometown from teacher order by age asc limit 1", "predicted_sql": "select teacher.name from teacher order by teacher.age asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Откуда самый молодой учитель? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Покажите разные родные города учителей и количество учителей из каждого города.", "query": "select hometown , count ( * ) from teacher group by hometown", "predicted_sql": "select teacher.hometown  , count ( teacher.teacher_id ) as count from teacher group by teacher.hometown", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Покажите разные родные города учителей и количество учителей из каждого города. \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Сколько учителей из каждого города?", "query": "select hometown , count ( * ) from teacher group by hometown", "predicted_sql": "select teacher.hometown  , count ( teacher.teacher_id ) as count from teacher group by teacher.hometown", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Сколько учителей из каждого города? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Перечислите наиболее часто встречающийся родной город учителей.", "query": "select hometown from teacher group by hometown order by count ( * ) desc limit 1", "predicted_sql": "select teacher.hometown from teacher group by teacher.hometown order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Перечислите наиболее часто встречающийся родной город учителей. \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Какие города наиболее распространены среди учителей?", "query": "select hometown from teacher group by hometown order by count ( * ) desc limit 1", "predicted_sql": "select teacher.hometown from teacher group by teacher.hometown order by count ( * ) desc limit 5", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Какие города наиболее распространены среди учителей? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Города, откуда родом как минимум два учителя.", "query": "select hometown from teacher group by hometown having count ( * ) >= 2", "predicted_sql": "select teacher.hometown from teacher group by teacher.hometown having count ( teacher.teacher_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Города, откуда родом как минимум два учителя. \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Из каких городов приехали как минимум два учителя?", "query": "select hometown from teacher group by hometown having count ( * ) >= 2", "predicted_sql": "select teacher.hometown from teacher group by teacher.hometown having count ( teacher.teacher_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Из каких городов приехали как минимум два учителя? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Покажите имена учителей и курсы, которые они должны преподавать.", "query": "select teacher.name , course.course from course_arrange join course on course_arrange.course_id = course.course_id join teacher on course_arrange.teacher_id = teacher.teacher_id", "predicted_sql": "select teacher.name  , course.course from teacher join course_arrange on teacher.teacher_id = course_arrange.teacher_id join course on course_arrange.course_id = course.course_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Покажите имена учителей и курсы, которые они должны преподавать. \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Как зовут каждого учителя и какой курс они преподают?", "query": "select teacher.name , course.course from course_arrange join course on course_arrange.course_id = course.course_id join teacher on course_arrange.teacher_id = teacher.teacher_id", "predicted_sql": "select teacher.name  , course.course from teacher join course_arrange on teacher.teacher_id = course_arrange.teacher_id join course on course_arrange.course_id = course.course_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Как зовут каждого учителя и какой курс они преподают? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Показать имена учителей и курсы, которые они преподают, в возрастающем алфавитном порядке имени учителя.", "query": "select teacher.name , course.course from course_arrange join course on course_arrange.course_id = course.course_id join teacher on course_arrange.teacher_id = teacher.teacher_id order by teacher.name asc", "predicted_sql": "select teacher.name  , course.course from teacher join course_arrange on teacher.teacher_id = course_arrange.teacher_id join course on course_arrange.course_id = course.course_id order by teacher.name asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Показать имена учителей и курсы, которые они преподают, в возрастающем алфавитном порядке имени учителя. \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Как зовут учителей и какие курсы они преподают в возрастающем алфавитном порядке по имени учителя?", "query": "select teacher.name , course.course from course_arrange join course on course_arrange.course_id = course.course_id join teacher on course_arrange.teacher_id = teacher.teacher_id order by teacher.name asc", "predicted_sql": "select teacher.name  , course.course from teacher join course_arrange on teacher.teacher_id = course_arrange.teacher_id join course on course_arrange.course_id = course.course_id order by teacher.name asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Как зовут учителей и какие курсы они преподают в возрастающем алфавитном порядке по имени учителя? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Имя учителя курса экономики.", "query": "select teacher.name from course_arrange join course on course_arrange.course_id = course.course_id join teacher on course_arrange.teacher_id = teacher.teacher_id where course.course = 'Экономика'", "predicted_sql": "select teacher.name from teacher join course_arrange on teacher.teacher_id = course_arrange.teacher_id join course on course_arrange.course_id = course.course_id where course.course = 'Экономика'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course ( Экономика ) | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Имя учителя курса экономики. \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Как зовут людей, которые преподают экономические курсы?", "query": "select teacher.name from course_arrange join course on course_arrange.course_id = course.course_id join teacher on course_arrange.teacher_id = teacher.teacher_id where course.course = 'Экономика'", "predicted_sql": "select teacher.name from teacher join course_arrange on teacher.teacher_id = course_arrange.teacher_id join course on course_arrange.course_id = course.course_id where course.course = 'экономический'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Как зовут людей, которые преподают экономические курсы? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Покажите имена учителей и количество курсов, которые они преподают.", "query": "select teacher.name , count ( * ) from course_arrange join teacher on course_arrange.teacher_id = teacher.teacher_id group by teacher.name", "predicted_sql": "select teacher.name  , count ( course_arrange.course_id ) as num_courses from teacher join course_arrange on teacher.teacher_id = course_arrange.teacher_id group by teacher.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Покажите имена учителей и количество курсов, которые они преподают. \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Как зовут учителей и сколько курсов они преподают?", "query": "select teacher.name , count ( * ) from course_arrange join teacher on course_arrange.teacher_id = teacher.teacher_id group by teacher.name", "predicted_sql": "select teacher.name  , count ( course_arrange.course_id ) as number_of_courses from teacher join course_arrange on teacher.teacher_id = course_arrange.teacher_id group by teacher.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Как зовут учителей и сколько курсов они преподают? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Покажите имена учителей, которые преподают как минимум два курса.", "query": "select teacher.name from course_arrange join teacher on course_arrange.teacher_id = teacher.teacher_id group by teacher.name having count ( * ) >= 2", "predicted_sql": "select teacher.name from teacher join course_arrange on teacher.teacher_id = course_arrange.teacher_id group by teacher.name having count ( distinct course_arrange.course_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Покажите имена учителей, которые преподают как минимум два курса. \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Как зовут учителей, которые ведут как минимум два курса?", "query": "select teacher.name from course_arrange join teacher on course_arrange.teacher_id = teacher.teacher_id group by teacher.name having count ( * ) >= 2", "predicted_sql": "select teacher.name from teacher join course_arrange on teacher.teacher_id = course_arrange.teacher_id group by teacher.teacher_id having count ( course_arrange.course_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Как зовут учителей, которые ведут как минимум два курса? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Перечисли имена учителей, не назначенных для преподавания курсов.", "query": "select name from teacher where teacher_id not in ( select teacher_id from course_arrange )", "predicted_sql": "select teacher.name from teacher left join course_arrange on teacher.teacher_id = course_arrange.teacher_id where course_arrange.teacher_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Перечисли имена учителей, не назначенных для преподавания курсов. \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Как зовут учителей, которые не ведут курсы?", "query": "select name from teacher where teacher_id not in ( select teacher_id from course_arrange )", "predicted_sql": "select teacher.name from teacher where teacher.teacher_id not in ( select teacher_id from course_arrange )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Как зовут учителей, которые не ведут курсы? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "museum_visit", "question": "Сколько здесь посетителей младше 30 лет?", "query": "select count ( * ) from visitor where age < 30", "predicted_sql": "select count ( * ) from visitor where age < 30", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Сколько здесь посетителей младше 30 лет? \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Показать имена посетителей, чей уровень членства выше 4, и отсортировать результаты по уровню от высокого к низкому.", "query": "select name from visitor where level_of_membership > 4 order by level_of_membership desc", "predicted_sql": "select visitor.name from visitor where visitor.level_of_membership > 4 order by visitor.level_of_membership desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Показать имена посетителей, чей уровень членства выше 4, и отсортировать результаты по уровню от высокого к низкому. \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Каков средний возраст посетителей, уровень членства которых не выше 4?", "query": "select avg ( age ) from visitor where level_of_membership <= 4", "predicted_sql": "select avg ( visitor.age ) from visitor where visitor.level_of_membership <= 4", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Каков средний возраст посетителей, уровень членства которых не выше 4? \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Найди имена и уровень членства посетителей, чей уровень членства выше 4, и отсортируй их по возрасту от старых к молодым.", "query": "select name , level_of_membership from visitor where level_of_membership > 4 order by age desc", "predicted_sql": "select visitor.name  , visitor.level_of_membership from visitor where visitor.level_of_membership > 4 order by visitor.age asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Найди имена и уровень членства посетителей, чей уровень членства выше 4, и отсортируй их по возрасту от старых к молодым. \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "id и название музея, в котором больше всего сотрудников", "query": "select museum_id , name from museum order by num_of_staff desc limit 1", "predicted_sql": "select museum_id  , name from museum order by num_of_staff desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### id и название музея, в котором больше всего сотрудников \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Найдите среднее количество сотрудников, работающих в музеях, которые были открыты до 2009 года.", "query": "select avg ( num_of_staff ) from museum where open_year < 2009", "predicted_sql": "select avg ( museum.num_of_staff ) from museum where museum.open_year < 2009", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Найдите среднее количество сотрудников, работающих в музеях, которые были открыты до 2009 года. \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Каковы год открытия и штатная численность музея Пушкинский?", "query": "select num_of_staff , open_year from museum where name = 'Пушкинский'", "predicted_sql": "select museum.open_year  , museum.num_of_staff from museum where museum.name = 'Пушкинский'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name ( Пушкинский ) , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Каковы год открытия и штатная численность музея Пушкинский? \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Названия музеев, в которых работает больше сотрудников, чем минимальная численность персонала всех музеев, открытых после 2010 года.", "query": "select name from museum where num_of_staff > ( select min ( num_of_staff ) from museum where open_year > 2010 )", "predicted_sql": "select museum.name from museum where museum.num_of_staff > ( select min ( museum.num_of_staff ) from museum where museum.open_year > 2010 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Названия музеев, в которых работает больше сотрудников, чем минимальная численность персонала всех музеев, открытых после 2010 года. \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Показать id, имя и возраст посетителей, которые посещали некоторые музеи более одного раза.", "query": "select visitor.id , visitor.name , visitor.age from visitor join visit on visitor.id = visit.visitor_id group by visitor.id having count ( * ) > 1", "predicted_sql": "select visitor.id  , visitor.name  , visitor.age from visitor join visit on visit.visitor_id = visitor.id group by visitor.id  , visitor.name  , visitor.age having count ( visit.museum_id ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Показать id, имя и возраст посетителей, которые посещали некоторые музеи более одного раза. \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Какой id, имя и уровень членства у посетителей, которые потратили наибольшую сумму денег на все билеты в музей?", "query": "select visit.visitor_id , visitor.name , visitor.level_of_membership from visitor join visit on visitor.id = visit.visitor_id group by visit.visitor_id order by sum ( visit.total_spent ) desc limit 1", "predicted_sql": "select visitor.id  , visitor.name  , visitor.level_of_membership from visitor join visit on visit.visitor_id = visitor.id group by visitor.id  , visitor.name  , visitor.level_of_membership order by sum ( visit.total_spent ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Какой id, имя и уровень членства у посетителей, которые потратили наибольшую сумму денег на все билеты в музей? \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Какой id и название у музея который посещают чаще всего?", "query": "select visit.museum_id , museum.name from museum join visit on museum.museum_id = visit.museum_id group by visit.museum_id order by count ( * ) desc limit 1", "predicted_sql": "select museum.museum_id  , museum.name from museum join visit on museum.museum_id = visit.museum_id group by museum.museum_id  , museum.name order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Какой id и название у музея который посещают чаще всего? \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Как называется музей, в котором еще не было ни одного посетителя?", "query": "select name from museum where museum_id not in ( select museum_id from visit )", "predicted_sql": "select museum.name from museum where museum.museum_id not in ( select visit.museum_id from visit )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Как называется музей, в котором еще не было ни одного посетителя? \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Имя и возраст посетителя, который купил больше всего билетов за раз.", "query": "select visitor.name , visitor.age from visitor join visit on visitor.id = visit.visitor_id order by visit.num_of_ticket desc limit 1", "predicted_sql": "select visitor.name  , visitor.age from visit join visitor on visit.visitor_id = visitor.id group by visit.visitor_id order by visit.num_of_ticket desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Имя и возраст посетителя, который купил больше всего билетов за раз. \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Каково среднее и максимальное количество билетов, купленных за все посещения?", "query": "select avg ( num_of_ticket ) , max ( num_of_ticket ) from visit", "predicted_sql": "select avg ( num_of_ticket ) as average_tickets  , max ( num_of_ticket ) as max_tickets from visit", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Каково среднее и максимальное количество билетов, купленных за все посещения? \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Каковы общие расходы на билеты у посетителей, чей уровень членства равен 1?", "query": "select sum ( visit.total_spent ) from visitor join visit on visitor.id = visit.visitor_id where visitor.level_of_membership = 1", "predicted_sql": "select sum ( visit.total_spent ) from visit join visitor on visit.visitor_id = visitor.id where visitor.level_of_membership = 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Каковы общие расходы на билеты у посетителей, чей уровень членства равен 1? \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Как зовут посетителя, который посетил и музей, открытый до 2009 года, и музей, открытый после 2011 года?", "query": "select visitor.name from visitor join visit on visitor.id = visit.visitor_id join museum on museum.museum_id = visit.museum_id where museum.open_year < 2009 intersect select visitor.name from visitor join visit on visitor.id = visit.visitor_id join museum on museum.museum_id = visit.museum_id where museum.open_year > 2011", "predicted_sql": "select visitor.name from visitor join visit on visit.visitor_id = visitor.id join museum on visit.museum_id = museum.museum_id where museum.open_year < 2009 and museum.open_year > 2011", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Как зовут посетителя, который посетил и музей, открытый до 2009 года, и музей, открытый после 2011 года? \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Найдите количество посетителей, которые не посещали ни один музей, открытый после 2010 года.", "query": "select count ( * ) from visitor where id not in ( select visit.visitor_id from museum join visit on museum.museum_id = visit.museum_id where museum.open_year > 2010 )", "predicted_sql": "select count ( visitor.id ) from visitor where visitor.id not in ( select visit.visitor_id from visit inner join museum on visit.museum_id = museum.museum_id where museum.open_year > 2010 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Найдите количество посетителей, которые не посещали ни один музей, открытый после 2010 года. \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "museum_visit", "question": "Сколько музеев было открыто после 2013 года или до 2008 года?", "query": "select count ( * ) from museum where open_year > 2013 or open_year < 2008", "predicted_sql": "select count ( * ) from museum where museum.open_year > 2013 or museum.open_year < 2008", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### Сколько музеев было открыто после 2013 года или до 2008 года? \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "wta_1", "question": "Найдите общее количество игроков.", "query": "select count ( * ) from players", "predicted_sql": "select count ( distinct player_id ) from players", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите общее количество игроков. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Сколько всего там игроков?", "query": "select count ( * ) from players", "predicted_sql": "select count ( distinct player_id ) from players", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Сколько всего там игроков? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найдите общее количество матчей.", "query": "select count ( * ) from matches", "predicted_sql": "select count ( * ) from matches", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите общее количество матчей. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Подсчитайте количество матчей.", "query": "select count ( * ) from matches", "predicted_sql": "select count ( * ) from matches", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Подсчитайте количество матчей. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Укажите имя и дату рождения всех игроков из страны с кодом АФК.", "query": "select first_name , birth_date from players where country_code = 'АФК'", "predicted_sql": "select players.first_name  , players.birth_date from players where players.country_code = 'АФК'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code ( АФК ) | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc ( АФК ) , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Укажите имя и дату рождения всех игроков из страны с кодом АФК. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Какие имена и даты рождения у игроков из АФК?", "query": "select first_name , birth_date from players where country_code = 'АФК'", "predicted_sql": "select players.first_name  , players.birth_date from players where players.country_code = 'АФК'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code ( АФК ) | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc ( АФК ) , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Какие имена и даты рождения у игроков из АФК? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найдите средний возраст проигравших и победителей всех матчей.", "query": "select avg ( loser_age ) , avg ( winner_age ) from matches", "predicted_sql": "select avg ( winner_age ) as average_winner_age  , avg ( loser_age ) as average_loser_age from matches", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите средний возраст проигравших и победителей всех матчей. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Каков средний возраст проигравших и победителей в матчах?", "query": "select avg ( loser_age ) , avg ( winner_age ) from matches", "predicted_sql": "select avg ( winner_age ) as average_winner_age  , avg ( loser_age ) as average_loser_age from matches", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Каков средний возраст проигравших и победителей в матчах? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найдите средний рейтинг победителей во всех матчах.", "query": "select avg ( winner_rank ) from matches", "predicted_sql": "select avg ( rankings.ranking_points ) as average_rating from matches join rankings on matches.winner_id = rankings.player_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите средний рейтинг победителей во всех матчах. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Каков средний рейтинг победителей во всех матчах?", "query": "select avg ( winner_rank ) from matches", "predicted_sql": "select avg ( rankings.ranking_points ) as average_ranking from matches join rankings on matches.winner_id = rankings.player_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Каков средний рейтинг победителей во всех матчах? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Самый высокий рейтинг проигравших во всех матчах.", "query": "select min ( loser_rank ) from matches", "predicted_sql": "select max ( rankings.ranking_points ) from rankings join matches on rankings.player_id = matches.loser_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Самый высокий рейтинг проигравших во всех матчах. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Какой самый лучший рейтинг проигравших во всех матчах?", "query": "select min ( loser_rank ) from matches", "predicted_sql": "select max ( rankings.ranking_points ) from rankings join matches on rankings.player_id = matches.loser_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Какой самый лучший рейтинг проигравших во всех матчах? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Количество различных кодов стран всех игроков.", "query": "select count ( distinct country_code ) from players", "predicted_sql": "select count ( distinct players.country_code ) from players", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Количество различных кодов стран всех игроков. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Из скольких разных стран все игроки?", "query": "select count ( distinct country_code ) from players", "predicted_sql": "select count ( distinct players.country_code ) from players", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Из скольких разных стран все игроки? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найдите количество отличных имен проигравших.", "query": "select count ( distinct loser_name ) from matches", "predicted_sql": "select count ( distinct loser_name ) from matches", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите количество отличных имен проигравших. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Сколько существует разных имен проигравших?", "query": "select count ( distinct loser_name ) from matches", "predicted_sql": "select count ( distinct loser_name ) from matches", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Сколько существует разных имен проигравших? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найди название турнира, в котором больше 10 матчей.", "query": "select tourney_name from matches group by tourney_name having count ( * ) > 10", "predicted_sql": "select tourney_name from matches group by tourney_name having count ( * ) > 10", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найди название турнира, в котором больше 10 матчей. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Как называются турниры, в которых больше 10 матчей?", "query": "select tourney_name from matches group by tourney_name having count ( * ) > 10", "predicted_sql": "select tourney_name from matches group by tourney_name having count ( match_num ) > 10", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Как называются турниры, в которых больше 10 матчей? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Перечислите имена всех победителей, игравших в 2013 и 2016 годах.", "query": "select winner_name from matches where year = 2013 intersect select winner_name from matches where year = 2016", "predicted_sql": "select winner_name from matches where year = 2013 or year = 2016", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Перечислите имена всех победителей, игравших в 2013 и 2016 годах. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Как зовут игроков, победивших в 2013 и 2016 годах?", "query": "select winner_name from matches where year = 2013 intersect select winner_name from matches where year = 2016", "predicted_sql": "select players.first_name  , players.last_name from players join matches on matches.winner_id = players.player_id where matches.year in ( 2013  , 2016 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Как зовут игроков, победивших в 2013 и 2016 годах? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Укажите количество всех матчей, сыгранных в 2013 или 2016 годах.", "query": "select count ( * ) from matches where year = 2013 or year = 2016", "predicted_sql": "select count ( * ) from matches where year = 2013 or year = 2016", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Укажите количество всех матчей, сыгранных в 2013 или 2016 годах. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Сколько матчей было сыграно в 2013 или 2016?", "query": "select count ( * ) from matches where year = 2013 or year = 2016", "predicted_sql": "select count ( * ) from matches where year = 2013 or year = 2016", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Сколько матчей было сыграно в 2013 или 2016? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Каковы коды страны и имена игроков, победивших в турнирах чемпионата по фрисби и Россия Первая?", "query": "select players.country_code , players.first_name from players join matches on players.player_id = matches.winner_id where matches.tourney_name = 'Чемпионат по фрисби' intersect select players.country_code , players.first_name from players join matches on players.player_id = matches.winner_id where matches.tourney_name = 'Россия Первая'", "predicted_sql": "select players.country_code  , players.first_name  , players.last_name from players join matches on matches.winner_id = players.player_id join rankings on rankings.player_id = players.player_id where matches.tourney_name = 'чемпионат по фрисби' and matches.tourney_level = 'Россия Первая'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name ( Россия Первая ) , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Каковы коды страны и имена игроков, победивших в турнирах чемпионата по фрисби и Россия Первая? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Какие имена и коды стран у игроков, выигравших в чемпионате по фрисби и в Россия Первая?", "query": "select players.country_code , players.first_name from players join matches on players.player_id = matches.winner_id where matches.tourney_name = 'Чемпионат по фрисби' intersect select players.country_code , players.first_name from players join matches on players.player_id = matches.winner_id where matches.tourney_name = 'Россия Первая'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name ( Россия Первая ) , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Какие имена и коды стран у игроков, выигравших в чемпионате по фрисби и в Россия Первая? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Показать имя и код страны самого старого игрока.", "query": "select first_name , country_code from players order by birth_date asc limit 1", "predicted_sql": "select players.first_name  , players.country_code from players order by players.birth_date asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Показать имя и код страны самого старого игрока. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Какое имя и код страны у самого старого игрока?", "query": "select first_name , country_code from players order by birth_date asc limit 1", "predicted_sql": "select players.first_name  , players.country_code from players where players.birth_date = ( select min ( players.birth_date ) from players )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Какое имя и код страны у самого старого игрока? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Отображать имена и фамилии всех игроков в порядке даты рождения.", "query": "select first_name , last_name from players order by birth_date asc", "predicted_sql": "select players.first_name  , players.last_name from players order by players.birth_date asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Отображать имена и фамилии всех игроков в порядке даты рождения. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Каковы полные имена всех игроков, отсортированные по дате рождения?", "query": "select first_name , last_name from players order by birth_date asc", "predicted_sql": "select players.first_name || ' ' || players.last_name as full_name from players order by players.birth_date asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Каковы полные имена всех игроков, отсортированные по дате рождения? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Отображать имя и фамилию всех игроков-левшей в порядке даты рождения.", "query": "select first_name , last_name from players where hand = 'Л' order by birth_date asc", "predicted_sql": "select players.first_name  , players.last_name from players where players.hand = 'L' order by players.birth_date asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Отображать имя и фамилию всех игроков-левшей в порядке даты рождения. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Каковы полные имена всех игроков-левшей в порядке даты рождения?", "query": "select first_name , last_name from players where hand = 'Л' order by birth_date asc", "predicted_sql": "select players.first_name || ' ' || players.last_name as full_name from players where players.hand = 'L' order by players.birth_date asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Каковы полные имена всех игроков-левшей в порядке даты рождения? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найдите имя и код страны игрока, совершившего наибольшее количество туров.", "query": "select players.country_code , players.first_name from players join rankings on players.player_id = rankings.player_id order by rankings.tours desc limit 1", "predicted_sql": "select players.first_name  , players.country_code from players join ( select player_id  , count ( * ) as num_tours from rankings group by player_id ) as tour_counts on players.player_id = tour_counts.player_id order by tour_counts.num_tours desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите имя и код страны игрока, совершившего наибольшее количество туров. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Какое имя и код страны у игрока с наибольшим количеством туров?", "query": "select players.country_code , players.first_name from players join rankings on players.player_id = rankings.player_id order by rankings.tours desc limit 1", "predicted_sql": "select players.first_name  , players.country_code from players join rankings on players.player_id = rankings.player_id group by players.player_id order by count ( rankings.tours ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Какое имя и код страны у игрока с наибольшим количеством туров? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найдите год, в котором больше всего матчей.", "query": "select year from matches group by year order by count ( * ) desc limit 1", "predicted_sql": "select year from matches group by year order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите год, в котором больше всего матчей. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "В каком году было больше всего матчей?", "query": "select year from matches group by year order by count ( * ) desc limit 1", "predicted_sql": "select year from matches group by year order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### В каком году было больше всего матчей? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Отображать имя и количество очков победителя, который выигрывал больше всего раз.", "query": "select winner_name , winner_rank_points from matches group by winner_name order by count ( * ) desc limit 1", "predicted_sql": "select players.first_name  , players.last_name  , max ( rankings.ranking_points ) as total_points from players join matches on matches.winner_id = players.player_id join rankings on rankings.player_id = players.player_id group by players.first_name  , players.last_name order by total_points desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Отображать имя и количество очков победителя, который выигрывал больше всего раз. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Как зовут победителя, выигравшего больше всего матчей, и сколько ранговых очков у этого игрока?", "query": "select winner_name , winner_rank_points from matches group by winner_name order by count ( * ) desc limit 1", "predicted_sql": "select players.first_name  , players.last_name  , max ( rankings.ranking_points ) as ranking_points from players join matches on matches.winner_id = players.player_id join rankings on rankings.player_id = players.player_id group by players.player_id order by count ( matches.match_num ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Как зовут победителя, выигравшего больше всего матчей, и сколько ранговых очков у этого игрока? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Имя победителя, набравшего наибольшее количество очков в рейтинге и участвовавшего в чемпионате по фрисби.", "query": "select winner_name from matches where tourney_name = 'Чемпионат по фрисби' order by winner_rank_points desc limit 1", "predicted_sql": "select players.first_name from players join rankings on players.player_id = rankings.player_id join matches on matches.winner_id = players.player_id where matches.tourney_name = 'чемпионат по фрисби' order by rankings.ranking_points desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Имя победителя, набравшего наибольшее количество очков в рейтинге и участвовавшего в чемпионате по фрисби. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Как зовут победителя, набравшего наибольшее количество рейтинговых очков, принявшего участие в чемпионате по фрисби?", "query": "select winner_name from matches where tourney_name = 'Чемпионат по фрисби' order by winner_rank_points desc limit 1", "predicted_sql": "select players.first_name  , players.last_name from players join matches on matches.winner_id = players.player_id join rankings on rankings.player_id = players.player_id where matches.tourney_name = 'чемпионат по фрисби' order by rankings.ranking_points desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Как зовут победителя, набравшего наибольшее количество рейтинговых очков, принявшего участие в чемпионате по фрисби? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "найти имена проигравшего и победителя, сыгравшего в матче с наибольшим количеством минут.", "query": "select winner_name , loser_name from matches order by minutes desc limit 1", "predicted_sql": "select matches.winner_name  , matches.loser_name from matches where matches.minutes = ( select max ( minutes ) from matches )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### найти имена проигравшего и победителя, сыгравшего в матче с наибольшим количеством минут. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Как зовут победителя и проигравшего, сыгравшего в самом продолжительном матче?", "query": "select winner_name , loser_name from matches order by minutes desc limit 1", "predicted_sql": "select matches.winner_name  , matches.loser_name from matches where matches.minutes = ( select max ( minutes ) from matches )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Как зовут победителя и проигравшего, сыгравшего в самом продолжительном матче? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найдите средний рейтинг каждого игрока и его имя.", "query": "select avg ( ranking ) , players.first_name from players join rankings on players.player_id = rankings.player_id group by players.first_name", "predicted_sql": "select players.first_name  , players.last_name  , avg ( rankings.ranking_points ) as average_rating from players join rankings on players.player_id = rankings.player_id group by players.player_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите средний рейтинг каждого игрока и его имя. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Каковы имена всех игроков и их средний рейтинг?", "query": "select avg ( ranking ) , players.first_name from players join rankings on players.player_id = rankings.player_id group by players.first_name", "predicted_sql": "select players.first_name  , players.last_name  , avg ( rankings.ranking ) as average_rating from players join rankings on players.player_id = rankings.player_id group by players.first_name  , players.last_name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Каковы имена всех игроков и их средний рейтинг? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Общее количество рейтинговых очков для каждого игрока и его имя.", "query": "select sum ( ranking_points ) , players.first_name from players join rankings on players.player_id = rankings.player_id group by players.first_name", "predicted_sql": "select players.first_name  , players.last_name  , sum ( rankings.ranking_points ) as total_ranking_points from players join rankings on players.player_id = rankings.player_id group by players.player_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Общее количество рейтинговых очков для каждого игрока и его имя. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Как зовут всех игроков и их общее количество очков в рейтинге?", "query": "select sum ( ranking_points ) , players.first_name from players join rankings on players.player_id = rankings.player_id group by players.first_name", "predicted_sql": "select players.first_name  , players.last_name  , sum ( rankings.ranking_points ) as total_points from players join rankings on players.player_id = rankings.player_id group by players.player_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Как зовут всех игроков и их общее количество очков в рейтинге? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Отображать количество игроков для каждой страны.", "query": "select count ( * ) , country_code from players group by country_code", "predicted_sql": "select players.country_code  , count ( players.player_id ) as player_count from players group by players.country_code", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Отображать количество игроков для каждой страны. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Сколько игроков от каждой страны?", "query": "select count ( * ) , country_code from players group by country_code", "predicted_sql": "select players.country_code  , count ( players.player_id ) as total_players from players group by players.country_code", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Сколько игроков от каждой страны? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Код страны, в которой больше всего игроков.", "query": "select country_code from players group by country_code order by count ( * ) desc limit 1", "predicted_sql": "select country_code from players group by country_code order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Код страны, в которой больше всего игроков. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Каков код страны с наибольшим количеством игроков?", "query": "select country_code from players group by country_code order by count ( * ) desc limit 1", "predicted_sql": "select players.country_code from players group by players.country_code order by count ( players.player_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Каков код страны с наибольшим количеством игроков? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найти коды стран, в которых больше 50 игроков.", "query": "select country_code from players group by country_code having count ( * ) > 50", "predicted_sql": "select players.country_code from players group by players.country_code having count ( players.player_id ) > 50", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найти коды стран, в которых больше 50 игроков. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Какие коды стран с более чем 50 игроками?", "query": "select country_code from players group by country_code having count ( * ) > 50", "predicted_sql": "select players.country_code from players group by players.country_code having count ( players.player_id ) > 50", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Какие коды стран с более чем 50 игроками? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найди общее количество туров для каждой рейтинговой даты.", "query": "select sum ( tours ) , ranking_date from rankings group by ranking_date", "predicted_sql": "select ranking_date  , count ( distinct tours ) as total_tours from rankings group by ranking_date", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найди общее количество туров для каждой рейтинговой даты. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Сколько всего туров было проведено на каждую дату рейтинга?", "query": "select sum ( tours ) , ranking_date from rankings group by ranking_date", "predicted_sql": "select ranking_date  , count ( distinct tours ) as total_tours from rankings group by ranking_date", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Сколько всего туров было проведено на каждую дату рейтинга? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найдите количество матчей за каждый год.", "query": "select count ( * ) , year from matches group by year", "predicted_sql": "select year  , count ( * ) as match_count from matches group by year", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите количество матчей за каждый год. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Сколько матчей игралось в год?", "query": "select count ( * ) , year from matches group by year", "predicted_sql": "select count ( * ) as total_matches from matches group by year", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Сколько матчей игралось в год? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найдите имена и ранги трех самых молодых победителей во всех матчах.", "query": "select distinct winner_name , winner_rank from matches order by winner_age asc limit 3", "predicted_sql": "select players.first_name  , players.last_name  , rankings.ranking from players join matches on matches.winner_id = players.player_id join rankings on rankings.player_id = players.player_id order by players.birth_date asc limit 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите имена и ранги трех самых молодых победителей во всех матчах. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Каковы имена и ранги трех самых молодых победителей во всех матчах?", "query": "select distinct winner_name , winner_rank from matches order by winner_age asc limit 3", "predicted_sql": "select players.first_name  , players.last_name  , rankings.ranking from players join matches on matches.winner_id = players.player_id join rankings on rankings.player_id = players.player_id order by players.birth_date asc limit 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Каковы имена и ранги трех самых молодых победителей во всех матчах? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Сколько разных победителей участвовали в Россия Первая и были левшами?", "query": "select count ( distinct winner_name ) from matches where tourney_name = 'Россия Первая' and winner_hand = 'L'", "predicted_sql": "select count ( distinct winner_id ) from matches where tourney_name = 'Россия Первая' and winner_hand = 'L'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name ( Россия Первая ) , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Сколько разных победителей участвовали в Россия Первая и были левшами? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найдите количество победителей-левшей, которые участвовали в Россия Первая.", "query": "select count ( distinct winner_name ) from matches where tourney_name = 'Россия Первая' and winner_hand = 'L'", "predicted_sql": "select count ( distinct winner_id ) from matches where winner_hand = 'L' and tourney_name = 'Россия Первая'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name ( Россия Первая ) , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите количество победителей-левшей, которые участвовали в Россия Первая. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найдите имя, код страны и дату рождения победителя, набравшего наибольшее количество очков во всех матчах.", "query": "select players.first_name , players.country_code , players.birth_date from players join matches on players.player_id = matches.winner_id order by matches.winner_rank_points desc limit 1", "predicted_sql": "select players.first_name  , players.country_code  , players.birth_date from players join ( select matches.winner_id  , sum ( rankings.ranking_points ) as total_points from matches join rankings on matches.winner_id = rankings.player_id group by matches.winner_id order by total_points desc limit 1 ) as subquery on players.player_id = subquery.winner_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите имя, код страны и дату рождения победителя, набравшего наибольшее количество очков во всех матчах. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Каковы имя, код страны и дата рождения игрока, набравшего наибольшее количество очков победителя во всех матчах?", "query": "select players.first_name , players.country_code , players.birth_date from players join matches on players.player_id = matches.winner_id order by matches.winner_rank_points desc limit 1", "predicted_sql": "select players.first_name  , players.country_code  , players.birth_date from players join matches on matches.winner_id = players.player_id join rankings on rankings.player_id = players.player_id order by rankings.ranking_points desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Каковы имя, код страны и дата рождения игрока, набравшего наибольшее количество очков победителя во всех матчах? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Найдите количество игроков для каждого типа руки.", "query": "select count ( * ) , hand from players group by hand", "predicted_sql": "select players.hand  , count ( players.player_id ) as count from players group by players.hand", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Найдите количество игроков для каждого типа руки. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Сколько игроков подходит для каждого типа рук?", "query": "select count ( * ) , hand from players group by hand", "predicted_sql": "select players.hand  , count ( players.player_id ) as count from players group by players.hand", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Сколько игроков подходит для каждого типа рук? \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "battle_death", "question": "Сколько кораблей было подорвано?", "query": "select count ( * ) from ship where disposition_of_ship = 'Подорван'", "predicted_sql": "select count ( * ) from ship where disposition_of_ship = 'Подорван'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship ( Подорван ) | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Сколько кораблей было подорвано? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Указать название и тоннаж в порядке убывания названий в алфавитном порядке.", "query": "select name , tonnage from ship order by name desc", "predicted_sql": "select ship.name  , ship.tonnage from ship order by ship.name desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Указать название и тоннаж в порядке убывания названий в алфавитном порядке. \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Перечислите название, дату и результат каждого боя.", "query": "select name , date from battle", "predicted_sql": "select battle.name  , battle.date  , battle.result from battle", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Перечислите название, дату и результат каждого боя. \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Какое максимальное и минимальное количество погибших происходит каждый раз?", "query": "select max ( killed ) , min ( killed ) from death", "predicted_sql": "select max ( death.killed ) as max_killed  , min ( death.killed ) as min_killed from death", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Какое максимальное и минимальное количество погибших происходит каждый раз? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Каково среднее количество травм, причиненных каждый раз?", "query": "select avg ( injured ) from death", "predicted_sql": "select avg ( injured ) from death", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Каково среднее количество травм, причиненных каждый раз? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Какие ситуации со смертельным исходом или телесными повреждениями вызваны судном с тоннажем '100\"?", "query": "select death.killed , death.injured from death join ship on death.caused_by_ship_id = ship.id where ship.tonnage = '100'", "predicted_sql": "select death.note from death join ship on death.caused_by_ship_id = ship.id where ship.tonnage = '100'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Какие ситуации со смертельным исходом или телесными повреждениями вызваны судном с тоннажем '100\"? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Названия и результаты сражений, когда болгарский командир не Нахимов", "query": "select name , result from battle where bulgarian_commander != 'Нахимов'", "predicted_sql": "select battle.name  , battle.result from battle where battle.bulgarian_commander  != 'Нахимов'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander ( Нахимов ) , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Названия и результаты сражений, когда болгарский командир не Нахимов \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Каковы разные id и названия сражений, в которых были потеряны корабли типа «Крейсер»?", "query": "select distinct battle.id , battle.name from battle join ship on battle.id = ship.lost_in_battle where ship.ship_type = 'Крейсер'", "predicted_sql": "select battle.id  , battle.name from battle join ship on ship.lost_in_battle = battle.id where ship.ship_type = 'Крейсер'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Каковы разные id и названия сражений, в которых были потеряны корабли типа «Крейсер»? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Каковы id и названия сражений, в которых в общей сложности погибло более 10 человек?", "query": "select battle.id , battle.name from battle join ship on battle.id = ship.lost_in_battle join death on ship.id = death.caused_by_ship_id group by battle.id having sum ( death.killed ) > 10", "predicted_sql": "select battle.id  , battle.name from battle join death on death.caused_by_ship_id = battle.id group by battle.id  , battle.name having sum ( death.killed ) + sum ( death.injured ) > 10", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Каковы id и названия сражений, в которых в общей сложности погибло более 10 человек? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Какой id и название у корабля нанесшего больше всего травм?", "query": "select ship.id , ship.name from death join ship on death.caused_by_ship_id = ship.id group by ship.id order by count ( * ) desc limit 1", "predicted_sql": "select death.caused_by_ship_id  , ship.name from death join ship on death.caused_by_ship_id = ship.id group by death.caused_by_ship_id order by count ( death.id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Какой id и название у корабля нанесшего больше всего травм? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Каковы отличительные названия сражений между болгарским командиром Нахимов и латинским командиром Распутином?", "query": "select name from battle where bulgarian_commander = 'Нахимов' and latin_commander = 'Распутин'", "predicted_sql": "select battle.name from battle where battle.bulgarian_commander = 'Нахимов' and battle.latin_commander = 'Распутин'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander ( Нахимов ) , battle.latin_commander ( Распутин ) , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Каковы отличительные названия сражений между болгарским командиром Нахимов и латинским командиром Распутином? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Сколько разных результатов у сражений?", "query": "select count ( distinct result ) from battle", "predicted_sql": "select count ( distinct result ) from battle", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Сколько разных результатов у сражений? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Сколько боёв не проиграл ни один корабль водоизмещением «225»?", "query": "select count ( * ) from battle where id not in ( select lost_in_battle from ship where tonnage = '225' )", "predicted_sql": "select count ( distinct battle.id ) from battle join ship on ship.lost_in_battle = battle.id where ship.tonnage = 225 and battle.result  != 'defeat'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Сколько боёв не проиграл ни один корабль водоизмещением «225»? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Укажите название и дату битвы, в которой потеряли корабль под названием «Адмирал Макаров» и корабль под названием «Аврора».", "query": "select battle.name , battle.date from battle join ship on battle.id = ship.lost_in_battle where ship.name = 'Адмирал Макаров' intersect select battle.name , battle.date from battle join ship on battle.id = ship.lost_in_battle where ship.name = 'Аврора'", "predicted_sql": "select battle.name  , battle.date from battle join ship on ship.lost_in_battle = battle.id where ship.name = 'Адмирал Макаров' or ship.name = 'Аврора'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Укажите название и дату битвы, в которой потеряли корабль под названием «Адмирал Макаров» и корабль под названием «Аврора». \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Покажите имена, результаты и болгарских командиров сражений без потерь в Балтийском море.", "query": "select name , result , bulgarian_commander from battle except select battle.name , battle.result , battle.bulgarian_commander from battle join ship on battle.id = ship.lost_in_battle where ship.location = 'Балтийское море'", "predicted_sql": "select battle.name  , battle.result  , battle.bulgarian_commander from battle join ship on ship.lost_in_battle = battle.id where ship.location = 'Baltic Sea' and ship.disposition_of_ship = 'No losses'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Покажите имена, результаты и болгарских командиров сражений без потерь в Балтийском море. \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Какие примечания к смертельным событиям содержат подстроку «Порт»?", "query": "select note from death where note like '%Порт%'", "predicted_sql": "select death.note from death where death.note like '%Порт%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Какие примечания к смертельным событиям содержат подстроку «Порт»? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "student_transcripts_tracking", "question": "какие все полные адреса, включая строку 1 и строку 2?", "query": "select line_1 , line_2 from addresses", "predicted_sql": "select addresses.line_1  , addresses.line_2  , addresses.line_3  , addresses.city  , addresses.zip_postcode  , addresses.state_province_county  , addresses.country  , addresses.other_address_details from addresses", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### какие все полные адреса, включая строку 1 и строку 2? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какая первая и вторая строка у всех адресов?", "query": "select line_1 , line_2 from addresses", "predicted_sql": "select addresses.line_1  , addresses.line_2 from addresses limit 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какая первая и вторая строка у всех адресов? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Сколько всего курсов указано в списке?", "query": "select count ( * ) from courses", "predicted_sql": "select count ( courses.course_id ) from courses", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Сколько всего курсов указано в списке? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Сколько всего курсов?", "query": "select count ( * ) from courses", "predicted_sql": "select count ( * ) from courses", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Сколько всего курсов? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Как описывается курс экономики?", "query": "select course_description from courses where course_name = 'экономика'", "predicted_sql": "select courses.course_description from courses where courses.course_name = 'экономика'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Как описывается курс экономики? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Каковы описания всех курсов экономики?", "query": "select course_description from courses where course_name = 'экономика'", "predicted_sql": "select courses.course_description from courses where courses.course_name = 'экономика'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Каковы описания всех курсов экономики? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какой почтовый индекс у адреса в городе Порт Рояль?", "query": "select zip_postcode from addresses where city = 'Порт Рояль'", "predicted_sql": "select addresses.zip_postcode from addresses where addresses.city = 'Порт Рояль'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city ( Порт Рояль ) , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какой почтовый индекс у адреса в городе Порт Рояль? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какой почтовый индекс у Гаваны?", "query": "select zip_postcode from addresses where city = 'Гавана'", "predicted_sql": "select addresses.zip_postcode from addresses where addresses.city = 'Гавана'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какой почтовый индекс у Гаваны? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какой факультет предлагает больше всего степеней? Перечислите название и id факультета.", "query": "select departments.department_name , degree_programs.department_id from degree_programs join departments on degree_programs.department_id = departments.department_id group by degree_programs.department_id order by count ( * ) desc limit 1", "predicted_sql": "select departments.department_id  , departments.department_name from degree_programs join departments on degree_programs.department_id = departments.department_id group by departments.department_id order by count ( degree_programs.degree_program_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какой факультет предлагает больше всего степеней? Перечислите название и id факультета. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Название и id факультета с наибольшим количеством ученых степеней", "query": "select departments.department_name , degree_programs.department_id from degree_programs join departments on degree_programs.department_id = departments.department_id group by degree_programs.department_id order by count ( * ) desc limit 1", "predicted_sql": "select departments.department_id  , departments.department_name from departments join degree_programs on departments.department_id = degree_programs.department_id group by departments.department_id  , departments.department_name order by count ( degree_programs.degree_program_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Название и id факультета с наибольшим количеством ученых степеней \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Сколько факультетов предлагают какую-либо степень?", "query": "select count ( distinct department_id ) from degree_programs", "predicted_sql": "select count ( departments.department_id ) as number_of_departments  , count ( degree_programs.degree_program_id ) as number_of_degree_programs from departments join degree_programs on departments.department_id = degree_programs.department_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Сколько факультетов предлагают какую-либо степень? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Сколько разных факультетов предлагают степени?", "query": "select count ( distinct department_id ) from degree_programs", "predicted_sql": "select count ( distinct departments.department_id ) from degree_programs join departments on degree_programs.department_id = departments.department_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Сколько разных факультетов предлагают степени? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Сколько разных названий степеней предлагается?", "query": "select count ( distinct degree_summary_name ) from degree_programs", "predicted_sql": "select count ( distinct degree_summary_name ) from degree_programs", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Сколько разных названий степеней предлагается? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Сколько разных степеней предлагается?", "query": "select count ( distinct degree_summary_name ) from degree_programs", "predicted_sql": "select count ( distinct degree_program_id ) from degree_programs", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Сколько разных степеней предлагается? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Сколько степеней предлагает физический факультет?", "query": "select count ( * ) from departments join degree_programs on departments.department_id = degree_programs.department_id where departments.department_name = 'физический'", "predicted_sql": "select count ( degree_programs.degree_program_id ) from degree_programs join departments on degree_programs.department_id = departments.department_id where departments.department_name = 'физический'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name ( физический ) , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Сколько степеней предлагает физический факультет? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Сколько степеней на физическом факультете?", "query": "select count ( * ) from departments join degree_programs on departments.department_id = degree_programs.department_id where departments.department_name = 'физический'", "predicted_sql": "select count ( degree_programs.degree_program_id ) from degree_programs join departments on degree_programs.department_id = departments.department_id where departments.department_name = 'физический факультет'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Сколько степеней на физическом факультете? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Названия и описания всех разделов", "query": "select section_name , section_description from sections", "predicted_sql": "select sections.section_name  , sections.section_description from sections", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Названия и описания всех разделов \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какие названия и описания у всех разделов?", "query": "select section_name , section_description from sections", "predicted_sql": "select sections.section_name  , sections.section_description from sections", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какие названия и описания у всех разделов? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какие названия и id курсов, содержащих не более двух разделов?", "query": "select courses.course_name , courses.course_id from courses join sections on courses.course_id = sections.course_id group by courses.course_id having count ( * ) <= 2", "predicted_sql": "select courses.course_id  , courses.course_name from courses join sections on sections.course_id = courses.course_id group by courses.course_id  , courses.course_name having count ( sections.section_id ) <= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какие названия и id курсов, содержащих не более двух разделов? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какие названия и id у каждого курса, состоящего менее чем из двух разделов?", "query": "select courses.course_name , courses.course_id from courses join sections on courses.course_id = sections.course_id group by courses.course_id having count ( * ) <= 2", "predicted_sql": "select courses.course_id  , courses.course_name from courses where courses.course_id in ( select sections.course_id from sections group by sections.course_id having count ( sections.section_id ) < 2 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какие названия и id у каждого курса, состоящего менее чем из двух разделов? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Перечислите названия разделов в обратном лексикографическом порядке.", "query": "select section_name from sections order by section_name desc", "predicted_sql": "select sections.section_name from sections order by sections.section_name desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Перечислите названия разделов в обратном лексикографическом порядке. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Как называются разделы в обратном алфавитном порядке?", "query": "select section_name from sections order by section_name desc", "predicted_sql": "select sections.section_name from sections order by sections.section_name desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Как называются разделы в обратном алфавитном порядке? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "На какой семестр зарегистрировалось больше всего студентов? Показать название и id семестра.", "query": "select semesters.semester_name , semesters.semester_id from semesters join student_enrolment on semesters.semester_id = student_enrolment.semester_id group by semesters.semester_id order by count ( * ) desc limit 1", "predicted_sql": "select semesters.semester_id  , semesters.semester_name from semesters join student_enrolment on semesters.semester_id = student_enrolment.semester_id group by semesters.semester_id order by count ( student_enrolment.student_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### На какой семестр зарегистрировалось больше всего студентов? Показать название и id семестра. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какое название и id для каждого семестра имеет тот, на который зарегистрировано больше всего студентов?", "query": "select semesters.semester_name , semesters.semester_id from semesters join student_enrolment on semesters.semester_id = student_enrolment.semester_id group by semesters.semester_id order by count ( * ) desc limit 1", "predicted_sql": "select semesters.semester_id  , semesters.semester_name from semesters join student_enrolment on semesters.semester_id = student_enrolment.semester_id group by semesters.semester_id  , semesters.semester_name order by count ( student_enrolment.student_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какое название и id для каждого семестра имеет тот, на который зарегистрировано больше всего студентов? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Каково описание отдела, в названии которого есть подстрока физический?", "query": "select department_description from departments where department_name like '%физический%'", "predicted_sql": "select departments.department_description from departments where departments.department_name like '%физический%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name ( физический ) , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Каково описание отдела, в названии которого есть подстрока физический? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какое описание отдела для отдела, в чьем названии есть слово физический?", "query": "select department_description from departments where department_name like '%физический%'", "predicted_sql": "select departments.department_description from departments where departments.department_name like '%физический%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name ( физический ) , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какое описание отдела для отдела, в чьем названии есть слово физический? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Кто зачислен на 2 программы обучения за один семестр? Перечислите имя, отчество, фамилию и id.", "query": "select students.first_name , students.middle_name , students.last_name , students.student_id from students join student_enrolment on students.student_id = student_enrolment.student_id group by students.student_id having count ( * ) = 2", "predicted_sql": "select students.first_name  , students.middle_name  , students.last_name  , students.student_id from students join student_enrolment on students.student_id = student_enrolment.student_id where student_enrolment.semester_id = 2 group by students.student_id having count ( distinct student_enrolment.degree_program_id ) = 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Кто зачислен на 2 программы обучения за один семестр? Перечислите имя, отчество, фамилию и id. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Каковы имя, отчество и фамилия, а также id всех студентов, которые обучались по двум программам за один семестр?", "query": "select students.first_name , students.middle_name , students.last_name , students.student_id from students join student_enrolment on students.student_id = student_enrolment.student_id group by students.student_id having count ( * ) = 2", "predicted_sql": "select students.first_name  , students.middle_name  , students.last_name  , students.student_id from students join student_enrolment on students.student_id = student_enrolment.student_id group by students.student_id having count ( distinct student_enrolment.degree_program_id ) = 2 and count ( distinct student_enrolment.semester_id ) = 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Каковы имя, отчество и фамилия, а также id всех студентов, которые обучались по двум программам за один семестр? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Кто учится на программе бакалавриата? Укажите имя, отчество, фамилию.", "query": "select distinct students.first_name , students.middle_name , students.last_name from students join student_enrolment on students.student_id = student_enrolment.student_id join degree_programs on student_enrolment.degree_program_id = degree_programs.degree_program_id where degree_programs.degree_summary_name = 'Bachelor'", "predicted_sql": "select students.first_name  , students.middle_name  , students.last_name from students join student_enrolment on students.student_id = student_enrolment.student_id join degree_programs on student_enrolment.degree_program_id = degree_programs.degree_program_id where degree_programs.degree_summary_name = 'Бакалавриат'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Кто учится на программе бакалавриата? Укажите имя, отчество, фамилию. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Каковы имя, отчество и фамилия у всех, кто обучается по программе аспирантуры?", "query": "select distinct students.first_name , students.middle_name , students.last_name from students join student_enrolment on students.student_id = student_enrolment.student_id join degree_programs on student_enrolment.degree_program_id = degree_programs.degree_program_id where degree_programs.degree_summary_name = 'Аспирансткая'", "predicted_sql": "select students.first_name  , students.middle_name  , students.last_name from students join student_enrolment on students.student_id = student_enrolment.student_id join degree_programs on student_enrolment.degree_program_id = degree_programs.degree_program_id where degree_programs.degree_summary_name = 'аспирантура'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Каковы имя, отчество и фамилия у всех, кто обучается по программе аспирантуры? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Найдите программу, по которой обучается больше всего студентов", "query": "select degree_programs.degree_summary_name from degree_programs join student_enrolment on degree_programs.degree_program_id = student_enrolment.degree_program_id group by degree_programs.degree_summary_name order by count ( * ) desc limit 1", "predicted_sql": "select degree_programs.degree_program_id from degree_programs join student_enrolment on degree_programs.degree_program_id = student_enrolment.degree_program_id group by degree_programs.degree_program_id order by count ( student_enrolment.student_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Найдите программу, по которой обучается больше всего студентов \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Краткое описание программы, на которой обучается наибольшее количество студентов", "query": "select degree_programs.degree_summary_name from degree_programs join student_enrolment on degree_programs.degree_program_id = student_enrolment.degree_program_id group by degree_programs.degree_summary_name order by count ( * ) desc limit 1", "predicted_sql": "select degree_programs.degree_summary_name  , count ( student_enrolment.student_id ) as total_students from degree_programs join student_enrolment on degree_programs.degree_program_id = student_enrolment.degree_program_id group by degree_programs.degree_summary_name order by total_students desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Краткое описание программы, на которой обучается наибольшее количество студентов \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Найди программу, по которой обучается наибольшее количество студентов. Укажи id и краткое описание.", "query": "select degree_programs.degree_program_id , degree_programs.degree_summary_name from degree_programs join student_enrolment on degree_programs.degree_program_id = student_enrolment.degree_program_id group by degree_programs.degree_program_id order by count ( * ) desc limit 1", "predicted_sql": "select degree_programs.degree_program_id  , degree_programs.degree_summary_description from degree_programs join student_enrolment on degree_programs.degree_program_id = student_enrolment.degree_program_id group by degree_programs.degree_program_id order by count ( student_enrolment.student_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Найди программу, по которой обучается наибольшее количество студентов. Укажи id и краткое описание. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Каков id программы и краткое описание степени, на которую обучается больше всего студентов?", "query": "select degree_programs.degree_program_id , degree_programs.degree_summary_name from degree_programs join student_enrolment on degree_programs.degree_program_id = student_enrolment.degree_program_id group by degree_programs.degree_program_id order by count ( * ) desc limit 1", "predicted_sql": "select degree_programs.degree_program_id  , degree_programs.degree_summary_description from degree_programs join student_enrolment on degree_programs.degree_program_id = student_enrolment.degree_program_id group by degree_programs.degree_program_id order by count ( student_enrolment.student_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Каков id программы и краткое описание степени, на которую обучается больше всего студентов? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какой студент чаще всего записывался на любую программу? Укажите id, имя, отчество, фамилию, количество зачислений и id студента.", "query": "select students.student_id , students.first_name , students.middle_name , students.last_name , count ( * ) , students.student_id from students join student_enrolment on students.student_id = student_enrolment.student_id group by students.student_id order by count ( * ) desc limit 1", "predicted_sql": "select students.student_id  , students.first_name  , students.middle_name  , students.last_name  , count ( student_enrolment.student_id ) as enrolment_count from students join student_enrolment on student_enrolment.student_id = students.student_id group by students.student_id order by enrolment_count desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какой студент чаще всего записывался на любую программу? Укажите id, имя, отчество, фамилию, количество зачислений и id студента. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Каковы имя, отчество и фамилия, а также id и количество зачислений у студента, который имеет больше всего зачислений на любую программу?", "query": "select students.student_id , students.first_name , students.middle_name , students.last_name , count ( * ) , students.student_id from students join student_enrolment on students.student_id = student_enrolment.student_id group by students.student_id order by count ( * ) desc limit 1", "predicted_sql": "select students.first_name  , students.middle_name  , students.last_name  , students.student_id  , count ( student_enrolment.student_enrolment_id ) as enrolment_count from students join student_enrolment on student_enrolment.student_id = students.student_id group by students.student_id order by enrolment_count desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Каковы имя, отчество и фамилия, а также id и количество зачислений у студента, который имеет больше всего зачислений на любую программу? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "На какие семестры не записываются студенты? Укажите название семестра.", "query": "select semester_name from semesters where semester_id not in ( select semester_id from student_enrolment )", "predicted_sql": "select semesters.semester_name from semesters where semesters.semester_id not in ( select student_enrolment.semester_id from student_enrolment )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### На какие семестры не записываются студенты? Укажите название семестра. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Как называется семестр, в который не зачисляются студенты?", "query": "select semester_name from semesters where semester_id not in ( select semester_id from student_enrolment )", "predicted_sql": "select semesters.semester_name from semesters where semesters.semester_id not in ( select student_enrolment.semester_id from student_enrolment )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Как называется семестр, в который не зачисляются студенты? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Как называются все курсы, на которые когда-либо записывались студенты?", "query": "select distinct courses.course_name from courses join student_enrolment_courses on courses.course_id = student_enrolment_courses.course_id", "predicted_sql": "select courses.course_name from courses join student_enrolment_courses on courses.course_id = student_enrolment_courses.course_id join student_enrolment on student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Как называются все курсы, на которые когда-либо записывались студенты? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Как называются все курсы, на которые записаны некоторые студенты?", "query": "select distinct courses.course_name from courses join student_enrolment_courses on courses.course_id = student_enrolment_courses.course_id", "predicted_sql": "select courses.course_name from courses join student_enrolment_courses on courses.course_id = student_enrolment_courses.course_id join student_enrolment on student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id join students on student_enrolment.student_id = students.student_id where students.first_name = 'John' and students.last_name = 'Doe'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Как называются все курсы, на которые записаны некоторые студенты? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Как называется курс с наибольшим количеством зачисленных?", "query": "select courses.course_name from courses join student_enrolment_courses on courses.course_id = student_enrolment_courses.course_id group by courses.course_name order by count ( * ) desc limit 1", "predicted_sql": "select courses.course_name from courses join student_enrolment_courses on courses.course_id = student_enrolment_courses.course_id group by courses.course_name order by count ( student_enrolment_courses.student_enrolment_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Как называется курс с наибольшим количеством зачисленных? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Как называется курс, в котором обучается больше всего студентов?", "query": "select courses.course_name from courses join student_enrolment_courses on courses.course_id = student_enrolment_courses.course_id group by courses.course_name order by count ( * ) desc limit 1", "predicted_sql": "select courses.course_name from courses join student_enrolment_courses on courses.course_id = student_enrolment_courses.course_id group by courses.course_name order by count ( student_enrolment_courses.student_enrolment_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Как называется курс, в котором обучается больше всего студентов? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Показать фамилии студентов, которые в настоящее время проживают в штате Северная Каролина, но не зарегистрировались ни в одной программе на получение степени.", "query": "select students.last_name from students join addresses on students.current_address_id = addresses.address_id where addresses.state_province_county = 'NorthCarolina' except select distinct students.last_name from students join student_enrolment on students.student_id = student_enrolment.student_id", "predicted_sql": "select students.last_name from students join addresses on students.current_address_id = addresses.address_id where addresses.state_province_county = 'Северная Каролина' and students.student_id not in ( select student_id from student_enrolment )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Показать фамилии студентов, которые в настоящее время проживают в штате Северная Каролина, но не зарегистрировались ни в одной программе на получение степени. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Каковы фамилии студентов, которые живут в Северной Каролине, но не зарегистрировались ни на какие программы обучения?", "query": "select students.last_name from students join addresses on students.current_address_id = addresses.address_id where addresses.state_province_county = 'NorthCarolina' except select distinct students.last_name from students join student_enrolment on students.student_id = student_enrolment.student_id", "predicted_sql": "select students.last_name from students join addresses on students.permanent_address_id = addresses.address_id where addresses.state_province_county = 'North Carolina' and students.student_id not in ( select student_id from student_enrolment )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Каковы фамилии студентов, которые живут в Северной Каролине, но не зарегистрировались ни на какие программы обучения? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Показать дату и id транскрипта как минимум с 2 результатами курса.", "query": "select transcripts.transcript_date , transcript_contents.transcript_id from transcript_contents join transcripts on transcript_contents.transcript_id = transcripts.transcript_id group by transcript_contents.transcript_id having count ( * ) >= 2", "predicted_sql": "select transcripts.transcript_date  , transcripts.transcript_id from transcripts join transcript_contents on transcript_contents.transcript_id = transcripts.transcript_id join student_enrolment_courses on student_enrolment_courses.student_course_id = transcript_contents.student_course_id group by student_enrolment_courses.course_id having count ( student_enrolment_courses.course_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Показать дату и id транскрипта как минимум с 2 результатами курса. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какова дата и id транскрипта с указанием как минимум 2 курсов?", "query": "select transcripts.transcript_date , transcript_contents.transcript_id from transcript_contents join transcripts on transcript_contents.transcript_id = transcripts.transcript_id group by transcript_contents.transcript_id having count ( * ) >= 2", "predicted_sql": "select transcripts.transcript_date  , transcripts.transcript_id from transcripts join transcript_contents on transcript_contents.transcript_id = transcripts.transcript_id join student_enrolment_courses on student_enrolment_courses.student_course_id = transcript_contents.student_course_id group by transcripts.transcript_date  , transcripts.transcript_id having count ( distinct student_enrolment_courses.course_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какова дата и id транскрипта с указанием как минимум 2 курсов? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какой номер телефона у человека по имени Тимофей и фамилии Улицкий?", "query": "select cell_mobile_number from students where first_name = 'Тимофей' and last_name = 'Улицкий'", "predicted_sql": "select students.cell_mobile_number from students where students.first_name = 'Тимофей' and students.last_name = 'Улицкий'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name ( Тимофей ) , students.middle_name , students.last_name ( Улицкий ) , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какой номер телефона у человека по имени Тимофей и фамилии Улицкий? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какой номер мобильного телефона у студента по имени Тимофей Улицкий?", "query": "select cell_mobile_number from students where first_name = 'Тимофей' and last_name = 'Улицкий'", "predicted_sql": "select students.cell_mobile_number from students where students.first_name = 'Тимофей' and students.last_name = 'Улицкий'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name ( Тимофей ) , students.middle_name , students.last_name ( Улицкий ) , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какой номер мобильного телефона у студента по имени Тимофей Улицкий? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Кто первым из студентов зарегистрировался? Показать имя, отчество и фамилию.", "query": "select first_name , middle_name , last_name from students order by date_first_registered asc limit 1", "predicted_sql": "select students.first_name  , students.middle_name  , students.last_name from students order by students.date_first_registered asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Кто первым из студентов зарегистрировался? Показать имя, отчество и фамилию. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Каковы имя, отчество и фамилия первого зарегистрировавшегося студента?", "query": "select first_name , middle_name , last_name from students order by date_first_registered asc limit 1", "predicted_sql": "select students.first_name  , students.middle_name  , students.last_name from students order by students.date_first_registered asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Каковы имя, отчество и фамилия первого зарегистрировавшегося студента? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Кто первый выпускник школы? Отображать имя, отчество и фамилию.", "query": "select first_name , middle_name , last_name from students order by date_left asc limit 1", "predicted_sql": "select students.first_name  , students.middle_name  , students.last_name from students order by students.date_first_registered asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Кто первый выпускник школы? Отображать имя, отчество и фамилию. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Каковы имя, отчество и фамилия первого выпускника школы?", "query": "select first_name , middle_name , last_name from students order by date_left asc limit 1", "predicted_sql": "select students.first_name  , students.middle_name  , students.last_name from students join student_enrolment on students.student_id = student_enrolment.student_id join degree_programs on student_enrolment.degree_program_id = degree_programs.degree_program_id where degree_programs.degree_summary_name = 'Выпускник' order by students.date_first_registered asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Каковы имя, отчество и фамилия первого выпускника школы? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Чей постоянный адрес отличается от его нынешнего адреса? Укажите его или ее имя.", "query": "select first_name from students where current_address_id != permanent_address_id", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Чей постоянный адрес отличается от его нынешнего адреса? Укажите его или ее имя. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Как зовут студента, постоянный адрес которого отличается от его нынешнего?", "query": "select first_name from students where current_address_id != permanent_address_id", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Как зовут студента, постоянный адрес которого отличается от его нынешнего? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "По какому адресу сейчас проживает наибольшее количество студентов? Показать id адреса и все адресные строки.", "query": "select addresses.address_id , addresses.line_1 , addresses.line_2 from addresses join students on addresses.address_id = students.current_address_id group by addresses.address_id order by count ( * ) desc limit 1", "predicted_sql": "select addresses.address_id  , addresses.line_1  , addresses.line_2  , addresses.line_3  , addresses.city  , addresses.zip_postcode  , addresses.state_province_county  , addresses.country  , addresses.other_address_details from students join addresses on students.current_address_id = addresses.address_id group by addresses.address_id order by count ( students.student_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### По какому адресу сейчас проживает наибольшее количество студентов? Показать id адреса и все адресные строки. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Каковы id, строка 1 и строка 2 адреса с наибольшим количеством студентов?", "query": "select addresses.address_id , addresses.line_1 , addresses.line_2 from addresses join students on addresses.address_id = students.current_address_id group by addresses.address_id order by count ( * ) desc limit 1", "predicted_sql": "select addresses.address_id  , addresses.line_1  , addresses.line_2 from addresses join students on students.permanent_address_id = addresses.address_id group by addresses.address_id order by count ( students.student_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Каковы id, строка 1 и строка 2 адреса с наибольшим количеством студентов? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Когда в среднем были напечатаны транскрипт?", "query": "select avg ( transcript_date ) from transcripts", "predicted_sql": "select avg ( transcripts.transcript_date ) as average_transcript_date from transcripts", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Когда в среднем были напечатаны транскрипт? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какая в среднем дата транскрипта?", "query": "select avg ( transcript_date ) from transcripts", "predicted_sql": "select avg ( transcripts.transcript_date ) from transcripts", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какая в среднем дата транскрипта? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Когда будет выпущен первый транскрипт? Укажите дату и подробности.", "query": "select transcript_date , other_details from transcripts order by transcript_date asc limit 1", "predicted_sql": "select transcripts.transcript_date  , transcripts.other_details from transcripts order by transcripts.transcript_date asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Когда будет выпущен первый транскрипт? Укажите дату и подробности. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какая самая ранняя дата выпуска транскрипта и какие подробности вы можете мне сообщить?", "query": "select transcript_date , other_details from transcripts order by transcript_date asc limit 1", "predicted_sql": "select min ( transcripts.transcript_date ) as earliest_transcript_date  , transcripts.other_details from transcripts", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какая самая ранняя дата выпуска транскрипта и какие подробности вы можете мне сообщить? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Сколько стенограмм выпущено?", "query": "select count ( * ) from transcripts", "predicted_sql": "select count ( transcripts.transcript_id ) from transcripts", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Сколько стенограмм выпущено? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Сколько стенограмм указано?", "query": "select count ( * ) from transcripts", "predicted_sql": "select count ( transcripts.transcript_id ) from transcripts", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Сколько стенограмм указано? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какая дата выпуска последней стенограммы?", "query": "select transcript_date from transcripts order by transcript_date desc limit 1", "predicted_sql": "select max ( transcripts.transcript_date ) from transcripts", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какая дата выпуска последней стенограммы? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Когда была опубликована последняя стенограмма?", "query": "select transcript_date from transcripts order by transcript_date desc limit 1", "predicted_sql": "select transcripts.transcript_date from transcripts order by transcripts.transcript_date desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Когда была опубликована последняя стенограмма? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Сколько раз результат зачисления на курс может отображаться в разных транскриптах? Также покажите id записи на курс.", "query": "select count ( * ) , student_course_id from transcript_contents group by student_course_id order by count ( * ) desc limit 1", "predicted_sql": "select count ( distinct transcripts.transcript_id ) as count_transcripts  , student_enrolment_courses.student_course_id from student_enrolment_courses join transcript_contents on transcript_contents.student_course_id = student_enrolment_courses.student_course_id join transcripts on transcripts.transcript_id = transcript_contents.transcript_id group by student_enrolment_courses.student_course_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Сколько раз результат зачисления на курс может отображаться в разных транскриптах? Также покажите id записи на курс. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какое максимальное количество раз курс появляется в разных транскриптах и каков id регистрации этого курса?", "query": "select count ( * ) , student_course_id from transcript_contents group by student_course_id order by count ( * ) desc limit 1", "predicted_sql": "select student_enrolment_courses.course_id  , count ( transcript_contents.transcript_id ) as num_transcripts from student_enrolment_courses join transcript_contents on transcript_contents.student_course_id = student_enrolment_courses.student_course_id group by student_enrolment_courses.course_id order by num_transcripts desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какое максимальное количество раз курс появляется в разных транскриптах и каков id регистрации этого курса? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Дата стенограммы, которая показывает наименьшее количество результатов, вместе с id стенограммы.", "query": "select transcripts.transcript_date , transcript_contents.transcript_id from transcript_contents join transcripts on transcript_contents.transcript_id = transcripts.transcript_id group by transcript_contents.transcript_id order by count ( * ) asc limit 1", "predicted_sql": "select transcripts.transcript_date  , transcripts.transcript_id from transcripts join transcript_contents on transcript_contents.transcript_id = transcripts.transcript_id group by transcripts.transcript_date  , transcripts.transcript_id order by count ( * ) asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Дата стенограммы, которая показывает наименьшее количество результатов, вместе с id стенограммы. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какая дата и id стенограммы с наименьшим количеством результатов?", "query": "select transcripts.transcript_date , transcript_contents.transcript_id from transcript_contents join transcripts on transcript_contents.transcript_id = transcripts.transcript_id group by transcript_contents.transcript_id order by count ( * ) asc limit 1", "predicted_sql": "select transcripts.transcript_date  , transcripts.transcript_id from transcripts join transcript_contents on transcripts.transcript_id = transcript_contents.transcript_id group by transcripts.transcript_date  , transcripts.transcript_id order by count ( * ) asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какая дата и id стенограммы с наименьшим количеством результатов? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Найдите семестр, в который были зачислены и студенты аспирантуры, и студенты докторантуры.", "query": "select distinct student_enrolment.semester_id from degree_programs join student_enrolment on degree_programs.degree_program_id = student_enrolment.degree_program_id where degree_summary_name = 'Кандидатская' intersect select distinct student_enrolment.semester_id from degree_programs join student_enrolment on degree_programs.degree_program_id = student_enrolment.degree_program_id where degree_summary_name = 'Аспирансткая'", "predicted_sql": "select semesters.semester_name from semesters join student_enrolment on semesters.semester_id = student_enrolment.semester_id join degree_programs on student_enrolment.degree_program_id = degree_programs.degree_program_id where degree_programs.degree_summary_name in ( 'аспирантура'  , 'докторантура' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Найдите семестр, в который были зачислены и студенты аспирантуры, и студенты докторантуры. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Каков id семестра, в который зачислены студенты аспирантуры и докторантуры?", "query": "select distinct student_enrolment.semester_id from degree_programs join student_enrolment on degree_programs.degree_program_id = student_enrolment.degree_program_id where degree_summary_name = 'Кандидатская' intersect select distinct student_enrolment.semester_id from degree_programs join student_enrolment on degree_programs.degree_program_id = student_enrolment.degree_program_id where degree_summary_name = 'Аспирансткая'", "predicted_sql": "select semesters.semester_id from semesters join student_enrolment on semesters.semester_id = student_enrolment.semester_id join degree_programs on student_enrolment.degree_program_id = degree_programs.degree_program_id where degree_programs.degree_summary_name in ( 'аспирантура'  , 'докторантура' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Каков id семестра, в который зачислены студенты аспирантуры и докторантуры? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "По скольким адресам сейчас проживают студенты?", "query": "select count ( distinct current_address_id ) from students", "predicted_sql": "select count ( distinct students.current_address_id ) as num_addresses from students", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### По скольким адресам сейчас проживают студенты? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "По каким адресам живут студенты?", "query": "select count ( distinct current_address_id ) from students", "predicted_sql": "select addresses.line_1  , addresses.line_2  , addresses.line_3  , addresses.city  , addresses.zip_postcode  , addresses.state_province_county  , addresses.country  , addresses.other_address_details from students join addresses on students.permanent_address_id = addresses.address_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### По каким адресам живут студенты? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Перечислите все сведения о студентах в обратном лексикографическом порядке.", "query": "select other_student_details from students order by other_student_details desc", "predicted_sql": "select students.student_id  , students.current_address_id  , students.permanent_address_id  , students.first_name  , students.middle_name  , students.last_name  , students.cell_mobile_number  , students.email_address  , students.ssn  , students.date_first_registered  , students.date_left  , students.other_student_details from students order by students.last_name desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Перечислите все сведения о студентах в обратном лексикографическом порядке. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Какие еще подробности о студентах вы можете рассказать в обратном алфавитном порядке?", "query": "select other_student_details from students order by other_student_details desc", "predicted_sql": "select students.other_student_details from students order by students.other_student_details desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Какие еще подробности о студентах вы можете рассказать в обратном алфавитном порядке? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Опишите раздел h.", "query": "select section_description from sections where section_name = 'h'", "predicted_sql": "select students.first_name  , students.last_name  , courses.course_name  , sections.section_name  , semesters.semester_name from students join student_enrolment on students.student_id = student_enrolment.student_id join student_enrolment_courses on student_enrolment.student_enrolment_id = student_enrolment_courses.student_enrolment_id join courses on student_enrolment_courses.course_id = courses.course_id join sections on sections.course_id = courses.course_id join semesters on student_enrolment.semester_id = semesters.semester_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Опишите раздел h. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Каково описание раздела с названием h?", "query": "select section_description from sections where section_name = 'h'", "predicted_sql": "select sections.section_description from sections where sections.section_name = 'h'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Каково описание раздела с названием h? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Найдите имена студентов, которые постоянно проживают в стране Куба, или у которых есть номер мобильного телефона (605)919-3594x3661.", "query": "select students.first_name from students join addresses on students.permanent_address_id = addresses.address_id where addresses.country = 'Куба' or students.cell_mobile_number = '(605)919-3594x3661'", "predicted_sql": "select students.first_name  , students.last_name from students join addresses on students.permanent_address_id = addresses.address_id where addresses.country = 'Куба' or students.cell_mobile_number = '(605)919-3594x3661'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country ( Куба ) , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number ( (605)919-3594x3661 ) , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Найдите имена студентов, которые постоянно проживают в стране Куба, или у которых есть номер мобильного телефона (605)919-3594x3661. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Как зовут студентов, которые постоянно живут на Кубе или имеют номер мобильного телефона (605)919-3594x3661?", "query": "select students.first_name from students join addresses on students.permanent_address_id = addresses.address_id where addresses.country = 'Куба' or students.cell_mobile_number = '(605)919-3594x3661'", "predicted_sql": "select students.first_name  , students.middle_name  , students.last_name from students join addresses on students.permanent_address_id = addresses.address_id where addresses.country = 'Cuba' or students.cell_mobile_number = '(605)919-3594x3661'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number ( (605)919-3594x3661 ) , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Как зовут студентов, которые постоянно живут на Кубе или имеют номер мобильного телефона (605)919-3594x3661? \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "tvshow", "question": "Перечислите названия всех мультфильмов в алфавитном порядке.", "query": "select title from cartoon order by title asc", "predicted_sql": "select cartoon.title from cartoon order by cartoon.title asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Перечислите названия всех мультфильмов в алфавитном порядке. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какие есть названия мультфильмов, отсортированные по алфавиту?", "query": "select title from cartoon order by title asc", "predicted_sql": "select cartoon.title from cartoon order by cartoon.title asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какие есть названия мультфильмов, отсортированные по алфавиту? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Список всех мультфильмов режиссера «Денис Устинов».", "query": "select title from cartoon where directed_by = 'Денис Устинов'", "predicted_sql": "select cartoon.title from cartoon where cartoon.directed_by = 'Денис Устинов'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Список всех мультфильмов режиссера «Денис Устинов». \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Как называются все мультфильмы Дениса Устинова?", "query": "select title from cartoon where directed_by = 'Денис Устинов'", "predicted_sql": "select cartoon.title from cartoon where cartoon.directed_by = 'Денис Устинов'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Как называются все мультфильмы Дениса Устинова? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Сколько мультфильмов создал «Тимур Вадимов»?", "query": "select count ( * ) from cartoon where written_by = 'Тимур Вадимов'", "predicted_sql": "select count ( * ) from cartoon where cartoon.directed_by = 'Тимур Вадимов'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Сколько мультфильмов создал «Тимур Вадимов»? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Сколько мультфильмов написал Тимур Вадимов?", "query": "select count ( * ) from cartoon where written_by = 'Тимур Вадимов'", "predicted_sql": "select count ( * ) from cartoon where cartoon.written_by = 'Тимур Вадимов'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by ( Тимур Вадимов ) , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Сколько мультфильмов написал Тимур Вадимов? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "перечислить все названия мультфильмов и их режиссеров по дате выхода в эфир", "query": "select title , directed_by from cartoon order by original_air_date asc", "predicted_sql": "select cartoon.title  , cartoon.directed_by from cartoon order by cartoon.original_air_date asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### перечислить все названия мультфильмов и их режиссеров по дате выхода в эфир \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Названия и режиссеры всех мультфильмов, сортированных по дате выхода в эфир", "query": "select title , directed_by from cartoon order by original_air_date asc", "predicted_sql": "select cartoon.title  , cartoon.directed_by from cartoon order by cartoon.original_air_date asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Названия и режиссеры всех мультфильмов, сортированных по дате выхода в эфир \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Перечислите названия всех мультфильмов, поставленных «Денисом Устиновым» или «Богданом Чуприковым».", "query": "select title from cartoon where directed_by = 'Денис Устинов' or directed_by = 'Богдан Чуприков'", "predicted_sql": "select cartoon.title from cartoon where cartoon.directed_by = 'Денис Устинов' or cartoon.directed_by = 'Богдан Чуприков'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Перечислите названия всех мультфильмов, поставленных «Денисом Устиновым» или «Богданом Чуприковым». \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Как называются все мультфильмы Дениса Устинова или Богдана Чуприкова?", "query": "select title from cartoon where directed_by = 'Денис Устинов' or directed_by = 'Богдан Чуприков'", "predicted_sql": "select cartoon.title from cartoon where cartoon.directed_by = 'Денис Устинов' or cartoon.directed_by = 'Богдан Чуприков'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Как называются все мультфильмы Дениса Устинова или Богдана Чуприкова? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "В какой стране больше всего телеканалов? Укажите страну и количество имеющихся в ней телеканалов.", "query": "select country , count ( * ) from tv_channel group by country order by count ( * ) desc limit 1", "predicted_sql": "select tv_channel.country  , count ( tv_channel.id ) as channel_count from tv_channel group by tv_channel.country order by channel_count desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### В какой стране больше всего телеканалов? Укажите страну и количество имеющихся в ней телеканалов. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "В какой стране больше всего телеканалов и сколько их?", "query": "select country , count ( * ) from tv_channel group by country order by count ( * ) desc limit 1", "predicted_sql": "select tv_channel.country  , count ( tv_channel.id ) as total_channels from tv_channel group by tv_channel.country order by total_channels desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### В какой стране больше всего телеканалов и сколько их? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Укажите количество названий и содержания различных сериалов в таблице телеканалов.", "query": "select count ( distinct series_name ) , count ( distinct content ) from tv_channel", "predicted_sql": "select count ( distinct tv_channel.series_name ) as number_of_series  , count ( distinct tv_channel.content ) as number_of_contents from tv_channel", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Укажите количество названий и содержания различных сериалов в таблице телеканалов. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Сколько различных сериалов и содержаний указано в таблице телеканалов?", "query": "select count ( distinct series_name ) , count ( distinct content ) from tv_channel", "predicted_sql": "select count ( distinct tv_channel.series_name ) as num_series  , count ( distinct tv_channel.content ) as num_content from tv_channel", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Сколько различных сериалов и содержаний указано в таблице телеканалов? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Что представляет собой сериал с названием 'Пятница\"?", "query": "select content from tv_channel where series_name = 'Пятница'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name ( Пятница ) , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Что представляет собой сериал с названием 'Пятница\"? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Каково содержание сериала Пятница?", "query": "select content from tv_channel where series_name = 'Пятница'", "predicted_sql": "select tv_channel.content from tv_channel where tv_channel.series_name = 'Пятница'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name ( Пятница ) , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Каково содержание сериала Пятница? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Что такое пакетный вариант сериала под названием 'Пятница'?", "query": "select package_option from tv_channel where series_name = 'Пятница'", "predicted_sql": "select tv_channel.package_option from tv_channel where tv_channel.series_name = 'Пятница'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name ( Пятница ) , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Что такое пакетный вариант сериала под названием 'Пятница'? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какие пакеты предложений имеют сериалы, которые называются Пятница?", "query": "select package_option from tv_channel where series_name = 'Пятница'", "predicted_sql": "select tv_channel.package_option from tv_channel join tv_series on tv_series.channel = tv_channel.id where tv_channel.series_name = 'Пятница'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name ( Пятница ) , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какие пакеты предложений имеют сериалы, которые называются Пятница? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Сколько телеканалов используют албанский язык?", "query": "select count ( * ) from tv_channel where language = 'Албанский'", "predicted_sql": "select count ( * ) from tv_channel where language = 'Албанский'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language ( Албанский ) , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Сколько телеканалов используют албанский язык? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Сколько телеканалов на албанском языке?", "query": "select count ( * ) from tv_channel where language = 'Албанский'", "predicted_sql": "select count ( * ) from tv_channel where language = 'albanian'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Сколько телеканалов на албанском языке? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Укажите язык, на котором транслируют наименьшее количество телеканалов. Показать язык и номер телеканала.", "query": "select language , count ( * ) from tv_channel group by language order by count ( * ) asc limit 1", "predicted_sql": "select tv_channel.language  , count ( tv_channel.id ) as channel_count from tv_channel group by tv_channel.language order by channel_count asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Укажите язык, на котором транслируют наименьшее количество телеканалов. Показать язык и номер телеканала. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какие языки используют наименьшее количество телеканалов и сколько каналов их используют?", "query": "select language , count ( * ) from tv_channel group by language order by count ( * ) asc limit 1", "predicted_sql": "select tv_channel.language  , count ( tv_channel.language ) as channel_count from tv_channel group by tv_channel.language order by channel_count asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какие языки используют наименьшее количество телеканалов и сколько каналов их используют? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Перечислите каждый язык и количество телеканалов, которые его используют.", "query": "select language , count ( * ) from tv_channel group by language", "predicted_sql": "select tv_channel.language  , count ( tv_channel.id ) as channel_count from tv_channel group by tv_channel.language", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Перечислите каждый язык и количество телеканалов, которые его используют. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Для каждого языка укажите количество телеканалов, которые его используют.", "query": "select language , count ( * ) from tv_channel group by language", "predicted_sql": "select tv_channel.language  , count ( tv_channel.id ) as channel_count from tv_channel group by tv_channel.language", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Для каждого языка укажите количество телеканалов, которые его используют. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "На каком телеканале идет мультфильм «Смешарики»? Укажите название телеканала.", "query": "select tv_channel.series_name from tv_channel join cartoon on tv_channel.id = cartoon.channel where cartoon.title = 'Смешарики'", "predicted_sql": "select tv_channel.series_name from tv_channel join cartoon on cartoon.channel = tv_channel.id where cartoon.title = 'Смешарики'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### На каком телеканале идет мультфильм «Смешарики»? Укажите название телеканала. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Как называется телеканал, на котором показывают мультфильм «Смешарики»?", "query": "select tv_channel.series_name from tv_channel join cartoon on tv_channel.id = cartoon.channel where cartoon.title = 'Смешарики'", "predicted_sql": "select tv_channel.series_name from tv_channel join cartoon on cartoon.channel = tv_channel.id where cartoon.title = 'Смешарики'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Как называется телеканал, на котором показывают мультфильм «Смешарики»? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Перечислить названия всех мультфильмов, показываемых на телеканале где есть сериал 'Пятница\".", "query": "select cartoon.title from tv_channel join cartoon on tv_channel.id = cartoon.channel where tv_channel.series_name = 'Пятница'", "predicted_sql": "select cartoon.title from cartoon join tv_channel on cartoon.channel = tv_channel.id join tv_series on tv_series.channel = tv_channel.id where tv_channel.series_name = 'Пятница'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name ( Пятница ) , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Перечислить названия всех мультфильмов, показываемых на телеканале где есть сериал 'Пятница\". \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Как называются все мультфильмы, которые идут на телеканале где идет «Пятница»?", "query": "select cartoon.title from tv_channel join cartoon on tv_channel.id = cartoon.channel where tv_channel.series_name = 'Пятница'", "predicted_sql": "select cartoon.title from cartoon join tv_channel on cartoon.channel = tv_channel.id where tv_channel.series_name = 'Пятница'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Как называются все мультфильмы, которые идут на телеканале где идет «Пятница»? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Список эпизодов всех сериалов, отсортированных по рейтингу.", "query": "select episode from tv_series order by rating asc", "predicted_sql": "select tv_series.episode from tv_series order by tv_series.rating asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Список эпизодов всех сериалов, отсортированных по рейтингу. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Показать все серии сериала, отсортированные по рейтингу", "query": "select episode from tv_series order by rating asc", "predicted_sql": "select tv_series.episode from tv_series order by tv_series.rating asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Показать все серии сериала, отсортированные по рейтингу \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "топ-3 сериала с самым высоким рейтингом. Указать серию сериала и рейтинг.", "query": "select episode , rating from tv_series order by rating desc limit 3", "predicted_sql": "select tv_series.episode  , tv_series.rating from tv_series order by tv_series.rating desc limit 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### топ-3 сериала с самым высоким рейтингом. Указать серию сериала и рейтинг. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какие 3 эпизода в таблице сериалов имеют самые высокие оценки и каковы были эти рейтинги?", "query": "select episode , rating from tv_series order by rating desc limit 3", "predicted_sql": "select tv_series.episode  , tv_series.rating from tv_series order by tv_series.rating desc limit 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какие 3 эпизода в таблице сериалов имеют самые высокие оценки и каковы были эти рейтинги? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какая минимальная и максимальная доля сериалов?", "query": "select max ( share ) , min ( share ) from tv_series", "predicted_sql": "select min ( tv_series.share )  , max ( tv_series.share ) from tv_series", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какая минимальная и максимальная доля сериалов? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какая максимальная и минимальная доля сериалов на телеканале?", "query": "select max ( share ) , min ( share ) from tv_series", "predicted_sql": "select max ( tv_series.share ) as max_share  , min ( tv_series.share ) as min_share from tv_series join tv_channel on tv_series.channel = tv_channel.id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какая максимальная и минимальная доля сериалов на телеканале? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какая дата выхода сериала с эпизодом «Любовь всей жизни»?", "query": "select air_date from tv_series where episode = 'Любовь всей жизни'", "predicted_sql": "select tv_series.air_date from tv_series where tv_series.episode = 'Любовь всей жизни'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какая дата выхода сериала с эпизодом «Любовь всей жизни»? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Когда вышел в эфир эпизод \"Любовь всей жизни\"?", "query": "select air_date from tv_series where episode = 'Любовь всей жизни'", "predicted_sql": "select tv_series.air_date from tv_series where tv_series.episode = 'Любовь всей жизни'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode ( Любовь всей жизни ) , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Когда вышел в эфир эпизод \"Любовь всей жизни\"? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Каков еженедельный рейтинг сериала с эпизодом «Любовь всей жизни»?", "query": "select weekly_rank from tv_series where episode = 'Любовь всей жизни'", "predicted_sql": "select tv_series.rating from tv_series where tv_series.episode = 'Любовь всей жизни'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Каков еженедельный рейтинг сериала с эпизодом «Любовь всей жизни»? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какой еженедельный рейтинг у серии «Любовь всей жизни»?", "query": "select weekly_rank from tv_series where episode = 'Любовь всей жизни'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какой еженедельный рейтинг у серии «Любовь всей жизни»? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "На каком телеканале есть сериал с эпизодом «Любовь всей жизни»? Укажите название сериала.", "query": "select tv_channel.series_name from tv_channel join tv_series on tv_channel.id = tv_series.channel where tv_series.episode = 'Любовь всей жизни'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### На каком телеканале есть сериал с эпизодом «Любовь всей жизни»? Укажите название сериала. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Как называется сериал, в котором есть серия «Любовь всей жизни»?", "query": "select tv_channel.series_name from tv_channel join tv_series on tv_channel.id = tv_series.channel where tv_series.episode = 'Любовь всей жизни'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Как называется сериал, в котором есть серия «Любовь всей жизни»? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Перечислить серии, показываемых в сериале с названием 'Пятница\".", "query": "select tv_series.episode from tv_channel join tv_series on tv_channel.id = tv_series.channel where tv_channel.series_name = 'Пятница'", "predicted_sql": "select tv_series.episode from tv_series join tv_channel on tv_series.channel = tv_channel.id where tv_channel.series_name = 'Пятница'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name ( Пятница ) , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Перечислить серии, показываемых в сериале с названием 'Пятница\". \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какая есть серия сериала «Пятница»?", "query": "select tv_series.episode from tv_channel join tv_series on tv_channel.id = tv_series.channel where tv_channel.series_name = 'Пятница'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какая есть серия сериала «Пятница»? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Найдите количество мультфильмов, поставленных каждым из перечисленных режиссеров.", "query": "select count ( * ) , directed_by from cartoon group by directed_by", "predicted_sql": "select cartoon.directed_by  , count ( cartoon.id ) as count from cartoon group by cartoon.directed_by", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Найдите количество мультфильмов, поставленных каждым из перечисленных режиссеров. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Сколько мультфильмов создал каждый режиссер?", "query": "select count ( * ) , directed_by from cartoon group by directed_by", "predicted_sql": "select cartoon.directed_by  , count ( cartoon.id ) as total_cartoons from cartoon group by cartoon.directed_by", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Сколько мультфильмов создал каждый режиссер? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Найдите производственный код и канал последнего вышедшего в эфир мультфильма.", "query": "select production_code , channel from cartoon order by original_air_date desc limit 1", "predicted_sql": "select cartoon.production_code  , tv_channel.id from cartoon join tv_channel on cartoon.channel = tv_channel.id order by cartoon.original_air_date desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Найдите производственный код и канал последнего вышедшего в эфир мультфильма. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какой производственный код и канал у последнего мультфильма?", "query": "select production_code , channel from cartoon order by original_air_date desc limit 1", "predicted_sql": "select cartoon.production_code  , cartoon.channel from cartoon inner join tv_channel on cartoon.channel = tv_channel.id order by cartoon.original_air_date desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какой производственный код и канал у последнего мультфильма? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Найти пакет предложений и название сериалов телеканала, на котором есть видео высокой четкости.", "query": "select package_option , series_name from tv_channel where hight_definition_tv = 'yes'", "predicted_sql": "select tv_channel.package_option  , tv_channel.series_name from tv_channel where tv_channel.hight_definition_tv = 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Найти пакет предложений и название сериалов телеканала, на котором есть видео высокой четкости. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какие есть варианты пакета и названия сериалов телеканала, поддерживающего видео высокого разрешения?", "query": "select package_option , series_name from tv_channel where hight_definition_tv = 'yes'", "predicted_sql": "select tv_channel.package_option  , tv_channel.series_name from tv_channel where tv_channel.hight_definition_tv = 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какие есть варианты пакета и названия сериалов телеканала, поддерживающего видео высокого разрешения? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "На телеканалах каких стран транслируется какой-нибудь мультфильм Ридли Скотта?", "query": "select tv_channel.country from tv_channel join cartoon on tv_channel.id = cartoon.channel where cartoon.written_by = 'Ридли Скотт'", "predicted_sql": "select tv_channel.country from tv_channel join cartoon on cartoon.channel = tv_channel.id where cartoon.directed_by = 'Ридли Скотт'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by ( Ридли Скотт ) , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### На телеканалах каких стран транслируется какой-нибудь мультфильм Ридли Скотта? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "В каких странах показывают мультфильмы, написанные Ридли Скоттом?", "query": "select tv_channel.country from tv_channel join cartoon on tv_channel.id = cartoon.channel where cartoon.written_by = 'Ридли Скотт'", "predicted_sql": "select tv_channel.country from cartoon join tv_channel on cartoon.channel = tv_channel.id where cartoon.written_by = 'Ридли Скотт'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by ( Ридли Скотт ) , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### В каких странах показывают мультфильмы, написанные Ридли Скоттом? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "телеканалы каких стран не показывают мультфильмы, написанные Ридли Скоттом?", "query": "select country from tv_channel except select tv_channel.country from tv_channel join cartoon on tv_channel.id = cartoon.channel where cartoon.written_by = 'Ридли Скотт'", "predicted_sql": "select tv_channel.country from tv_channel where tv_channel.id not in ( select cartoon.channel from cartoon where cartoon.written_by = 'Ридли Скотт' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by ( Ридли Скотт ) , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### телеканалы каких стран не показывают мультфильмы, написанные Ридли Скоттом? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "В каких странах не показывают мультфильмы Ридли Скотта?", "query": "select country from tv_channel except select tv_channel.country from tv_channel join cartoon on tv_channel.id = cartoon.channel where cartoon.written_by = 'Ридли Скотт'", "predicted_sql": "select tv_channel.country from tv_channel join cartoon on cartoon.channel = tv_channel.id where cartoon.written_by <> 'Ридли Скотт'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by ( Ридли Скотт ) , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### В каких странах не показывают мультфильмы Ридли Скотта? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Найдите программу и страну телеканала, на котором транслируются мультфильмы Федора Бондарчука и Николая Лебедева", "query": "select tv_channel.series_name , tv_channel.country from tv_channel join cartoon on tv_channel.id = cartoon.channel where cartoon.directed_by = 'Николай Лебедев' intersect select tv_channel.series_name , tv_channel.country from tv_channel join cartoon on tv_channel.id = cartoon.channel where cartoon.directed_by = 'Федор Бондарчук'", "predicted_sql": "select tv_channel.content  , tv_channel.country from tv_channel join cartoon on cartoon.channel = tv_channel.id where cartoon.directed_by = 'Федор Бондарчук' and cartoon.written_by = 'Николай Лебедев'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Найдите программу и страну телеканала, на котором транслируются мультфильмы Федора Бондарчука и Николая Лебедева \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какая программа и страна у всех телеканалов, которые показывают мультфильмы Федора Бондарчука и Николая Лебедева?", "query": "select tv_channel.series_name , tv_channel.country from tv_channel join cartoon on tv_channel.id = cartoon.channel where cartoon.directed_by = 'Николай Лебедев' intersect select tv_channel.series_name , tv_channel.country from tv_channel join cartoon on tv_channel.id = cartoon.channel where cartoon.directed_by = 'Федор Бондарчук'", "predicted_sql": "select tv_channel.content  , tv_channel.country from tv_channel join cartoon on cartoon.channel = tv_channel.id where cartoon.directed_by = 'Федор Бондарчук' and cartoon.written_by = 'Николай Лебедев'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какая программа и страна у всех телеканалов, которые показывают мультфильмы Федора Бондарчука и Николая Лебедева? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Найдите соотношение сторон пикселей и страну телеканалов, которые не используют албанский язык.", "query": "select pixel_aspect_ratio_par , country from tv_channel where language != 'Албанский'", "predicted_sql": "select tv_channel.pixel_aspect_ratio_par  , tv_channel.country from tv_channel where tv_channel.language  != 'Албанский'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language ( Албанский ) , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Найдите соотношение сторон пикселей и страну телеканалов, которые не используют албанский язык. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какое соотношение сторон пикселей и страна происхождения у всех телеканалов, не использующих албанский язык?", "query": "select pixel_aspect_ratio_par , country from tv_channel where language != 'Албанский'", "predicted_sql": "select tv_channel.pixel_aspect_ratio_par  , tv_channel.country from tv_channel where tv_channel.language  != 'Албанский'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language ( Албанский ) , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какое соотношение сторон пикселей и страна происхождения у всех телеканалов, не использующих албанский язык? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "найти id телеканалов из стран, где есть более двух телеканалов.", "query": "select id from tv_channel group by country having count ( * ) > 2", "predicted_sql": "select tv_channel.id from tv_channel group by tv_channel.country having count ( tv_channel.id ) > 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### найти id телеканалов из стран, где есть более двух телеканалов. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какие id у всех телеканалов, на которых больше 2 программ?", "query": "select id from tv_channel group by country having count ( * ) > 2", "predicted_sql": "select tv_channel.id from tv_channel group by tv_channel.id having count ( * ) > 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какие id у всех телеканалов, на которых больше 2 программ? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "найти id телеканалов, на которых не воспроизводятся мультфильмы Федора Бондарчука.", "query": "select id from tv_channel except select channel from cartoon where directed_by = 'Федор Бондарчук'", "predicted_sql": "select tv_channel.id from tv_channel left join cartoon on cartoon.channel = tv_channel.id where cartoon.title  != 'Федор Бондарчук' or cartoon.title is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### найти id телеканалов, на которых не воспроизводятся мультфильмы Федора Бондарчука. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какие id телеканалов, на которых нет мультфильмов Федора Бондарчука?", "query": "select id from tv_channel except select channel from cartoon where directed_by = 'Федор Бондарчук'", "predicted_sql": "select tv_channel.id from tv_channel where tv_channel.id not in ( select cartoon.channel from cartoon where cartoon.directed_by = 'Федор Бондарчук' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv ( нет ) , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какие id телеканалов, на которых нет мультфильмов Федора Бондарчука? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "найдите вариант пакета телеканалов, в котором нет ни одного мультфильма Федора Бондарчука.", "query": "select package_option from tv_channel where id not in ( select channel from cartoon where directed_by = 'Федор Бондарчук' )", "predicted_sql": "select tv_channel.package_option from tv_channel where tv_channel.id not in ( select cartoon.channel from cartoon where cartoon.directed_by = 'Федор Бондарчук' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv ( нет ) , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### найдите вариант пакета телеканалов, в котором нет ни одного мультфильма Федора Бондарчука. \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "tvshow", "question": "Какие есть варианты пакетов телеканалов, на которых не воспроизводятся мультфильмы Федора Бондарчука?", "query": "select package_option from tv_channel where id not in ( select channel from cartoon where directed_by = 'Федор Бондарчук' )", "predicted_sql": "select tv_channel.package_option from tv_channel where tv_channel.content  != 'мультфильм' and tv_channel.series_name  != 'Федор Бондарчук'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Какие есть варианты пакетов телеканалов, на которых не воспроизводятся мультфильмы Федора Бондарчука? \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "poker_player", "question": "Сколько в покере игроков?", "query": "select count ( * ) from poker_player", "predicted_sql": "select count ( * ) from poker_player", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Сколько в покере игроков? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Подсчитайте количество игроков в покер.", "query": "select count ( * ) from poker_player", "predicted_sql": "select count ( * ) from poker_player", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Подсчитайте количество игроков в покер. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Перечислите заработки игроков в покер в порядке убывания.", "query": "select earnings from poker_player order by earnings desc", "predicted_sql": "select poker_player.earnings from poker_player order by poker_player.earnings desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Перечислите заработки игроков в покер в порядке убывания. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Каковы доходы игроков в покер, отсортированные по убыванию значения?", "query": "select earnings from poker_player order by earnings desc", "predicted_sql": "select poker_player.earnings from poker_player order by poker_player.earnings desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Каковы доходы игроков в покер, отсортированные по убыванию значения? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Составь список составленных финальных столов и лучших результатов игроков в покер.", "query": "select final_table_made , best_finish from poker_player", "predicted_sql": "select poker_player.final_table_made  , poker_player.best_finish from poker_player", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Составь список составленных финальных столов и лучших результатов игроков в покер. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Каковы финальные столы и лучшие результаты для всех игроков в покер?", "query": "select final_table_made , best_finish from poker_player", "predicted_sql": "select poker_player.final_table_made  , poker_player.best_finish from poker_player", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Каковы финальные столы и лучшие результаты для всех игроков в покер? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Каков средний заработок игроков в покер?", "query": "select avg ( earnings ) from poker_player", "predicted_sql": "select avg ( earnings ) from poker_player", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Каков средний заработок игроков в покер? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Показать средний заработок по всем игрокам в покер.", "query": "select avg ( earnings ) from poker_player", "predicted_sql": "select avg ( earnings ) from poker_player", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Показать средний заработок по всем игрокам в покер. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Какой денежный ранг у игрока в покер с самым высоким заработком?", "query": "select money_rank from poker_player order by earnings desc limit 1", "predicted_sql": "select poker_player.money_rank from poker_player order by poker_player.earnings desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Какой денежный ранг у игрока в покер с самым высоким заработком? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Показать денежный ранг игрока с наибольшим заработком.", "query": "select money_rank from poker_player order by earnings desc limit 1", "predicted_sql": "select poker_player.money_rank from poker_player order by poker_player.earnings desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Показать денежный ранг игрока с наибольшим заработком. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Каково максимальное количество финальных столов среди игроков в покер с заработком менее 200000?", "query": "select max ( final_table_made ) from poker_player where earnings < 200000", "predicted_sql": "select max ( final_table_made ) from poker_player where earnings < 200000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Каково максимальное количество финальных столов среди игроков в покер с заработком менее 200000? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Показать максимальное количество финальных столов, сделанное всеми игроками в покер, чей заработок ниже 200000.", "query": "select max ( final_table_made ) from poker_player where earnings < 200000", "predicted_sql": "select max ( final_table_made ) from poker_player where earnings < 200000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Показать максимальное количество финальных столов, сделанное всеми игроками в покер, чей заработок ниже 200000. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Как зовут игроков в покер?", "query": "select people.name from people join poker_player on people.people_id = poker_player.people_id", "predicted_sql": "select people.name from poker_player join people on poker_player.people_id = people.people_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Как зовут игроков в покер? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Указать имена всех игроков в покер.", "query": "select people.name from people join poker_player on people.people_id = poker_player.people_id", "predicted_sql": "select people.name from poker_player join people on poker_player.people_id = people.people_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Указать имена всех игроков в покер. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Как зовут игроков в покер, чей заработок превышает 300000?", "query": "select people.name from people join poker_player on people.people_id = poker_player.people_id where poker_player.earnings > 300000", "predicted_sql": "select people.name from poker_player join people on poker_player.people_id = people.people_id where poker_player.earnings > 300000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Как зовут игроков в покер, чей заработок превышает 300000? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Назовите имена игроков в покер, чей заработок превышает 300000.", "query": "select people.name from people join poker_player on people.people_id = poker_player.people_id where poker_player.earnings > 300000", "predicted_sql": "select people.name from poker_player join people on poker_player.people_id = people.people_id where poker_player.earnings > 300000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Назовите имена игроков в покер, чей заработок превышает 300000. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Перечислите имена игроков в покер в порядке возрастания финальных столов.", "query": "select people.name from people join poker_player on people.people_id = poker_player.people_id order by poker_player.final_table_made asc", "predicted_sql": "select people.name from poker_player join people on poker_player.people_id = people.people_id order by poker_player.final_table_made asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Перечислите имена игроков в покер в порядке возрастания финальных столов. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Как зовутся игроки в покер в порядке возрастания по количеству проведенных ими финальных столов?", "query": "select people.name from people join poker_player on people.people_id = poker_player.people_id order by poker_player.final_table_made asc", "predicted_sql": "select people.name from poker_player join people on poker_player.people_id = people.people_id order by poker_player.final_table_made asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Как зовутся игроки в покер в порядке возрастания по количеству проведенных ими финальных столов? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Какая дата рождения игрока в покер с самым низким доходом?", "query": "select people.birth_date from people join poker_player on people.people_id = poker_player.people_id order by poker_player.earnings asc limit 1", "predicted_sql": "select people.birth_date from poker_player join people on poker_player.people_id = people.people_id order by poker_player.earnings asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Какая дата рождения игрока в покер с самым низким доходом? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Показать дату рождения игрока в покер с наименьшим заработком.", "query": "select people.birth_date from people join poker_player on people.people_id = poker_player.people_id order by poker_player.earnings asc limit 1", "predicted_sql": "select people.birth_date from poker_player join people on poker_player.people_id = people.people_id order by poker_player.earnings asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Показать дату рождения игрока в покер с наименьшим заработком. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Какой денежный ранг у самого высокого игрока в покер?", "query": "select poker_player.money_rank from people join poker_player on people.people_id = poker_player.people_id order by people.height desc limit 1", "predicted_sql": "select max ( money_rank ) from poker_player", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Какой денежный ранг у самого высокого игрока в покер? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Показать денежный ранг игрока в покер с наибольшим ростом.", "query": "select poker_player.money_rank from people join poker_player on people.people_id = poker_player.people_id order by people.height desc limit 1", "predicted_sql": "select poker_player.money_rank from poker_player join people on poker_player.people_id = people.people_id order by people.height desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Показать денежный ранг игрока в покер с наибольшим ростом. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Каков средний заработок игроков в покер ростом выше 200?", "query": "select avg ( poker_player.earnings ) from people join poker_player on people.people_id = poker_player.people_id where people.height > 200", "predicted_sql": "select avg ( poker_player.earnings ) from poker_player join people on poker_player.people_id = people.people_id where people.height > 200", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Каков средний заработок игроков в покер ростом выше 200? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Приведите средний заработок игроков в покер которые ростом выше 200.", "query": "select avg ( poker_player.earnings ) from people join poker_player on people.people_id = poker_player.people_id where people.height > 200", "predicted_sql": "select avg ( poker_player.earnings ) from poker_player join people on poker_player.people_id = people.people_id where people.height > 200", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Приведите средний заработок игроков в покер которые ростом выше 200. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Как зовут игроков в покер в порядке убывания их доходов?", "query": "select people.name from people join poker_player on people.people_id = poker_player.people_id order by poker_player.earnings desc", "predicted_sql": "select people.name from poker_player join people on poker_player.people_id = people.people_id order by poker_player.earnings desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Как зовут игроков в покер в порядке убывания их доходов? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Покажи имена игроков в покер, отсортированные по убыванию их заработка.", "query": "select people.name from people join poker_player on people.people_id = poker_player.people_id order by poker_player.earnings desc", "predicted_sql": "select people.name from poker_player join people on poker_player.people_id = people.people_id order by poker_player.earnings desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Покажи имена игроков в покер, отсортированные по убыванию их заработка. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Каковы разные национальности людей и соответствующее количество людей от каждой нации?", "query": "select nationality , count ( * ) from people group by nationality", "predicted_sql": "select people.nationality  , count ( people.people_id ) as count from people group by people.nationality", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Каковы разные национальности людей и соответствующее количество людей от каждой нации? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Сколько людей каждой национальности?", "query": "select nationality , count ( * ) from people group by nationality", "predicted_sql": "select people.nationality  , count ( * ) as count from people group by people.nationality", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Сколько людей каждой национальности? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Какая национальность у людей самая распространенная?", "query": "select nationality from people group by nationality order by count ( * ) desc limit 1", "predicted_sql": "select people.nationality from people group by people.nationality order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Какая национальность у людей самая распространенная? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Укажите национальность, которая наиболее характерна для всех людей.", "query": "select nationality from people group by nationality order by count ( * ) desc limit 1", "predicted_sql": "select people.nationality from people group by people.nationality order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Укажите национальность, которая наиболее характерна для всех людей. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Какие национальности разделяют как минимум два человека?", "query": "select nationality from people group by nationality having count ( * ) >= 2", "predicted_sql": "select distinct nationality from people group by nationality having count ( * ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Какие национальности разделяют как минимум два человека? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Показать национальности, к которым принадлежат два и более человека.", "query": "select nationality from people group by nationality having count ( * ) >= 2", "predicted_sql": "select people.nationality from people group by people.nationality having count ( * ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Показать национальности, к которым принадлежат два и более человека. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Перечислите имена и даты рождения людей в возрастающем алфавитном порядке имен.", "query": "select name , birth_date from people order by name asc", "predicted_sql": "select people.name  , people.birth_date from people order by people.name asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Перечислите имена и даты рождения людей в возрастающем алфавитном порядке имен. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Каковы имена и даты рождения людей, отсортированные по именам в алфавитном порядке?", "query": "select name , birth_date from people order by name asc", "predicted_sql": "select people.name  , people.birth_date from people order by people.name asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Каковы имена и даты рождения людей, отсортированные по именам в алфавитном порядке? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Покажите имена людей, национальность которых не «Украина».", "query": "select name from people where nationality != 'Украина'", "predicted_sql": "select people.name from people where people.nationality <> 'Украина'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Покажите имена людей, национальность которых не «Украина». \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Как зовут людей не из Украины?", "query": "select name from people where nationality != 'Украина'", "predicted_sql": "select people.name from people where people.nationality  != 'Украина'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality ( Украина ) , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Как зовут людей не из Украины? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Перечислите имена людей, не играющих в покер.", "query": "select name from people where people_id not in ( select people_id from poker_player )", "predicted_sql": "select people.name from people where people.people_id not in ( select poker_player.people_id from poker_player )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Перечислите имена людей, не играющих в покер. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Как зовут людей, которые не играют в покер?", "query": "select name from people where people_id not in ( select people_id from poker_player )", "predicted_sql": "select people.name from people where people.people_id not in ( select poker_player.people_id from poker_player )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Как зовут людей, которые не играют в покер? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Сколько существует разных национальностей?", "query": "select count ( distinct nationality ) from people", "predicted_sql": "select count ( distinct nationality ) from people", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Сколько существует разных национальностей? \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "poker_player", "question": "Подсчитай количество разных национальностей.", "query": "select count ( distinct nationality ) from people", "predicted_sql": "select count ( distinct nationality ) from people", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | poker_player : poker_player.poker_player_id , poker_player.people_id , poker_player.final_table_made , poker_player.best_finish , poker_player.money_rank , poker_player.earnings | people : people.people_id , people.nationality , people.name , people.birth_date , people.height | poker_player.people_id = people.people_id# \n ### Подсчитай количество разных национальностей. \n SELECT\n        ", "tc_original": ["poker_player.*", "poker_player.poker_player_id", "poker_player.people_id", "poker_player.final_table_made", "poker_player.best_finish", "poker_player.money_rank", "poker_player.earnings", "people.*", "people.people_id", "people.nationality", "people.name", "people.birth_date", "people.height"]}
{"db_id": "voter_1", "question": "Сколько там штатов?", "query": "select count ( * ) from area_code_state", "predicted_sql": "select count ( distinct state ) from area_code_state", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Сколько там штатов? \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Перечислить номера и имена участников в порядке убывания имен участников.", "query": "select contestant_number , contestant_name from contestants order by contestant_name desc", "predicted_sql": "select contestant_number  , contestant_name from contestants order by contestant_name desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Перечислить номера и имена участников в порядке убывания имен участников. \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Перечислите id голосов, номера телефонов и штаты всех голосов.", "query": "select vote_id , phone_number , state from votes", "predicted_sql": "select votes.vote_id  , votes.phone_number  , votes.state from votes", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Перечислите id голосов, номера телефонов и штаты всех голосов. \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Каковы максимальные и минимальные значения кодов городов?", "query": "select max ( area_code ) , min ( area_code ) from area_code_state", "predicted_sql": "select max ( area_code_state.area_code ) as max_area_code  , min ( area_code_state.area_code ) as min_area_code from area_code_state", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Каковы максимальные и минимальные значения кодов городов? \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Какова последняя дата создания голосов от штата «CA»?", "query": "select max ( created ) from votes where state = 'CA'", "predicted_sql": "select max ( created ) from votes where state = 'CA'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Какова последняя дата создания голосов от штата «CA»? \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Как зовут участников, чьи имена не «Павел Нестеров»?", "query": "select contestant_name from contestants where contestant_name != 'Павел Нестеров'", "predicted_sql": "select contestant_name from contestants where contestant_name  != 'Павел Нестеров'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Как зовут участников, чьи имена не «Павел Нестеров»? \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Каковы различные штаты и время оформления всех голосов?", "query": "select distinct state , created from votes", "predicted_sql": "select distinct state  , created from votes", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Каковы различные штаты и время оформления всех голосов? \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Каковы номера участников и имена участников, набравших не менее двух голосов?", "query": "select contestants.contestant_number , contestants.contestant_name from contestants join votes on contestants.contestant_number = votes.contestant_number group by contestants.contestant_number having count ( * ) >= 2", "predicted_sql": "select contestants.contestant_number  , contestants.contestant_name from contestants join votes on votes.contestant_number = contestants.contestant_number group by contestants.contestant_number  , contestants.contestant_name having count ( votes.vote_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Каковы номера участников и имена участников, набравших не менее двух голосов? \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Из всех проголосовавших участников, каков номер и имя участника, набравшего наименьшее количество голосов?", "query": "select contestants.contestant_number , contestants.contestant_name from contestants join votes on contestants.contestant_number = votes.contestant_number group by contestants.contestant_number order by count ( * ) asc limit 1", "predicted_sql": "select contestants.contestant_number  , contestants.contestant_name from contestants where contestants.contestant_number = ( select votes.contestant_number from votes group by votes.contestant_number order by count ( votes.vote_id ) asc limit 1 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Из всех проголосовавших участников, каков номер и имя участника, набравшего наименьшее количество голосов? \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Каково количество голосов от штата Нью-Йорк или Калифорния?", "query": "select count ( * ) from votes where state = 'NY' or state = 'CA'", "predicted_sql": "select count ( * ) from votes where state = 'New York' or state = 'California'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Каково количество голосов от штата Нью-Йорк или Калифорния? \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Сколько конкурсантов не проголосовали?", "query": "select count ( * ) from contestants where contestant_number not in ( select contestant_number from votes )", "predicted_sql": "select count ( * ) from contestants where contestant_number not in ( select contestant_number from votes )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Сколько конкурсантов не проголосовали? \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Каков код города, в котором проголосовало наибольшее количество избирателей?", "query": "select area_code_state.area_code from area_code_state join votes on area_code_state.state = votes.state group by area_code_state.area_code order by count ( * ) desc limit 1", "predicted_sql": "select area_code_state.area_code from area_code_state join votes on area_code_state.state = votes.state group by area_code_state.area_code order by count ( votes.phone_number ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Каков код города, в котором проголосовало наибольшее количество избирателей? \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Каковы даты оформления, штаты и номера телефонов при голосовании за участника по имени Матвей Гончаров?", "query": "select votes.created , votes.state , votes.phone_number from contestants join votes on contestants.contestant_number = votes.contestant_number where contestants.contestant_name = 'Матвей Гончаров'", "predicted_sql": "select votes.created  , area_code_state.state  , votes.phone_number from votes join contestants on votes.contestant_number = contestants.contestant_number join area_code_state on votes.state = area_code_state.state where contestants.contestant_name = 'Матвей Гончаров'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name ( Матвей Гончаров ) | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Каковы даты оформления, штаты и номера телефонов при голосовании за участника по имени Матвей Гончаров? \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Перечислите коды городов, в которых избиратели голосовали как за кандидатуру «Матвей Гончаров», так и за кандидатуру «Арина Филиппова».", "query": "select area_code_state.area_code from contestants join votes on contestants.contestant_number = votes.contestant_number join area_code_state on votes.state = area_code_state.state where contestants.contestant_name = 'Матвей Гончаров' intersect select area_code_state.area_code from contestants join votes on contestants.contestant_number = votes.contestant_number join area_code_state on votes.state = area_code_state.state where contestants.contestant_name = 'Арина Филиппова'", "predicted_sql": "select area_code_state.area_code from area_code_state join votes on area_code_state.state = votes.state join contestants on votes.contestant_number = contestants.contestant_number where contestants.contestant_name = 'Матвей Гончаров' and contestants.contestant_name = 'Арина Филиппова'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Перечислите коды городов, в которых избиратели голосовали как за кандидатуру «Матвей Гончаров», так и за кандидатуру «Арина Филиппова». \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "voter_1", "question": "Показать имена участников, имена которых содержат подстроку «ов».", "query": "select contestant_name from contestants where contestant_name like '%ов%'", "predicted_sql": "select contestant_name from contestants where contestant_name like '%ов%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | area_code_state : area_code_state.area_code , area_code_state.state | contestants : contestants.contestant_number , contestants.contestant_name | votes : votes.vote_id , votes.phone_number , votes.state , votes.contestant_number , votes.created | votes.contestant_number = contestants.contestant_number | votes.state = area_code_state.state# \n ### Показать имена участников, имена которых содержат подстроку «ов». \n SELECT\n        ", "tc_original": ["area_code_state.*", "area_code_state.area_code", "area_code_state.state", "contestants.*", "contestants.contestant_number", "contestants.contestant_name", "votes.*", "votes.vote_id", "votes.phone_number", "votes.state", "votes.contestant_number", "votes.created"]}
{"db_id": "world_1", "question": "What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ?", "query": "select name from country where indepyear > 1950", "predicted_sql": "select sum ( country.population ) as total_population  , avg ( country.surfacearea ) as average_area from country where country.continent = 'North America' and country.surfacearea > 3000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( North America ) , country.region ( North America ) , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### What is the total population and average area of countries in the continent of North America whose area is bigger than 3000 ? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 .", "query": "select name from country where indepyear > 1950", "predicted_sql": "select sum ( country.population ) as total_population  , avg ( country.surfacearea ) as average_surface_area from country where country.continent = 'North America' and country.surfacearea > 3000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( North America ) , country.region ( North America ) , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Give the total population and average surface area corresponding to countries in North America that have a surface area greater than 3000 . \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В скольких странах форма правления является абсолютной монархией?", "query": "select count ( * ) from country where governmentform = 'Абсолютная монархия'", "predicted_sql": "select count ( distinct country.code ) from country where country.governmentform = 'Absolute Monarchy'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В скольких странах форма правления является абсолютной монархией? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В скольких странах есть абсолютные монархические правительства?", "query": "select count ( * ) from country where governmentform = 'Абсолютная монархия'", "predicted_sql": "select count ( distinct country.name ) from country where country.governmentform = 'Absolute Monarchy'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В скольких странах есть абсолютные монархические правительства? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какова общая площадь стран Средиземного региона?", "query": "select sum ( surfacearea ) from country where region = 'Средиземье'", "predicted_sql": "select sum ( surfacearea ) from country where region = 'Mediterranean'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какова общая площадь стран Средиземного региона? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какую площадь покрывают вместе страны Средиземного бассейна?", "query": "select sum ( surfacearea ) from country where region = 'Средиземье'", "predicted_sql": "select sum ( surfacearea ) from country where continent = 'Europe' or continent = 'Africa'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какую площадь покрывают вместе страны Средиземного бассейна? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На каком континенте находится Ваканда?", "query": "select continent from country where name = 'Ваканда'", "predicted_sql": "select country.continent from country where country.name = 'Ваканда'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name ( Ваканда ) , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname ( Ваканда ) , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На каком континенте находится Ваканда? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Как называется континент, к которому принадлежит Ваканда?", "query": "select continent from country where name = 'Ваканда'", "predicted_sql": "select country.continent from country where country.name = 'Ваканда'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name ( Ваканда ) , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname ( Ваканда ) , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Как называется континент, к которому принадлежит Ваканда? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В каком регионе находится город Сайлент Хилл?", "query": "select region from country join city on country.code = city.countrycode where city.name = 'Сайлент Хилл'", "predicted_sql": "select country.region from city join country on city.countrycode = country.code where city.name = 'Сайлент Хилл'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name ( Сайлент Хилл ) , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В каком регионе находится город Сайлент Хилл? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В каком регионе находится Сайлент Хилл?", "query": "select region from country join city on country.code = city.countrycode where city.name = 'Сайлент Хилл'", "predicted_sql": "select country.region from city join country on city.countrycode = country.code where city.name = 'Сайлент Хилл'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name ( Сайлент Хилл ) , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В каком регионе находится Сайлент Хилл? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какой язык наиболее популярен в Ваканде?", "query": "select countrylanguage.language from country join countrylanguage on country.code = countrylanguage.countrycode where country.name = 'Ваканда' order by percentage desc limit 1", "predicted_sql": "select countrylanguage.language from countrylanguage where countrylanguage.countrycode = 'WAK' order by countrylanguage.percentage desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какой язык наиболее популярен в Ваканде? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На каком языке преимущественно говорят в Ваканде?", "query": "select countrylanguage.language from country join countrylanguage on country.code = countrylanguage.countrycode where country.name = 'Ваканда' order by percentage desc limit 1", "predicted_sql": "select countrylanguage.language from countrylanguage join country on countrylanguage.countrycode = country.code where country.name = 'Ваканда'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На каком языке преимущественно говорят в Ваканде? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какова численность населения и ожидаемая продолжительность жизни в Ваканде?", "query": "select population , lifeexpectancy from country where name = 'Ваканда'", "predicted_sql": "select country.population  , country.lifeexpectancy from country where country.name = 'Ваканда'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какова численность населения и ожидаемая продолжительность жизни в Ваканде? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Показать количество населения Ваканды и продолжительность жизни.", "query": "select population , lifeexpectancy from country where name = 'Ваканда'", "predicted_sql": "select country.population  , country.lifeexpectancy from country where country.name = 'Wakanda'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Показать количество населения Ваканды и продолжительность жизни. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "К какому региону относится Вальверде и какое в ней количество населения?", "query": "select population , region from country where name = 'Вальверде'", "predicted_sql": "select country.region  , city.population from country join city on city.countrycode = country.code where city.name = 'Вальверде'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name ( Вальверде ) , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname ( Вальверде ) , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### К какому региону относится Вальверде и какое в ней количество населения? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "К какому региону принадлежит Вальверде и каково ее население?", "query": "select population , region from country where name = 'Вальверде'", "predicted_sql": "select country.region  , city.population from country join city on city.countrycode = country.code where city.name = 'Вальверде'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name ( Вальверде ) , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname ( Вальверде ) , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### К какому региону принадлежит Вальверде и каково ее население? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какова средняя ожидаемая продолжительность жизни в странах региона Средиземье?", "query": "select avg ( lifeexpectancy ) from country where region = 'Средиземье'", "predicted_sql": "select avg ( country.lifeexpectancy ) from country where country.region = 'Средиземье'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region ( Средиземье ) , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какова средняя ожидаемая продолжительность жизни в странах региона Средиземье? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какая средняя продолжительность жизни в Средиземье?", "query": "select avg ( lifeexpectancy ) from country where region = 'Средиземье'", "predicted_sql": "select avg ( country.lifeexpectancy ) from country where country.region = 'Средиземье'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region ( Средиземье ) , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какая средняя продолжительность жизни в Средиземье? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Как называется страна с самой короткой продолжительностью жизни в Атлантиде?", "query": "select name from country where continent = 'Атлантида' order by lifeexpectancy asc limit 1", "predicted_sql": "select country.name from country where country.continent = 'Атлантида' order by country.lifeexpectancy asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Как называется страна с самой короткой продолжительностью жизни в Атлантиде? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Назовите страну в Атлантиде с самой низкой продолжительностью жизни.", "query": "select name from country where continent = 'Атлантида' order by lifeexpectancy asc limit 1", "predicted_sql": "select country.name from country where country.continent = 'Атлантида' order by country.lifeexpectancy asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Назовите страну в Атлантиде с самой низкой продолжительностью жизни. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какова общая численность населения и максимальный ВНП в Атлантиде?", "query": "select sum ( population ) , max ( gnp ) from country where continent = 'Атлантида'", "predicted_sql": "select sum ( country.population ) as total_population  , max ( country.gnp ) as max_gnp from country where country.continent = 'Атлантида'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какова общая численность населения и максимальный ВНП в Атлантиде? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Сколько людей живет в Атлантиде и какой у них самый большой ВНП?", "query": "select sum ( population ) , max ( gnp ) from country where continent = 'Атлантида'", "predicted_sql": "select country.population  , max ( country.gnp ) from country where country.continent = 'Атлантида'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Сколько людей живет в Атлантиде и какой у них самый большой ВНП? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какова средняя продолжительность жизни в абсолютных монархиях Атлантиды?", "query": "select avg ( lifeexpectancy ) from country where continent = 'Атлантида' and governmentform = 'Абсолютная монархия'", "predicted_sql": "select avg ( country.lifeexpectancy ) from country where country.governmentform = 'Атлантида'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какова средняя продолжительность жизни в абсолютных монархиях Атлантиды? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Приведи среднюю продолжительность жизни в странах Атлантиды, которые являются абсолютными монархиями", "query": "select avg ( lifeexpectancy ) from country where continent = 'Атлантида' and governmentform = 'Абсолютная монархия'", "predicted_sql": "select avg ( country.lifeexpectancy ) from country where country.continent = 'Атлантида' and country.governmentform = 'абсолютная монархия'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Приведи среднюю продолжительность жизни в странах Атлантиды, которые являются абсолютными монархиями \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какова общая площадь континентов Атлантида и Гиперборея?", "query": "select sum ( surfacearea ) from country where continent = 'Атлантида' or continent = 'Гиперборея'", "predicted_sql": "select sum ( surfacearea ) from country where continent = 'Атлантида' or continent = 'Гиперборея'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида , Гиперборея ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какова общая площадь континентов Атлантида и Гиперборея? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Укажите общую площадь, покрытую странами Атлантиды или Гипербореи.", "query": "select sum ( surfacearea ) from country where continent = 'Атлантида' or continent = 'Гиперборея'", "predicted_sql": "select sum ( country.surfacearea ) from country where country.continent = 'Атлантида' or country.continent = 'Гиперборея'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида , Гиперборея ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Укажите общую площадь, покрытую странами Атлантиды или Гипербореи. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Сколько человек проживает в районе Одинцовский?", "query": "select sum ( population ) from city where district = 'Одинцовский'", "predicted_sql": "select sum ( city.population ) from city where city.district = 'Одинцовский'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district ( Одинцовский ) , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Сколько человек проживает в районе Одинцовский? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какова общая численность населения Одинцовского района?", "query": "select sum ( population ) from city where district = 'Одинцовский'", "predicted_sql": "select sum ( city.population ) from city where city.district = 'Одинцовский район'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какова общая численность населения Одинцовского района? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каков средний ВНП и общая численность населения во всех странах, правительство которых смешанная республика?", "query": "select avg ( gnp ) , sum ( population ) from country where governmentform = 'Смешанная республика'", "predicted_sql": "select avg ( country.gnp ) as average_gnp  , sum ( country.population ) as total_population from country where country.governmentform = 'Смешанная республика'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform ( Смешанная республика ) , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каков средний ВНП и общая численность населения во всех странах, правительство которых смешанная республика? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Укажите средний ВНП и общую численность населения стран, считающихся смешанной республикой.", "query": "select avg ( gnp ) , sum ( population ) from country where governmentform = 'Смешанная республика'", "predicted_sql": "select avg ( country.gnp ) as average_gnp  , sum ( country.population ) as total_population from country where country.governmentform = 'Mixed Republic'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Укажите средний ВНП и общую численность населения стран, считающихся смешанной республикой. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На скольких уникальных языках говорят в мире?", "query": "select count ( distinct language ) from countrylanguage", "predicted_sql": "select count ( distinct language ) from countrylanguage", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На скольких уникальных языках говорят в мире? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какое количество различных языков используется в мире?", "query": "select count ( distinct language ) from countrylanguage", "predicted_sql": "select count ( distinct language ) from countrylanguage", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какое количество различных языков используется в мире? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Сколько типов правительств существует в Гиперборее?", "query": "select count ( distinct governmentform ) from country where continent = 'Гиперборея'", "predicted_sql": "select count ( distinct governmentform ) from country where continent = 'Гиперборея'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Гиперборея ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Сколько типов правительств существует в Гиперборее? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Сколько различных форм правления существует в Гиперборее?", "query": "select count ( distinct governmentform ) from country where continent = 'Гиперборея'", "predicted_sql": "select count ( distinct governmentform ) from country where continent = 'Гиперборея'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Гиперборея ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Сколько различных форм правления существует в Гиперборее? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какое общее количество языков используется в Ваканде?", "query": "select count ( countrylanguage.language ) from country join countrylanguage on country.code = countrylanguage.countrycode where country.name = 'Ваканда'", "predicted_sql": "select count ( distinct language ) from countrylanguage where countrycode = 'WAK'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какое общее количество языков используется в Ваканде? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На скольких языках говорят в Ваканде?", "query": "select count ( countrylanguage.language ) from country join countrylanguage on country.code = countrylanguage.countrycode where country.name = 'Ваканда'", "predicted_sql": "select count ( distinct language ) from countrylanguage where countrycode = 'WAK'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На скольких языках говорят в Ваканде? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Сколько официальных языков в Нордхейме?", "query": "select count ( * ) from country join countrylanguage on country.code = countrylanguage.countrycode where country.name = 'Нордхейм' and isofficial = 'T'", "predicted_sql": "select count ( countrylanguage.language ) from countrylanguage where countrylanguage.countrycode = 'NOR' and countrylanguage.isofficial = 'T'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Сколько официальных языков в Нордхейме? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На скольких официальных языках говорят в Нордхейме?", "query": "select count ( * ) from country join countrylanguage on country.code = countrylanguage.countrycode where country.name = 'Нордхейм' and isofficial = 'T'", "predicted_sql": "select count ( countrylanguage.language ) from countrylanguage join city on city.countrycode = countrylanguage.countrycode where city.name = 'Nordheim' and countrylanguage.isofficial = 'T'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На скольких официальных языках говорят в Нордхейме? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Как называется страна, говорящая на наибольшем количестве языков?", "query": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode group by country.name order by count ( * ) desc limit 1", "predicted_sql": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode group by country.name order by count ( countrylanguage.language ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Как называется страна, говорящая на наибольшем количестве языков? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Укажи название нации, которая использует наибольшее количество языков.", "query": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode group by country.name order by count ( * ) desc limit 1", "predicted_sql": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode group by country.name order by count ( countrylanguage.language ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Укажи название нации, которая использует наибольшее количество языков. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На каком континенте самые разные языки?", "query": "select country.continent from country join countrylanguage on country.code = countrylanguage.countrycode group by country.continent order by count ( * ) desc limit 1", "predicted_sql": "select country.continent from countrylanguage join country on countrylanguage.countrycode = country.code group by country.continent order by count ( distinct countrylanguage.language ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На каком континенте самые разные языки? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На каком континенте больше всего языков?", "query": "select country.continent from country join countrylanguage on country.code = countrylanguage.countrycode group by country.continent order by count ( * ) desc limit 1", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На каком континенте больше всего языков? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Сколько стран говорят на вакандийском и нордовском языках?", "query": "select count ( * ) from ( select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' intersect select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Нордовский' )", "predicted_sql": "select count ( distinct countrylanguage.countrycode ) from countrylanguage where countrylanguage.language in ( 'вакандийский'  , 'нордовский' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Сколько стран говорят на вакандийском и нордовском языках? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Сколько стран используют вакандийский и нордовский языки?", "query": "select count ( * ) from ( select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' intersect select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Нордовский' )", "predicted_sql": "select count ( distinct countrylanguage.countrycode ) from countrylanguage where countrylanguage.language in ( 'Вакандийский'  , 'Нордовский' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Вакандийский , Нордовский ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Сколько стран используют вакандийский и нордовский языки? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Как называются народы, говорящие на вакандийском и дженоши языках?", "query": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' intersect select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Дженоши'", "predicted_sql": "select country.name from countrylanguage join country on countrylanguage.countrycode = country.code where countrylanguage.language = 'вакандийский' or countrylanguage.language = 'дженоши'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Дженоши ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Как называются народы, говорящие на вакандийском и дженоши языках? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Назовите страны, говорящие на вакандийском и дженоши языках.", "query": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' intersect select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Дженоши'", "predicted_sql": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'вакандийский' and countrylanguage.language = 'дженоши'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Дженоши ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Назовите страны, говорящие на вакандийском и дженоши языках. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Как называются страны, в которых вакандийский и дженоши являются официальными языками?", "query": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' and countrylanguage.isofficial = 'T' intersect select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Дженоши' and countrylanguage.isofficial = 'T'", "predicted_sql": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' and countrylanguage.isofficial = 1 and countrylanguage.language = 'Дженоши' and countrylanguage.isofficial = 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Вакандийский , Дженоши ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Как называются страны, в которых вакандийский и дженоши являются официальными языками? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Назовите страны, официальными языками которых являются вакандийский и дженоши.", "query": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' and countrylanguage.isofficial = 'T' intersect select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Дженоши' and countrylanguage.isofficial = 'T'", "predicted_sql": "select country.name from country join countrylanguage on countrylanguage.countrycode = country.code where countrylanguage.language = 'Вакандийский' and countrylanguage.isofficial = 'T' and countrylanguage.language = 'Дженоши' and countrylanguage.isofficial = 'T'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Вакандийский , Дженоши ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Назовите страны, официальными языками которых являются вакандийский и дженоши. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На каком количестве разных континентов говорят по-клингонски?", "query": "select count ( distinct continent ) from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Клингонский'", "predicted_sql": "select count ( distinct country.continent ) from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Klingon'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На каком количестве разных континентов говорят по-клингонски? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На скольких континентах говорят по-клингонски?", "query": "select count ( distinct continent ) from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Клингонский'", "predicted_sql": "select count ( distinct country.continent ) from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Klingon'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На скольких континентах говорят по-клингонски? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В каких регионах используется вакандийский или нордовский язык?", "query": "select distinct country.region from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' or countrylanguage.language = 'Нордовский'", "predicted_sql": "select country.region from countrylanguage join country on countrylanguage.countrycode = country.code where countrylanguage.language = 'Вакандийский' or countrylanguage.language = 'Нордовский'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Вакандийский , Нордовский ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В каких регионах используется вакандийский или нордовский язык? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В каких регионах говорят на нордовском или вакандийском?", "query": "select distinct country.region from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' or countrylanguage.language = 'Нордовский'", "predicted_sql": "select country.region from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'нордовский' or countrylanguage.language = 'вакандийский'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В каких регионах говорят на нордовском или вакандийском? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В каких странах вакандийский или нордовский язык является официальным языком?", "query": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' and isofficial = 'T' union select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Нордовский' and isofficial = 'T'", "predicted_sql": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' or countrylanguage.language = 'Нордовский' and countrylanguage.isofficial = 'T'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Вакандийский , Нордовский ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В каких странах вакандийский или нордовский язык является официальным языком? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В каких странах вакандийский или нордовский является официальным языком?", "query": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' and isofficial = 'T' union select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Нордовский' and isofficial = 'T'", "predicted_sql": "select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' or countrylanguage.language = 'Нордовский' and countrylanguage.isofficial = 'T'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Вакандийский , Нордовский ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В каких странах вакандийский или нордовский является официальным языком? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какой язык самый популярный на континенте Атлантиды?", "query": "select countrylanguage.language from country join countrylanguage on country.code = countrylanguage.countrycode where country.continent = 'Атлантида' group by countrylanguage.language order by count ( * ) desc limit 1", "predicted_sql": "select countrylanguage.language from countrylanguage join country on countrylanguage.countrycode = country.code where country.continent = 'Атлантида' order by countrylanguage.percentage desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какой язык самый популярный на континенте Атлантиды? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какой язык используется большинством народов Атлантиды?", "query": "select countrylanguage.language from country join countrylanguage on country.code = countrylanguage.countrycode where country.continent = 'Атлантида' group by countrylanguage.language order by count ( * ) desc limit 1", "predicted_sql": "select countrylanguage.language from countrylanguage join country on countrylanguage.countrycode = country.code where country.continent = 'Атлантида' group by countrylanguage.language order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какой язык используется большинством народов Атлантиды? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На каких языках говорит только одна страна с абсолютной монархией?", "query": "select countrylanguage.language from country join countrylanguage on country.code = countrylanguage.countrycode where country.governmentform = 'Абсолютная монархия' group by countrylanguage.language having count ( * ) = 1", "predicted_sql": "select countrylanguage.language from countrylanguage join country on countrylanguage.countrycode = country.code where country.governmentform = 'Absolute Monarchy' group by countrylanguage.language having count ( distinct countrylanguage.countrycode ) = 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На каких языках говорит только одна страна с абсолютной монархией? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какие языки используются только в одной стране с абсолютным монархическим правительством?", "query": "select countrylanguage.language from country join countrylanguage on country.code = countrylanguage.countrycode where country.governmentform = 'Абсолютная монархия' group by countrylanguage.language having count ( * ) = 1", "predicted_sql": "select countrylanguage.language from countrylanguage join country on countrylanguage.countrycode = country.code where country.governmentform = 'Absolute Monarchy' group by countrylanguage.language having count ( distinct countrylanguage.countrycode ) = 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какие языки используются только в одной стране с абсолютным монархическим правительством? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Найдите город с самым большим населением, использующим вакандийский язык.", "query": "select city.name , city.population from city join countrylanguage on city.countrycode = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' order by city.population desc limit 1", "predicted_sql": "select city.name from city join countrylanguage on city.countrycode = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' order by city.population desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Вакандийский ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Найдите город с самым большим населением, использующим вакандийский язык. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В каком городе с наибольшим населением говорят по-вакандийски?", "query": "select city.name , city.population from city join countrylanguage on city.countrycode = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' order by city.population desc limit 1", "predicted_sql": "select city.name from city join countrylanguage on city.countrycode = countrylanguage.countrycode where countrylanguage.language = 'вакандийский' order by city.population desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В каком городе с наибольшим населением говорят по-вакандийски? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Найдите название, население и ожидаемую продолжительность жизни страны в Атлантиде с самой большой площадью?", "query": "select name , population , lifeexpectancy from country where continent = 'Атлантида' order by surfacearea desc limit 1", "predicted_sql": "select country.name  , country.population  , country.lifeexpectancy from country where country.continent = 'Атлантида' order by country.surfacearea desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Найдите название, население и ожидаемую продолжительность жизни страны в Атлантиде с самой большой площадью? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каково название, население и продолжительность жизни самой большой по территории суши страны в Атлантиде?", "query": "select name , population , lifeexpectancy from country where continent = 'Атлантида' order by surfacearea desc limit 1", "predicted_sql": "select country.name  , country.population  , country.lifeexpectancy from country where country.continent = 'Атлантида' order by country.surfacearea desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каково название, население и продолжительность жизни самой большой по территории суши страны в Атлантиде? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какова средняя продолжительность жизни в странах, где вакандийский не является официальным языком?", "query": "select avg ( lifeexpectancy ) from country where name not in ( select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' and countrylanguage.isofficial = 'T' )", "predicted_sql": "select avg ( country.lifeexpectancy ) from country where country.code not in ( select countrylanguage.countrycode from countrylanguage where countrylanguage.language = 'Вакандийский' and countrylanguage.isofficial = 'T' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Вакандийский ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какова средняя продолжительность жизни в странах, где вакандийский не является официальным языком? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Приведите среднюю продолжительность жизни в странах, в которых вакандийский не является официальным языком.", "query": "select avg ( lifeexpectancy ) from country where name not in ( select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' and countrylanguage.isofficial = 'T' )", "predicted_sql": "select avg ( country.lifeexpectancy ) from country where country.code not in ( select countrylanguage.countrycode from countrylanguage where countrylanguage.language = 'Вакандийский' and countrylanguage.isofficial = 'T' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Вакандийский ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Приведите среднюю продолжительность жизни в странах, в которых вакандийский не является официальным языком. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каково общее количество людей, проживающих в странах, не использующих вакандийский язык?", "query": "select sum ( population ) from country where name not in ( select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' )", "predicted_sql": "select sum ( country.population ) from country where country.code not in ( select countrylanguage.countrycode from countrylanguage where countrylanguage.language = 'Вакандийский' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Вакандийский ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каково общее количество людей, проживающих в странах, не использующих вакандийский язык? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Сколько людей живет в странах, где не говорят по-вакандийски?", "query": "select sum ( population ) from country where name not in ( select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'Вакандийский' )", "predicted_sql": "select sum ( country.population ) from country where country.code not in ( select countrylanguage.countrycode from countrylanguage where countrylanguage.language = 'вакандийский' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Сколько людей живет в странах, где не говорят по-вакандийски? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На каком официальном языке говорят в стране, главой государства которой является Ангела?", "query": "select countrylanguage.language from country join countrylanguage on country.code = countrylanguage.countrycode where country.headofstate = 'Ангела' and countrylanguage.isofficial = 'T'", "predicted_sql": "select countrylanguage.language from countrylanguage join country on countrylanguage.countrycode = country.code where country.headofstate = 'Ангела'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate ( Ангела ) , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На каком официальном языке говорят в стране, главой государства которой является Ангела? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какой официальный язык используется в стране, главу государства которой зовут Ангела?", "query": "select countrylanguage.language from country join countrylanguage on country.code = countrylanguage.countrycode where country.headofstate = 'Ангела' and countrylanguage.isofficial = 'T'", "predicted_sql": "select countrylanguage.language from countrylanguage join country on countrylanguage.countrycode = country.code where country.headofstate = 'Ангела'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate ( Ангела ) , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какой официальный язык используется в стране, главу государства которой зовут Ангела? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каково общее количество уникальных официальных языков, на которых говорят в странах, основанных до 1930 года?", "query": "select count ( distinct countrylanguage.language ) from country join countrylanguage on country.code = countrylanguage.countrycode where indepyear < 1930 and countrylanguage.isofficial = 'T'", "predicted_sql": "select count ( distinct countrylanguage.language ) from countrylanguage join country on countrylanguage.countrycode = country.code where country.indepyear < 1930 and countrylanguage.isofficial = 'T'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каково общее количество уникальных официальных языков, на которых говорят в странах, основанных до 1930 года? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каково общее количество различных официальных языков в странах, основанных до 1930 года?", "query": "select count ( distinct countrylanguage.language ) from country join countrylanguage on country.code = countrylanguage.countrycode where indepyear < 1930 and countrylanguage.isofficial = 'T'", "predicted_sql": "select count ( distinct countrylanguage.language ) from countrylanguage join country on countrylanguage.countrycode = country.code where country.indepyear < 1930 and countrylanguage.isofficial = 'T'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каково общее количество различных официальных языков в странах, основанных до 1930 года? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какие страны имеют большую площадь, чем любая страна в Лемурии?", "query": "select name from country where surfacearea > ( select min ( surfacearea ) from country where continent = 'Лемурия' )", "predicted_sql": "select country.name from country where country.surfacearea > ( select max ( surfacearea ) from country where country.continent = 'Лемурия' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Лемурия ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какие страны имеют большую площадь, чем любая страна в Лемурии? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какие страны имеют большую площадь, чем у любой страны Лемурии?", "query": "select name from country where surfacearea > ( select min ( surfacearea ) from country where continent = 'Лемурия' )", "predicted_sql": "select country.name from country where country.surfacearea > ( select max ( surfacearea ) from country where continent = 'Лемурия' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Лемурия ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какие страны имеют большую площадь, чем у любой страны Лемурии? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В каких гиперборейских странах проживает меньше людей, чем в любой стране Атлантиды?", "query": "select name from country where continent = 'Гиперборея' and population < ( select max ( population ) from country where continent = 'Атлантида' )", "predicted_sql": "select country.name from country where country.continent = 'Атлантида' and country.population > ( select min ( country.population ) from country where country.continent = 'Гиперборея' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В каких гиперборейских странах проживает меньше людей, чем в любой стране Атлантиды? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В каких гиперборейских странах проживает меньше населения, чем в любой стране Атлантиды?", "query": "select name from country where continent = 'Гиперборея' and population < ( select max ( population ) from country where continent = 'Атлантида' )", "predicted_sql": "select country.name from country where country.continent = 'Гиперборея' and country.population < ( select min ( country.population ) from country where country.continent = 'Атлантида' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В каких гиперборейских странах проживает меньше населения, чем в любой стране Атлантиды? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Население каких стран Атлантиды больше, чем в любой стране Гипербореи?", "query": "select name from country where continent = 'Атлантида' and population > ( select max ( population ) from country where continent = 'Гиперборея' )", "predicted_sql": "select country.name from country where country.continent = 'Атлантида' and country.population > ( select max ( country.population ) from country where country.continent = 'Гиперборея' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида , Гиперборея ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Население каких стран Атлантиды больше, чем в любой стране Гипербореи? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В каких странах Атлантиды проживает больше людей, чем в любой другой стране Гипербореи?", "query": "select name from country where continent = 'Атлантида' and population > ( select max ( population ) from country where continent = 'Гиперборея' )", "predicted_sql": "select country.name from country where country.continent = 'Атлантида' and country.population > ( select max ( country.population ) from country where country.continent = 'Гиперборея' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида , Гиперборея ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В каких странах Атлантиды проживает больше людей, чем в любой другой стране Гипербореи? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какие коды стран у стран, в которых не говорят по-вакандийски?", "query": "select countrycode from countrylanguage except select countrycode from countrylanguage where language = 'Вакандийский'", "predicted_sql": "select country.code from country where country.code not in ( select countrylanguage.countrycode from countrylanguage where countrylanguage.language = 'вакандийский' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какие коды стран у стран, в которых не говорят по-вакандийски? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Покажи коды стран для стран, в которых не говорят по-вакандийски.", "query": "select countrycode from countrylanguage except select countrycode from countrylanguage where language = 'Вакандийский'", "predicted_sql": "select country.code from country where country.code not in ( select countrylanguage.countrycode from countrylanguage where countrylanguage.language = 'вакандийский' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Покажи коды стран для стран, в которых не говорят по-вакандийски. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каковы коды стран, в которых люди используют другие языки, кроме вакандийского?", "query": "select distinct countrycode from countrylanguage where language != 'Вакандийский'", "predicted_sql": "select country.code from country where country.code not in ( select countrylanguage.countrycode from countrylanguage where countrylanguage.language = 'вакандийский' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каковы коды стран, в которых люди используют другие языки, кроме вакандийского? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Укажите коды стран для стран, в которых люди говорят не на вакандийском языке.", "query": "select distinct countrycode from countrylanguage where language != 'Вакандийский'", "predicted_sql": "select country.code from country where country.code not in ( select countrylanguage.countrycode from countrylanguage where countrylanguage.language = 'вакандийский' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Укажите коды стран для стран, в которых люди говорят не на вакандийском языке. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каковы коды стран, которые не говорят по-вакандийски и чьи государственные формы не являются абсолютными монархиями?", "query": "select code from country where governmentform != 'Абсолютная монархия' except select countrycode from countrylanguage where language = 'Вакандийский'", "predicted_sql": "select country.code from country left join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language  != 'вакандийский' and country.governmentform  != 'абсолютная монархия'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каковы коды стран, которые не говорят по-вакандийски и чьи государственные формы не являются абсолютными монархиями? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Показать коды стран, в которых не говорят по-вакандийски и чья форма правительства не абсолютная монархия.", "query": "select code from country where governmentform != 'Абсолютная монархия' except select countrycode from countrylanguage where language = 'Вакандийский'", "predicted_sql": "select country.code from country left join countrylanguage on countrylanguage.countrycode = country.code where countrylanguage.language <> 'вакандийски' and country.governmentform <> 'Абсолютная монархия'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform ( Абсолютная монархия ) , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Показать коды стран, в которых не говорят по-вакандийски и чья форма правительства не абсолютная монархия. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "В каких городах гиперборейских стран вакандийский не является официальным языком?", "query": "select distinct city.name from country join city on city.countrycode = country.code where country.continent = 'Гиперборея' and country.name not in ( select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.isofficial = 'T' and countrylanguage.language = 'Вакандийский' )", "predicted_sql": "select city.name from city join country on city.countrycode = country.code join countrylanguage on countrylanguage.countrycode = country.code where country.continent = 'Hyperborea' and countrylanguage.language = 'Вакандийский' and countrylanguage.isofficial = 'No'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Вакандийский ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### В каких городах гиперборейских стран вакандийский не является официальным языком? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Как называются города в Гиперборее, для которых вакандийский не является официальным языком?", "query": "select distinct city.name from country join city on city.countrycode = country.code where country.continent = 'Гиперборея' and country.name not in ( select country.name from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.isofficial = 'T' and countrylanguage.language = 'Вакандийский' )", "predicted_sql": "select city.name from city join country on city.countrycode = country.code join countrylanguage on countrylanguage.countrycode = country.code where country.continent = 'Гиперборея' and countrylanguage.language <> 'Вакандийский' and countrylanguage.isofficial = 0", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Гиперборея ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Вакандийский ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Как называются города в Гиперборее, для которых вакандийский не является официальным языком? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какие уникальные города находятся в странах Атлантиды, где клингонский язык является официальным языком?", "query": "select distinct city.name from country join countrylanguage on country.code = countrylanguage.countrycode join city on country.code = city.countrycode where countrylanguage.isofficial = 'T' and countrylanguage.language = 'Клингонский' and country.continent = 'Атлантида'", "predicted_sql": "select city.name from city join country on city.countrycode = country.code join countrylanguage on countrylanguage.countrycode = country.code where country.continent = 'Атлантида' and countrylanguage.language = 'Клингонский' and countrylanguage.isofficial = 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Клингонский ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какие уникальные города находятся в странах Атлантиды, где клингонский язык является официальным языком? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Верните разные названия городов в Атлантиде, для которых клингонский является официальным языком.", "query": "select distinct city.name from country join countrylanguage on country.code = countrylanguage.countrycode join city on country.code = city.countrycode where countrylanguage.isofficial = 'T' and countrylanguage.language = 'Клингонский' and country.continent = 'Атлантида'", "predicted_sql": "select distinct city.name from city join country on city.countrycode = country.code join countrylanguage on countrylanguage.countrycode = country.code where country.continent = 'Атлантида' and countrylanguage.language = 'Клингонский' and countrylanguage.isofficial = 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Клингонский ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Верните разные названия городов в Атлантиде, для которых клингонский является официальным языком. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Название, год независимости и площадь страны с наименьшим населением", "query": "select name , surfacearea , indepyear from country order by population asc limit 1", "predicted_sql": "select country.name  , country.indepyear  , country.surfacearea from country order by country.population asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Название, год независимости и площадь страны с наименьшим населением \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Укажите название, год независимости и площадь страны с наименьшим населением.", "query": "select name , surfacearea , indepyear from country order by population asc limit 1", "predicted_sql": "select country.name  , country.indepyear  , country.surfacearea from country order by country.population asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Укажите название, год независимости и площадь страны с наименьшим населением. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каково население, название и лидер страны с самой большой площадью?", "query": "select name , population , headofstate from country order by surfacearea desc limit 1", "predicted_sql": "select country.population  , country.name  , country.headofstate from country order by country.surfacearea desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каково население, название и лидер страны с самой большой площадью? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Укажите название, численность населения и главу государства для страны с самой большой площадью.", "query": "select name , population , headofstate from country order by surfacearea desc limit 1", "predicted_sql": "select country.name  , country.population  , country.headofstate from country where country.surfacearea = ( select max ( surfacearea ) from country )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Укажите название, численность населения и главу государства для страны с самой большой площадью. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Показать название страны и количество языков для каждой страны, в которой говорят как минимум на 3 языках.", "query": "select count ( countrylanguage.language ) , country.name from country join countrylanguage on country.code = countrylanguage.countrycode group by country.name having count ( * ) > 2", "predicted_sql": "select country.name  , count ( countrylanguage.language ) as language_count from country join countrylanguage on country.code = countrylanguage.countrycode group by country.name having count ( countrylanguage.language ) >= 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Показать название страны и количество языков для каждой страны, в которой говорят как минимум на 3 языках. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Как называются страны, в которых говорят более чем на 2 языках, а также на скольких языках они говорят?", "query": "select count ( countrylanguage.language ) , country.name from country join countrylanguage on country.code = countrylanguage.countrycode group by country.name having count ( * ) > 2", "predicted_sql": "select country.name  , count ( distinct countrylanguage.language ) as num_languages from country join countrylanguage on country.code = countrylanguage.countrycode group by country.name having count ( distinct countrylanguage.language ) > 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Как называются страны, в которых говорят более чем на 2 языках, а также на скольких языках они говорят? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Найдите количество городов в каждом районе, население которых превышает среднюю численность населения городов", "query": "select count ( * ) , district from city where population > ( select avg ( population ) from city ) group by district", "predicted_sql": "select city.district  , count ( city.id ) as city_count from city where city.population > ( select avg ( population ) from city ) group by city.district", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Найдите количество городов в каждом районе, население которых превышает среднюю численность населения городов \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Сколько городов в каждом районе имеют население выше среднего по всем городам?", "query": "select count ( * ) , district from city where population > ( select avg ( population ) from city ) group by district", "predicted_sql": "select city.district  , count ( city.name ) as num_cities from city where city.population > ( select avg ( population ) from city ) group by city.district", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Сколько городов в каждом районе имеют население выше среднего по всем городам? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Найдите название формы правления и общую численность населения для каждой формы правления, средняя продолжительность жизни при которой превышает 72 года.", "query": "select sum ( population ) , governmentform from country group by governmentform having avg ( lifeexpectancy ) > 72", "predicted_sql": "select country.governmentform  , sum ( country.population ) from country where country.lifeexpectancy > 72 group by country.governmentform", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Найдите название формы правления и общую численность населения для каждой формы правления, средняя продолжительность жизни при которой превышает 72 года. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каковы различные формы правления и какова общая численность населения каждой из форм правления, средняя продолжительность жизни при которых превышает 72 года?", "query": "select sum ( population ) , governmentform from country group by governmentform having avg ( lifeexpectancy ) > 72", "predicted_sql": "select country.governmentform  , sum ( country.population ) as total_population from country where country.lifeexpectancy > 72 group by country.governmentform", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каковы различные формы правления и какова общая численность населения каждой из форм правления, средняя продолжительность жизни при которых превышает 72 года? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Найдите среднюю продолжительность жизни и общую численность населения для каждого континента, где средняя продолжительность жизни меньше 72", "query": "select sum ( population ) , avg ( lifeexpectancy ) , continent from country group by continent having avg ( lifeexpectancy ) < 72", "predicted_sql": "select country.continent  , avg ( country.lifeexpectancy ) as average_life_expectancy  , sum ( country.population ) as total_population from country where country.lifeexpectancy < 72 group by country.continent", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Найдите среднюю продолжительность жизни и общую численность населения для каждого континента, где средняя продолжительность жизни меньше 72 \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каковы различные континенты, общая численность населения и средняя продолжительность жизни, соответствующие каждому из континентов, средняя продолжительность жизни которых менее 72?", "query": "select sum ( population ) , avg ( lifeexpectancy ) , continent from country group by continent having avg ( lifeexpectancy ) < 72", "predicted_sql": "select country.continent  , sum ( country.population ) as total_population  , avg ( country.lifeexpectancy ) as average_life_expectancy from country where country.lifeexpectancy < 72 group by country.continent", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каковы различные континенты, общая численность населения и средняя продолжительность жизни, соответствующие каждому из континентов, средняя продолжительность жизни которых менее 72? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Как называются страны, входящие в пятерку крупнейших по площади, и каковы их территории?", "query": "select name , surfacearea from country order by surfacearea desc limit 5", "predicted_sql": "select country.name  , country.surfacearea from country order by country.surfacearea desc limit 5", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Как называются страны, входящие в пятерку крупнейших по площади, и каковы их территории? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Отображать имена и площади 5 крупнейших стран.", "query": "select name , surfacearea from country order by surfacearea desc limit 5", "predicted_sql": "select country.name  , country.surfacearea from country order by country.surfacearea desc limit 5", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Отображать имена и площади 5 крупнейших стран. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Как называются страны с топ-3 по численности населения?", "query": "select name from country order by population desc limit 3", "predicted_sql": "select country.name from country order by country.population desc limit 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Как называются страны с топ-3 по численности населения? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Показывать названия 3-х самых густонаселенных стран.", "query": "select name from country order by population desc limit 3", "predicted_sql": "select country.name from country order by country.population desc limit 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Показывать названия 3-х самых густонаселенных стран. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Как называются народы с 3 наименьшим количеством населения?", "query": "select name from country order by population asc limit 3", "predicted_sql": "select country.name from country order by country.population asc limit 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Как называются народы с 3 наименьшим количеством населения? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Показать названия 3 стран с наименьшим количеством людей.", "query": "select name from country order by population asc limit 3", "predicted_sql": "select country.name from country order by country.population asc limit 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Показать названия 3 стран с наименьшим количеством людей. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Сколько стран в Атлантиде?", "query": "select count ( * ) from country where continent = 'Атлантида'", "predicted_sql": "select count ( * ) from country where continent = 'Атлантида'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Сколько стран в Атлантиде? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Подсчитайте количество стран в Атлантиде.", "query": "select count ( * ) from country where continent = 'Атлантида'", "predicted_sql": "select count ( * ) from country where continent = 'Атлантида'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Подсчитайте количество стран в Атлантиде. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Как называются страны лемурийского континента с населением 80000 человек?", "query": "select name from country where continent = 'Лемурия' and population = '80000'", "predicted_sql": "select country.name from country where country.continent = 'Lemuria' and country.population = 80000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Как называются страны лемурийского континента с населением 80000 человек? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Назовите страны Лемурии с населением 80000 человек.", "query": "select name from country where continent = 'Лемурия' and population = '80000'", "predicted_sql": "select country.name from country where country.continent = 'Лемурия' and country.population = 80000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Лемурия ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Назовите страны Лемурии с населением 80000 человек. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какова общая численность населения и средняя площадь стран на континенте Атлантида, площадь которых превышает 3000?", "query": "select sum ( population ) , avg ( surfacearea ) from country where continent = 'Атлантида' and surfacearea > 3000", "predicted_sql": "select sum ( country.population ) as total_population  , avg ( country.surfacearea ) as average_area from country where country.continent = 'Атлантида' and country.surfacearea > 3000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какова общая численность населения и средняя площадь стран на континенте Атлантида, площадь которых превышает 3000? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Приведи общую численность населения и среднюю площадь в соответствии со странами Атлантиды с площадью более 3000.", "query": "select sum ( population ) , avg ( surfacearea ) from country where continent = 'Атлантида' and surfacearea > 3000", "predicted_sql": "select country.name  , sum ( country.population ) as total_population  , avg ( country.surfacearea ) as average_surfacearea from country where country.continent = 'Атлантида' and country.surfacearea > 3000 group by country.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent ( Атлантида ) , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Приведи общую численность населения и среднюю площадь в соответствии со странами Атлантиды с площадью более 3000. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Какие города с населением от 160000 до 900000?", "query": "select name from city where population between 160000 and 900000", "predicted_sql": "select city.name from city where city.population between 160000 and 900000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Какие города с населением от 160000 до 900000? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Показать названия городов с населением от 160000 до 900000 человек.", "query": "select name from city where population between 160000 and 900000", "predicted_sql": "select city.name from city where city.population between 160000 and 900000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Показать названия городов с населением от 160000 до 900000 человек. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На каком языке говорит наибольшее количество стран?", "query": "select language from countrylanguage group by language order by count ( * ) desc limit 1", "predicted_sql": "select countrylanguage.language from countrylanguage group by countrylanguage.language order by count ( countrylanguage.countrycode ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На каком языке говорит наибольшее количество стран? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Назовите язык, на котором говорят в большинстве стран.", "query": "select language from countrylanguage group by language order by count ( * ) desc limit 1", "predicted_sql": "select countrylanguage.language from countrylanguage group by countrylanguage.language having count ( distinct countrylanguage.countrycode ) = ( select count ( distinct country.code ) from country )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Назовите язык, на котором говорят в большинстве стран. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "На каком языке говорит самый большой процент людей в каждой стране?", "query": "select language , countrycode , max ( percentage ) from countrylanguage group by countrycode", "predicted_sql": "select country.name  , countrylanguage.language from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.percentage = ( select max ( percentage ) from countrylanguage where countrylanguage.countrycode = country.code )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### На каком языке говорит самый большой процент людей в каждой стране? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каковы коды стран в разных странах и на каких языках говорит наибольший процент людей в каждой из них?", "query": "select language , countrycode , max ( percentage ) from countrylanguage group by countrycode", "predicted_sql": "select country.code  , countrylanguage.language from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.percentage = ( select max ( percentage ) from countrylanguage where countrylanguage.countrycode = country.code ) group by country.code", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каковы коды стран в разных странах и на каких языках говорит наибольший процент людей в каждой из них? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каково общее количество стран, в которых на новоязском языке говорит наибольший процент людей?", "query": "select count ( * ) , max ( percentage ) from countrylanguage where language = 'Новояз' group by countrycode", "predicted_sql": "select count ( distinct countrylanguage.countrycode ) from countrylanguage where countrylanguage.language = 'новоязский' and countrylanguage.percentage = ( select max ( countrylanguage.percentage ) from countrylanguage where countrylanguage.language = 'новоязский' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каково общее количество стран, в которых на новоязском языке говорит наибольший процент людей? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Подсчитайте количество стран, в которых новоязский является основным используемым языком.", "query": "select count ( * ) , max ( percentage ) from countrylanguage where language = 'Новояз' group by countrycode", "predicted_sql": "select count ( distinct country.code ) from country join countrylanguage on country.code = countrylanguage.countrycode where countrylanguage.language = 'новоязский' and countrylanguage.isofficial = 'T'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Подсчитайте количество стран, в которых новоязский является основным используемым языком. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каковы коды стран, в которых на новоязском языке говорит самый большой процент людей?", "query": "select countrycode , max ( percentage ) from countrylanguage where language = 'Новояз' group by countrycode", "predicted_sql": "select countrylanguage.countrycode from countrylanguage where countrylanguage.language = 'новоязский' order by countrylanguage.percentage desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каковы коды стран, в которых на новоязском языке говорит самый большой процент людей? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Показать коды стран, для которых новояз является основным языком.", "query": "select countrycode , max ( percentage ) from countrylanguage where language = 'Новояз' group by countrycode", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language ( Новояз ) , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Показать коды стран, для которых новояз является основным языком. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "orchestra", "question": "Сколько здесь дирижеров?", "query": "select count ( * ) from conductor", "predicted_sql": "select count ( conductor.conductor_id ) from conductor", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Сколько здесь дирижеров? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Подсчитайте количество дирижеров.", "query": "select count ( * ) from conductor", "predicted_sql": "select count ( conductor_id ) from conductor", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Подсчитайте количество дирижеров. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Перечислите имена дирижеров в порядке возрастания их возраста.", "query": "select name from conductor order by age asc", "predicted_sql": "select conductor.name from conductor order by conductor.age asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Перечислите имена дирижеров в порядке возрастания их возраста. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Как зовут дирижеров по возрасту?", "query": "select name from conductor order by age asc", "predicted_sql": "select conductor.name from conductor order by conductor.age asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Как зовут дирижеров по возрасту? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Как зовут дирижеров, чья национальность не «Россия»?", "query": "select name from conductor where nationality != 'Россия'", "predicted_sql": "select conductor.name from conductor where conductor.nationality <> 'Россия'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Как зовут дирижеров, чья национальность не «Россия»? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Укажите имена дирижеров, не имеющих национальности «Россия».", "query": "select name from conductor where nationality != 'Россия'", "predicted_sql": "select conductor.name from conductor where conductor.nationality <> 'Россия'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Укажите имена дирижеров, не имеющих национальности «Россия». \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Каковы звукозаписывающие компании оркестров в порядке убывания года их основания?", "query": "select record_company from orchestra order by year_of_founded desc", "predicted_sql": "select orchestra.record_company from orchestra order by orchestra.year_of_founded desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Каковы звукозаписывающие компании оркестров в порядке убывания года их основания? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Показать звукозаписывающие компании оркестров, отсортированные по годам их основания.", "query": "select record_company from orchestra order by year_of_founded desc", "predicted_sql": "select orchestra.record_company from orchestra order by orchestra.year_of_founded asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Показать звукозаписывающие компании оркестров, отсортированные по годам их основания. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Какова средняя посещаемость шоу?", "query": "select avg ( attendance ) from show", "predicted_sql": "select avg ( attendance ) from show", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Какова средняя посещаемость шоу? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Показать среднюю посещаемость по всем шоу.", "query": "select avg ( attendance ) from show", "predicted_sql": "select avg ( attendance ) from show", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Показать среднюю посещаемость по всем шоу. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Какова максимальная и минимальная доля выступлений, тип которых не является предоказом.", "query": "select max ( share ) , min ( share ) from performance where type != 'Предпоказ'", "predicted_sql": "select max ( performance.share ) as max_share  , min ( performance.share ) as min_share from performance where performance.type <> 'premiere'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Какова максимальная и минимальная доля выступлений, тип которых не является предоказом. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Показать максимальную и минимальную долю выступлений, не имеющих типа «предпоказ».", "query": "select max ( share ) , min ( share ) from performance where type != 'Предпоказ'", "predicted_sql": "select max ( performance.share ) as max_share  , min ( performance.share ) as min_share from performance where performance.type  != 'предпоказ'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Показать максимальную и минимальную долю выступлений, не имеющих типа «предпоказ». \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Сколько национальностей у дирижеров?", "query": "select count ( distinct nationality ) from conductor", "predicted_sql": "select count ( distinct conductor.nationality ) from conductor", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Сколько национальностей у дирижеров? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Подсчитайте количество дирижеров разных национальностей.", "query": "select count ( distinct nationality ) from conductor", "predicted_sql": "select conductor.nationality  , count ( conductor.nationality ) as count from conductor group by conductor.nationality", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Подсчитайте количество дирижеров разных национальностей. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Перечислите имена дирижеров в порядке убывания стажа работы.", "query": "select name from conductor order by year_of_work desc", "predicted_sql": "select conductor.name from conductor order by conductor.year_of_work desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Перечислите имена дирижеров в порядке убывания стажа работы. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Как зовут дирижеров, отсортированных по количеству отработанных лет?", "query": "select name from conductor order by year_of_work desc", "predicted_sql": "select conductor.name from conductor order by conductor.year_of_work asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Как зовут дирижеров, отсортированных по количеству отработанных лет? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Укажите фамилию дирижера с наибольшим количеством лет работы.", "query": "select name from conductor order by year_of_work desc limit 1", "predicted_sql": "select conductor.name from conductor order by conductor.year_of_work desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Укажите фамилию дирижера с наибольшим количеством лет работы. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Как зовут дирижера, проработавшего наибольшее количество лет?", "query": "select name from conductor order by year_of_work desc limit 1", "predicted_sql": "select conductor.name from conductor order by conductor.year_of_work desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Как зовут дирижера, проработавшего наибольшее количество лет? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Покажите имена дирижеров и оркестров, которыми они дирижировали.", "query": "select conductor.name , orchestra.orchestra from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id", "predicted_sql": "select conductor.name  , orchestra.orchestra from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Покажите имена дирижеров и оркестров, которыми они дирижировали. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Имена дирижеров и названия оркестров, которыми они дирижировали", "query": "select conductor.name , orchestra.orchestra from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id", "predicted_sql": "select conductor.name  , orchestra.orchestra from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Имена дирижеров и названия оркестров, которыми они дирижировали \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Укажите имена дирижеров, дирижировавших более чем одним оркестром.", "query": "select conductor.name from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id group by orchestra.conductor_id having count ( * ) > 1", "predicted_sql": "select conductor.name from conductor group by conductor.name having count ( distinct conductor.conductor_id ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Укажите имена дирижеров, дирижировавших более чем одним оркестром. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Как зовут дирижеров, дирижировавших более чем в одном оркестре?", "query": "select conductor.name from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id group by orchestra.conductor_id having count ( * ) > 1", "predicted_sql": "select conductor.name from conductor where conductor.conductor_id in ( select conductor_id from orchestra group by conductor_id having count ( distinct orchestra_id ) > 1 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Как зовут дирижеров, дирижировавших более чем в одном оркестре? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Укажите имя дирижера, дирижировавшего наибольшим количеством оркестров.", "query": "select conductor.name from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id group by orchestra.conductor_id order by count ( * ) desc limit 1", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Укажите имя дирижера, дирижировавшего наибольшим количеством оркестров. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Как зовут дирижера, дирижировавшего большинством оркестров?", "query": "select conductor.name from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id group by orchestra.conductor_id order by count ( * ) desc limit 1", "predicted_sql": "select conductor.name from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id group by conductor.name having count ( orchestra.orchestra_id ) > ( select count ( orchestra_id ) from orchestra ) / 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Как зовут дирижера, дирижировавшего большинством оркестров? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Укажите имя дирижера, дирижировавшего оркестрами, основанными после 2008 года.", "query": "select conductor.name from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id where year_of_founded > 2008", "predicted_sql": "select conductor.name from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id where orchestra.year_of_founded > 2008", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Укажите имя дирижера, дирижировавшего оркестрами, основанными после 2008 года. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Как зовут дирижеров, дирижировавших оркестрами, основанными после 2008 года?", "query": "select conductor.name from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id where year_of_founded > 2008", "predicted_sql": "select conductor.name from conductor join orchestra on conductor.conductor_id = orchestra.conductor_id where orchestra.year_of_founded > 2008", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Как зовут дирижеров, дирижировавших оркестрами, основанными после 2008 года? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Пожалуйста, покажи разные звукозаписывающие компании и соответствующее количество оркестров.", "query": "select record_company , count ( * ) from orchestra group by record_company", "predicted_sql": "select orchestra.record_company  , count ( orchestra.orchestra_id ) as number_of_orchestras from orchestra group by orchestra.record_company", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Пожалуйста, покажи разные звукозаписывающие компании и соответствующее количество оркестров. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Сколько оркестров у каждой звукозаписывающей компании?", "query": "select record_company , count ( * ) from orchestra group by record_company", "predicted_sql": "select record_company  , count ( distinct orchestra_id ) as num_orchestras from orchestra group by record_company", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Сколько оркестров у каждой звукозаписывающей компании? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Пожалуйста, покажите форматы записи оркестров в порядке возрастания количества.", "query": "select major_record_format from orchestra group by major_record_format order by count ( * ) asc", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Пожалуйста, покажите форматы записи оркестров в порядке возрастания количества. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Какие основные форматы записи оркестров, отсортированные по частоте?", "query": "select major_record_format from orchestra group by major_record_format order by count ( * ) asc", "predicted_sql": "select orchestra.major_record_format from orchestra group by orchestra.major_record_format order by count ( * ) desc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Какие основные форматы записи оркестров, отсортированные по частоте? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Укажите звукозаписывающую компанию, которую делит наибольшее количество оркестров.", "query": "select record_company from orchestra group by record_company order by count ( * ) desc limit 1", "predicted_sql": "select record_company from orchestra group by record_company having count ( distinct orchestra_id ) = ( select max ( count ) from ( select count ( distinct orchestra_id ) as count from orchestra group by record_company ) )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Укажите звукозаписывающую компанию, которую делит наибольшее количество оркестров. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Какую звукозаписывающую компанию использует наибольшее количество оркестров?", "query": "select record_company from orchestra group by record_company order by count ( * ) desc limit 1", "predicted_sql": "select record_company  , count ( orchestra_id ) as num_orchestras from orchestra group by record_company order by num_orchestras desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Какую звукозаписывающую компанию использует наибольшее количество оркестров? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Перечислите названия оркестров, у которых нет выступлений.", "query": "select orchestra from orchestra where orchestra_id not in ( select orchestra_id from performance )", "predicted_sql": "select orchestra.orchestra from orchestra left join performance on orchestra.orchestra_id = performance.orchestra_id where performance.performance_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result ( Нет ) , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Перечислите названия оркестров, у которых нет выступлений. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Какие оркестры не выступают?", "query": "select orchestra from orchestra where orchestra_id not in ( select orchestra_id from performance )", "predicted_sql": "select orchestra.orchestra from orchestra where orchestra.orchestra_id not in ( select performance.orchestra_id from performance )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Какие оркестры не выступают? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Покажите звукозаписывающие компании оркестров, основанных до 2003 года и после 2003 года.", "query": "select record_company from orchestra where year_of_founded < 2003 intersect select record_company from orchestra where year_of_founded > 2003", "predicted_sql": "select orchestra.record_company from orchestra where orchestra.year_of_founded < 2003 or orchestra.year_of_founded > 2003", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Покажите звукозаписывающие компании оркестров, основанных до 2003 года и после 2003 года. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Какие звукозаписывающие компании используются как оркестрами, основанными до 2003 года, так и оркестрами, основанными после 2003 года?", "query": "select record_company from orchestra where year_of_founded < 2003 intersect select record_company from orchestra where year_of_founded > 2003", "predicted_sql": "select orchestra.record_company from orchestra where orchestra.year_of_founded <= 2003 and orchestra.record_company in ( select orchestra.record_company from orchestra where orchestra.year_of_founded > 2003 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Какие звукозаписывающие компании используются как оркестрами, основанными до 2003 года, так и оркестрами, основанными после 2003 года? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Найди количество оркестров, чей формат записи - \"CD\" или \"DVD\".", "query": "select count ( * ) from orchestra where major_record_format = 'CD' or major_record_format = 'DVD'", "predicted_sql": "select count ( distinct orchestra.orchestra_id ) from orchestra where orchestra.major_record_format = 'CD' or orchestra.major_record_format = 'DVD'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format ( CD , DVD ) | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Найди количество оркестров, чей формат записи - \"CD\" или \"DVD\". \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Подсчитай количество оркестров, у которых есть CD или DVD в качестве формата записи.", "query": "select count ( * ) from orchestra where major_record_format = 'CD' or major_record_format = 'DVD'", "predicted_sql": "select count ( distinct orchestra.orchestra_id ) from orchestra where orchestra.major_record_format = 'CD' or orchestra.major_record_format = 'DVD'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format ( CD , DVD ) | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Подсчитай количество оркестров, у которых есть CD или DVD в качестве формата записи. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Покажите годы, когда были основаны оркестры, давшие более одного выступления.", "query": "select year_of_founded from orchestra join performance on orchestra.orchestra_id = performance.orchestra_id group by performance.orchestra_id having count ( * ) > 1", "predicted_sql": "select orchestra.year_of_founded from orchestra join performance on orchestra.orchestra_id = performance.orchestra_id group by orchestra.orchestra_id having count ( performance.performance_id ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Покажите годы, когда были основаны оркестры, давшие более одного выступления. \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "orchestra", "question": "Когда были основаны оркестры, которые выступали более одного раза?", "query": "select year_of_founded from orchestra join performance on orchestra.orchestra_id = performance.orchestra_id group by performance.orchestra_id having count ( * ) > 1", "predicted_sql": "select orchestra.orchestra  , orchestra.year_of_founded from orchestra join performance on orchestra.orchestra_id = performance.orchestra_id group by orchestra.orchestra having count ( performance.performance_id ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Когда были основаны оркестры, которые выступали более одного раза? \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "network_1", "question": "Сколько здесь старшеклассников?", "query": "select count ( * ) from highschooler", "predicted_sql": "select count ( * ) from highschooler", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Сколько здесь старшеклассников? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Подсчитайте количество старшеклассников.", "query": "select count ( * ) from highschooler", "predicted_sql": "select count ( * ) from highschooler", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Подсчитайте количество старшеклассников. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажите имена и оценки каждого старшеклассника.", "query": "select name , grade from highschooler", "predicted_sql": "select highschooler.name  , highschooler.grade from highschooler", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажите имена и оценки каждого старшеклассника. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Какие имена и оценки у каждого старшеклассника?", "query": "select name , grade from highschooler", "predicted_sql": "select highschooler.name  , highschooler.grade from highschooler", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Какие имена и оценки у каждого старшеклассника? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Показать все оценки старшеклассников.", "query": "select grade from highschooler", "predicted_sql": "select * from highschooler", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Показать все оценки старшеклассников. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Какая оценка у каждого старшеклассника?", "query": "select grade from highschooler", "predicted_sql": "select highschooler.grade from highschooler", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Какая оценка у каждого старшеклассника? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "В каком классе Лев?", "query": "select grade from highschooler where name = 'Лев'", "predicted_sql": "select highschooler.grade from highschooler where highschooler.name = 'Лев'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name ( Лев ) , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### В каком классе Лев? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Отобразить оценку старшеклассника по имени Лев.", "query": "select grade from highschooler where name = 'Лев'", "predicted_sql": "select highschooler.grade from highschooler where highschooler.name = 'Лев'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name ( Лев ) , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Отобразить оценку старшеклассника по имени Лев. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажите имена всех старшеклассников 10 класса.", "query": "select name from highschooler where grade = 10", "predicted_sql": "select highschooler.name from highschooler where highschooler.grade = 10", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажите имена всех старшеклассников 10 класса. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Как зовут всех старшеклассников 10 класса?", "query": "select name from highschooler where grade = 10", "predicted_sql": "select highschooler.name from highschooler where highschooler.grade = 10", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Как зовут всех старшеклассников 10 класса? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Найди id старшеклассника по имени Лев.", "query": "select id from highschooler where name = 'Лев'", "predicted_sql": "select highschooler.id from highschooler where highschooler.name = 'Лев'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name ( Лев ) , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Найди id старшеклассника по имени Лев. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Какой у Льва id?", "query": "select id from highschooler where name = 'Лев'", "predicted_sql": "select highschooler.id from highschooler where highschooler.name = 'Лев'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Какой у Льва id? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Сколько старшеклассников в 9 или 10 классе?", "query": "select count ( * ) from highschooler where grade = 9 or grade = 10", "predicted_sql": "select count ( * ) from highschooler where grade = 9 or grade = 10", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Сколько старшеклассников в 9 или 10 классе? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Подсчитайте количество старшеклассников в 9 или 10 классах.", "query": "select count ( * ) from highschooler where grade = 9 or grade = 10", "predicted_sql": "select count ( * ) from highschooler where grade = 9 or grade = 10", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Подсчитайте количество старшеклассников в 9 или 10 классах. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Количество старшеклассников в каждом классе.", "query": "select grade , count ( * ) from highschooler group by grade", "predicted_sql": "select grade  , count ( * ) as count from highschooler group by grade", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Количество старшеклассников в каждом классе. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Сколько старшеклассников в каждом классе?", "query": "select grade , count ( * ) from highschooler group by grade", "predicted_sql": "select grade  , count ( * ) as count from highschooler group by grade", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Сколько старшеклассников в каждом классе? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "В каком классе учатся наибольшее количество старшеклассников?", "query": "select grade from highschooler group by grade order by count ( * ) desc limit 1", "predicted_sql": "select grade from highschooler where grade = '12' group by grade order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### В каком классе учатся наибольшее количество старшеклассников? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажи оценку большинства старшеклассников.", "query": "select grade from highschooler group by grade order by count ( * ) desc limit 1", "predicted_sql": "select avg ( grade ) from highschooler", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажи оценку большинства старшеклассников. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажи все классы, в которых учится не менее 4 учеников.", "query": "select grade from highschooler group by grade having count ( * ) >= 4", "predicted_sql": "select grade from highschooler group by grade having count ( * ) >= 4", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажи все классы, в которых учится не менее 4 учеников. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "В каких классах учатся 4 или более старшеклассников?", "query": "select grade from highschooler group by grade having count ( * ) >= 4", "predicted_sql": "select highschooler.grade from highschooler where highschooler.grade >= 4 group by highschooler.grade having count ( highschooler.id ) >= 4", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### В каких классах учатся 4 или более старшеклассников? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажите студенческие id и количество друзей, соответствующих каждому из этих id.", "query": "select student_id , count ( * ) from friend group by student_id", "predicted_sql": "select friend.student_id  , count ( friend.friend_id ) from friend group by friend.student_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажите студенческие id и количество друзей, соответствующих каждому из этих id. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Сколько друзей у каждого ученика?", "query": "select student_id , count ( * ) from friend group by student_id", "predicted_sql": "select highschooler.id  , count ( friend.friend_id ) as num_friends from highschooler left join friend on friend.student_id = highschooler.id group by highschooler.id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Сколько друзей у каждого ученика? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажите имена старшеклассников и количество их друзей.", "query": "select highschooler.name , count ( * ) from friend join highschooler on friend.student_id = highschooler.id group by friend.student_id", "predicted_sql": "select highschooler.name  , count ( friend.friend_id ) as friend_count from highschooler join friend on friend.student_id = highschooler.id group by highschooler.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажите имена старшеклассников и количество их друзей. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Как зовут старшеклассников и сколько друзей у каждого из них?", "query": "select highschooler.name , count ( * ) from friend join highschooler on friend.student_id = highschooler.id group by friend.student_id", "predicted_sql": "select highschooler.name  , count ( friend.friend_id ) as num_friends from highschooler join friend on friend.student_id = highschooler.id group by highschooler.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Как зовут старшеклассников и сколько друзей у каждого из них? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Как зовут старшеклассника, у которого больше всего друзей?", "query": "select highschooler.name from friend join highschooler on friend.student_id = highschooler.id group by friend.student_id order by count ( * ) desc limit 1", "predicted_sql": "select highschooler.name from highschooler join friend on friend.student_id = highschooler.id group by highschooler.id order by count ( friend.friend_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Как зовут старшеклассника, у которого больше всего друзей? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Отображать имя старшеклассника с наибольшим количеством друзей.", "query": "select highschooler.name from friend join highschooler on friend.student_id = highschooler.id group by friend.student_id order by count ( * ) desc limit 1", "predicted_sql": "select highschooler.name from highschooler join friend on friend.student_id = highschooler.id group by highschooler.name order by count ( friend.friend_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Отображать имя старшеклассника с наибольшим количеством друзей. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажи имена старшеклассников, у которых есть как минимум 3 друга.", "query": "select highschooler.name from friend join highschooler on friend.student_id = highschooler.id group by friend.student_id having count ( * ) >= 3", "predicted_sql": "select highschooler.name from highschooler join friend on friend.student_id = highschooler.id group by highschooler.id having count ( friend.friend_id ) >= 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажи имена старшеклассников, у которых есть как минимум 3 друга. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Как зовут старшеклассников, у которых есть 3 или более друзей?", "query": "select highschooler.name from friend join highschooler on friend.student_id = highschooler.id group by friend.student_id having count ( * ) >= 3", "predicted_sql": "select highschooler.name from highschooler join friend on friend.student_id = highschooler.id group by highschooler.id having count ( friend.friend_id ) >= 3", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Как зовут старшеклассников, у которых есть 3 или более друзей? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажите имена всех друзей старшеклассника Льва.", "query": "select highschooler.name from friend join highschooler on friend.student_id = highschooler.id join highschooler on friend.friend_id = highschooler.id where highschooler.name = 'Лев'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажите имена всех друзей старшеклассника Льва. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажи имена друзей старшеклассника Льва.", "query": "select highschooler.name from friend join highschooler on friend.student_id = highschooler.id join highschooler on friend.friend_id = highschooler.id where highschooler.name = 'Лев'", "predicted_sql": "select highschooler.name from highschooler join friend on friend.friend_id = highschooler.id where friend.student_id = ( select id from highschooler where name = 'Лев' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажи имена друзей старшеклассника Льва. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Сколько друзей у старшеклассника Льва?", "query": "select count ( * ) from friend join highschooler on friend.student_id = highschooler.id where highschooler.name = 'Лев'", "predicted_sql": "select count ( friend.friend_id ) from highschooler join friend on friend.student_id = highschooler.id where highschooler.name = 'Лев'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Сколько друзей у старшеклассника Льва? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Подсчитай количество друзей Льва.", "query": "select count ( * ) from friend join highschooler on friend.student_id = highschooler.id where highschooler.name = 'Лев'", "predicted_sql": "select count ( * ) from friend where friend.student_id = ( select id from highschooler where name = 'Лев' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Подсчитай количество друзей Льва. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Показать id всех студентов, у которых нет друзей.", "query": "select id from highschooler except select student_id from friend", "predicted_sql": "select highschooler.id from highschooler where highschooler.id not in ( select friend.student_id from friend )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Показать id всех студентов, у которых нет друзей. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Каковы id старшеклассников, у которых нет друзей?", "query": "select id from highschooler except select student_id from friend", "predicted_sql": "select highschooler.id from highschooler where highschooler.id not in ( select friend.student_id from friend )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Каковы id старшеклассников, у которых нет друзей? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажите имена всех старшеклассников, у которых нет друзей.", "query": "select name from highschooler except select highschooler.name from friend join highschooler on friend.student_id = highschooler.id", "predicted_sql": "select highschooler.name from highschooler where highschooler.id not in ( select friend.student_id from friend )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажите имена всех старшеклассников, у которых нет друзей. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Как зовут студентов, у которых нет друзей?", "query": "select name from highschooler except select highschooler.name from friend join highschooler on friend.student_id = highschooler.id", "predicted_sql": "select highschooler.name from highschooler where highschooler.id not in ( select friend.student_id from friend )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Как зовут студентов, у которых нет друзей? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажи id старшеклассников, у которых есть друзья и которые кому-то нравятся.", "query": "select student_id from friend intersect select liked_id from likes", "predicted_sql": "select highschooler.id from highschooler join friend on friend.student_id = highschooler.id join likes on likes.student_id = highschooler.id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажи id старшеклассников, у которых есть друзья и которые кому-то нравятся. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Какие id у студентов, у которых есть друзья и которые нравятся другим?", "query": "select student_id from friend intersect select liked_id from likes", "predicted_sql": "select highschooler.id from highschooler join friend on friend.student_id = highschooler.id join likes on likes.student_id = highschooler.id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Какие id у студентов, у которых есть друзья и которые нравятся другим? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Показать имена всех студентов, у которых есть друзья и они кому-то нравятся.", "query": "select highschooler.name from friend join highschooler on likes.student_id = highschooler.id intersect select highschooler.name from likes join highschooler on likes.liked_id = highschooler.id", "predicted_sql": "select highschooler.name from highschooler join friend on friend.student_id = highschooler.id join likes on likes.student_id = highschooler.id where friend.friend_id = highschooler.id and likes.liked_id = highschooler.id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Показать имена всех студентов, у которых есть друзья и они кому-то нравятся. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Как зовут старшеклассников, у которых есть друзья и которые нравятся людям?", "query": "select highschooler.name from friend join highschooler on likes.student_id = highschooler.id intersect select highschooler.name from likes join highschooler on likes.liked_id = highschooler.id", "predicted_sql": "select highschooler.name from highschooler join friend on friend.student_id = highschooler.id join likes on likes.student_id = highschooler.id where highschooler.id in ( select friend_id from friend ) and highschooler.id in ( select liked_id from likes )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Как зовут старшеклассников, у которых есть друзья и которые нравятся людям? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Подсчитайте количество лайков для каждого студенческого id.", "query": "select student_id , count ( * ) from likes group by student_id", "predicted_sql": "select likes.student_id  , count ( likes.liked_id ) as num_likes from likes group by likes.student_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Подсчитайте количество лайков для каждого студенческого id. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Сколько лайков соответствует каждому студенческому id?", "query": "select student_id , count ( * ) from likes group by student_id", "predicted_sql": "select likes.student_id  , count ( likes.liked_id ) as num_likes from likes group by likes.student_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Сколько лайков соответствует каждому студенческому id? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажите имена старшеклассников с лайками, и количество лайков у каждого из них.", "query": "select highschooler.name , count ( * ) from likes join highschooler on likes.student_id = highschooler.id group by likes.student_id", "predicted_sql": "select highschooler.name  , count ( likes.liked_id ) as num_likes from highschooler left join likes on highschooler.id = likes.student_id group by highschooler.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажите имена старшеклассников с лайками, и количество лайков у каждого из них. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Как зовут старшеклассников, у которых есть лайки, и сколько лайков у каждого?", "query": "select highschooler.name , count ( * ) from likes join highschooler on likes.student_id = highschooler.id group by likes.student_id", "predicted_sql": "select highschooler.name  , count ( likes.liked_id ) as num_likes from highschooler join likes on highschooler.id = likes.student_id group by highschooler.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Как зовут старшеклассников, у которых есть лайки, и сколько лайков у каждого? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Как зовут старшеклассника, у которого больше всего лайков?", "query": "select highschooler.name from likes join highschooler on likes.student_id = highschooler.id group by likes.student_id order by count ( * ) desc limit 1", "predicted_sql": "select highschooler.name from highschooler join likes on highschooler.id = likes.student_id group by highschooler.id order by count ( likes.liked_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Как зовут старшеклассника, у которого больше всего лайков? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Назовите имя ученика, у которого больше всего лайков.", "query": "select highschooler.name from likes join highschooler on likes.student_id = highschooler.id group by likes.student_id order by count ( * ) desc limit 1", "predicted_sql": "select highschooler.name from highschooler join likes on highschooler.id = likes.student_id group by highschooler.name order by count ( likes.liked_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Назовите имя ученика, у которого больше всего лайков. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажите имена студентов, которым поставили не менее 2 лайков.", "query": "select highschooler.name from likes join highschooler on likes.student_id = highschooler.id group by likes.student_id having count ( * ) >= 2", "predicted_sql": "select highschooler.name from highschooler join likes on likes.student_id = highschooler.id group by highschooler.name having count ( likes.liked_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажите имена студентов, которым поставили не менее 2 лайков. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Как зовут студентов, у которых 2 и более лайков?", "query": "select highschooler.name from likes join highschooler on likes.student_id = highschooler.id group by likes.student_id having count ( * ) >= 2", "predicted_sql": "select highschooler.name from highschooler join likes on highschooler.id = likes.student_id group by highschooler.id having count ( likes.liked_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Как зовут студентов, у которых 2 и более лайков? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажите имена учеников, которые имеют оценку выше 5 и имеют как минимум 2 друзей.", "query": "select highschooler.name from friend join highschooler on friend.student_id = highschooler.id where highschooler.grade > 5 group by friend.student_id having count ( * ) >= 2", "predicted_sql": "select highschooler.name from highschooler where highschooler.grade > 5 and ( select count ( * ) from friend where friend.student_id = highschooler.id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажите имена учеников, которые имеют оценку выше 5 и имеют как минимум 2 друзей. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Как зовут старшеклассников, которые имеют оценку выше 5 и имеют 2 или более друзей?", "query": "select highschooler.name from friend join highschooler on friend.student_id = highschooler.id where highschooler.grade > 5 group by friend.student_id having count ( * ) >= 2", "predicted_sql": "select highschooler.name from highschooler where highschooler.grade > 5 and highschooler.id in ( select friend.student_id from friend group by friend.student_id having count ( friend.friend_id ) >= 2 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Как зовут старшеклассников, которые имеют оценку выше 5 и имеют 2 или более друзей? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Сколько лайков у Льва?", "query": "select count ( * ) from likes join highschooler on likes.student_id = highschooler.id where highschooler.name = 'Лев'", "predicted_sql": "select count ( * ) from likes where likes.student_id = ( select id from highschooler where name = 'Лев' )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Сколько лайков у Льва? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Покажи количество лайков у старшеклассника по имени Лев.", "query": "select count ( * ) from likes join highschooler on likes.student_id = highschooler.id where highschooler.name = 'Лев'", "predicted_sql": "select count ( likes.liked_id ) from highschooler join likes on likes.student_id = highschooler.id where highschooler.name = 'Лев'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name ( Лев ) , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Покажи количество лайков у старшеклассника по имени Лев. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Найдите среднюю оценку всех учеников, у которых есть друзья.", "query": "select avg ( grade ) from highschooler where id in ( select friend.student_id from friend join highschooler on friend.student_id = highschooler.id )", "predicted_sql": "select avg ( grade ) from highschooler where id in ( select student_id from friend )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Найдите среднюю оценку всех учеников, у которых есть друзья. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Какова средняя оценка у студентов, у которых есть друзья?", "query": "select avg ( grade ) from highschooler where id in ( select friend.student_id from friend join highschooler on friend.student_id = highschooler.id )", "predicted_sql": "select avg ( highschooler.grade ) from highschooler join friend on friend.student_id = highschooler.id join highschooler as friend_highschooler on friend_highschooler.id = friend.friend_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Какова средняя оценка у студентов, у которых есть друзья? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Найдите самый младший класс учеников, у которых нет друзей.", "query": "select min ( grade ) from highschooler where id not in ( select friend.student_id from friend join highschooler on friend.student_id = highschooler.id )", "predicted_sql": "select min ( highschooler.grade ) from highschooler where highschooler.id not in ( select friend.student_id from friend )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Найдите самый младший класс учеников, у которых нет друзей. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Какой самый младший класс учеников, у которых нет друзей?", "query": "select min ( grade ) from highschooler where id not in ( select friend.student_id from friend join highschooler on friend.student_id = highschooler.id )", "predicted_sql": "select min ( highschooler.grade ) from highschooler where highschooler.id not in ( select friend.student_id from friend )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Какой самый младший класс учеников, у которых нет друзей? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "dog_kennels", "question": "В каких штатах проживают и хозяева, и специалисты?", "query": "select state from owners intersect select state from professionals", "predicted_sql": "select owners.state  , professionals.state from owners join professionals on owners.state = professionals.state", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### В каких штатах проживают и хозяева, и специалисты? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найдите штаты, в которых живут и хозяева, и специалисты.", "query": "select state from owners intersect select state from professionals", "predicted_sql": "select owners.state from owners join professionals on owners.state = professionals.state", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найдите штаты, в которых живут и хозяева, и специалисты. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Каков средний возраст собак, прошедших какое-либо лечение?", "query": "select avg ( age ) from dogs where dog_id in ( select dog_id from treatments )", "predicted_sql": "select avg ( age ) from dogs where dog_id in ( select dog_id from treatments )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Каков средний возраст собак, прошедших какое-либо лечение? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найдите средний возраст собак, прошедших курс лечения.", "query": "select avg ( age ) from dogs where dog_id in ( select dog_id from treatments )", "predicted_sql": "select avg ( age ) from dogs where dog_id in ( select dog_id from treatments )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найдите средний возраст собак, прошедших курс лечения. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какие специалисты живут в штате Индиана или провели лечение более чем двумя способами? Укажите его или ее id, фамилию и мобильный телефон.", "query": "select professional_id , last_name , cell_number from professionals where state = 'Indiana' union select professionals.professional_id , professionals.last_name , professionals.cell_number from professionals join treatments on professionals.professional_id = treatments.professional_id group by professionals.professional_id having count ( * ) > 2", "predicted_sql": "select professionals.professional_id  , professionals.last_name  , professionals.cell_number from professionals where professionals.state = 'Indiana' or professionals.professional_id in ( select professional_id from treatments group by professional_id having count ( distinct treatment_type_code ) > 2 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какие специалисты живут в штате Индиана или провели лечение более чем двумя способами? Укажите его или ее id, фамилию и мобильный телефон. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найдите id, фамилии и сотовые телефоны специалистов, которые живут в штате Индиана или провели более двух процедур.", "query": "select professional_id , last_name , cell_number from professionals where state = 'Indiana' union select professionals.professional_id , professionals.last_name , professionals.cell_number from professionals join treatments on professionals.professional_id = treatments.professional_id group by professionals.professional_id having count ( * ) > 2", "predicted_sql": "select professionals.professional_id  , professionals.last_name  , professionals.cell_number from professionals where professionals.state = 'Indiana' or ( select count ( * ) from treatments where treatments.professional_id = professionals.professional_id ) > 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найдите id, фамилии и сотовые телефоны специалистов, которые живут в штате Индиана или провели более двух процедур. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Лечение каких собак не обошлось своим хозяевам дороже 1000? Укажи клички собак.", "query": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum ( cost_of_treatment ) > 1000 )", "predicted_sql": "select dogs.name from dogs join treatments on dogs.dog_id = treatments.dog_id where treatments.cost_of_treatment > 1000 and dogs.date_departed is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Лечение каких собак не обошлось своим хозяевам дороже 1000? Укажи клички собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Как зовут собак, на лечение которых их хозяин не потратил более 1000?", "query": "select name from dogs where dog_id not in ( select dog_id from treatments group by dog_id having sum ( cost_of_treatment ) > 1000 )", "predicted_sql": "select dogs.name from dogs join owners on dogs.owner_id = owners.owner_id join treatments on treatments.dog_id = dogs.dog_id where treatments.cost_of_treatment > 1000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Как зовут собак, на лечение которых их хозяин не потратил более 1000? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какие имена используются для специалистов или владельцев, но не используются в качестве имен собак?", "query": "select first_name from professionals union select first_name from owners except select name from dogs", "predicted_sql": "select professionals.first_name  , professionals.last_name  , owners.first_name  , owners.last_name from professionals left join dogs on professionals.first_name = dogs.name left join owners on professionals.first_name = owners.first_name where dogs.name is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какие имена используются для специалистов или владельцев, но не используются в качестве имен собак? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найдите имена, которые используются для специалистов или владельцев, но не используются в качестве имен собак.", "query": "select first_name from professionals union select first_name from owners except select name from dogs", "predicted_sql": "select owners.first_name from owners where owners.first_name not in ( select dogs.name from dogs ) union select professionals.first_name from professionals where professionals.first_name not in ( select dogs.name from dogs )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найдите имена, которые используются для специалистов или владельцев, но не используются в качестве имен собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Кто из специалистов не проводил лечение собакам? Перечислите id, должность и адрес электронной почты специалиста.", "query": "select professional_id , role_code , email_address from professionals except select professionals.professional_id , professionals.role_code , professionals.email_address from professionals join treatments on professionals.professional_id = treatments.professional_id", "predicted_sql": "select professionals.professional_id  , professionals.role_code  , professionals.email_address from professionals where professionals.professional_id not in ( select treatments.professional_id from treatments )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Кто из специалистов не проводил лечение собакам? Перечислите id, должность и адрес электронной почты специалиста. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Покажи id, должность и адрес электронной почты профессионалов, которые не лечили собак.", "query": "select professional_id , role_code , email_address from professionals except select professionals.professional_id , professionals.role_code , professionals.email_address from professionals join treatments on professionals.professional_id = treatments.professional_id", "predicted_sql": "select professionals.professional_id  , professionals.role_code  , professionals.email_address from professionals where professionals.professional_id not in ( select treatments.professional_id from treatments )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Покажи id, должность и адрес электронной почты профессионалов, которые не лечили собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "У какого владельца больше всего собак? Укажите id владельца, имя и фамилию.", "query": "select dogs.owner_id , owners.first_name , owners.last_name from dogs join owners on dogs.owner_id = owners.owner_id group by dogs.owner_id order by count ( * ) desc limit 1", "predicted_sql": "select owners.owner_id  , owners.first_name  , owners.last_name from owners join dogs on dogs.owner_id = owners.owner_id group by owners.owner_id order by count ( dogs.dog_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### У какого владельца больше всего собак? Укажите id владельца, имя и фамилию. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Указать id, имя и фамилию владельца, у которого больше всего собак.", "query": "select dogs.owner_id , owners.first_name , owners.last_name from dogs join owners on dogs.owner_id = owners.owner_id group by dogs.owner_id order by count ( * ) desc limit 1", "predicted_sql": "select owners.owner_id  , owners.first_name  , owners.last_name from owners join dogs on dogs.owner_id = owners.owner_id group by owners.owner_id order by count ( dogs.dog_id ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Указать id, имя и фамилию владельца, у которого больше всего собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какие специалисты провели как минимум две процедуры? Перечислите id, должность и имя специалиста.", "query": "select professionals.professional_id , professionals.role_code , professionals.first_name from professionals join treatments on professionals.professional_id = treatments.professional_id group by professionals.professional_id having count ( * ) >= 2", "predicted_sql": "select professionals.professional_id  , professionals.role_code  , professionals.first_name from professionals join treatments on treatments.professional_id = professionals.professional_id group by professionals.professional_id having count ( treatments.treatment_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какие специалисты провели как минимум две процедуры? Перечислите id, должность и имя специалиста. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Каковы id, роли и имена специалистов, которые провели два или более курса лечения?", "query": "select professionals.professional_id , professionals.role_code , professionals.first_name from professionals join treatments on professionals.professional_id = treatments.professional_id group by professionals.professional_id having count ( * ) >= 2", "predicted_sql": "select professionals.professional_id  , professionals.role_code  , professionals.first_name from professionals join treatments on treatments.professional_id = professionals.professional_id group by professionals.professional_id having count ( treatments.treatment_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Каковы id, роли и имена специалистов, которые провели два или более курса лечения? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Как называется наиболее распространенная порода собак?", "query": "select breeds.breed_name from breeds join dogs on breeds.breed_code = dogs.breed_code group by breeds.breed_name order by count ( * ) desc limit 1", "predicted_sql": "select breeds.breed_name from breeds group by breeds.breed_name order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Как называется наиболее распространенная порода собак? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какая порода у большинства собак? Отображать название породы.", "query": "select breeds.breed_name from breeds join dogs on breeds.breed_code = dogs.breed_code group by breeds.breed_name order by count ( * ) desc limit 1", "predicted_sql": "select breeds.breed_name from breeds join dogs on dogs.breed_code = breeds.breed_code group by breeds.breed_name order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какая порода у большинства собак? Отображать название породы. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какой владелец заплатил больше всего за лечение своих собак? Покажи id и фамилию владельца.", "query": "select owners.owner_id , owners.last_name from owners join dogs on owners.owner_id = dogs.owner_id join treatments on dogs.dog_id = treatments.dog_id group by owners.owner_id order by count ( * ) desc limit 1", "predicted_sql": "select owners.owner_id  , owners.last_name from owners join dogs on dogs.owner_id = owners.owner_id join treatments on treatments.dog_id = dogs.dog_id group by owners.owner_id order by sum ( treatments.cost_of_treatment ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какой владелец заплатил больше всего за лечение своих собак? Покажи id и фамилию владельца. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Показывать id и фамилию владельца, который больше всего потратил на лечение своих собак.", "query": "select owners.owner_id , owners.last_name from owners join dogs on owners.owner_id = dogs.owner_id join treatments on dogs.dog_id = treatments.dog_id group by owners.owner_id order by count ( * ) desc limit 1", "predicted_sql": "select owners.owner_id  , owners.last_name from owners join dogs on dogs.owner_id = owners.owner_id join treatments on treatments.dog_id = dogs.dog_id group by owners.owner_id order by sum ( treatments.cost_of_treatment ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Показывать id и фамилию владельца, который больше всего потратил на лечение своих собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Как называется лечение, которое в целом стоит меньше всего?", "query": "select treatment_types.treatment_type_description from treatment_types join treatments on treatment_types.treatment_type_code = treatments.treatment_type_code group by treatment_types.treatment_type_code order by sum ( cost_of_treatment ) asc limit 1", "predicted_sql": "select treatment_types.treatment_type_description from treatments join treatment_types on treatments.treatment_type_code = treatment_types.treatment_type_code group by treatments.treatment_type_code order by sum ( treatments.cost_of_treatment ) asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Как называется лечение, которое в целом стоит меньше всего? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Дайте мне описание вида лечения, общая стоимость которого самая низкая.", "query": "select treatment_types.treatment_type_description from treatment_types join treatments on treatment_types.treatment_type_code = treatments.treatment_type_code group by treatment_types.treatment_type_code order by sum ( cost_of_treatment ) asc limit 1", "predicted_sql": "select treatment_types.treatment_type_description  , sum ( treatments.cost_of_treatment ) as total_cost from treatments join treatment_types on treatments.treatment_type_code = treatment_types.treatment_type_code group by treatments.treatment_type_code order by total_cost asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Дайте мне описание вида лечения, общая стоимость которого самая низкая. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какой владелец заплатил самую большую сумму денег за своих собак? Покажите id владельца и почтовый индекс.", "query": "select owners.owner_id , owners.zip_code from owners join dogs on owners.owner_id = dogs.owner_id join treatments on dogs.dog_id = treatments.dog_id group by owners.owner_id order by sum ( treatments.cost_of_treatment ) desc limit 1", "predicted_sql": "select owners.owner_id  , owners.zip_code from owners join dogs on dogs.owner_id = owners.owner_id join treatments on treatments.dog_id = dogs.dog_id group by owners.owner_id order by sum ( treatments.cost_of_treatment ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какой владелец заплатил самую большую сумму денег за своих собак? Покажите id владельца и почтовый индекс. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найти id и почтовый индекс владельца, который потратил больше всего денег на своих собак.", "query": "select owners.owner_id , owners.zip_code from owners join dogs on owners.owner_id = dogs.owner_id join treatments on dogs.dog_id = treatments.dog_id group by owners.owner_id order by sum ( treatments.cost_of_treatment ) desc limit 1", "predicted_sql": "select owners.owner_id  , owners.zip_code from owners join dogs on dogs.owner_id = owners.owner_id join treatments on treatments.dog_id = dogs.dog_id group by owners.owner_id order by sum ( treatments.cost_of_treatment ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найти id и почтовый индекс владельца, который потратил больше всего денег на своих собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какие специалисты проводили как минимум два вида лечения? Показать id специалиста и мобильный телефон.", "query": "select professionals.professional_id , professionals.cell_number from professionals join treatments on professionals.professional_id = treatments.professional_id group by professionals.professional_id having count ( * ) >= 2", "predicted_sql": "select professionals.professional_id  , professionals.cell_number from professionals join treatments on treatments.professional_id = professionals.professional_id group by professionals.professional_id having count ( distinct treatments.treatment_type_code ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какие специалисты проводили как минимум два вида лечения? Показать id специалиста и мобильный телефон. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найдите id и мобильный телефон специалистов, которые проводят два или более лечения.", "query": "select professionals.professional_id , professionals.cell_number from professionals join treatments on professionals.professional_id = treatments.professional_id group by professionals.professional_id having count ( * ) >= 2", "predicted_sql": "select professionals.professional_id  , professionals.cell_number from professionals join treatments on treatments.professional_id = professionals.professional_id group by professionals.professional_id having count ( treatments.treatment_id ) >= 2", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найдите id и мобильный телефон специалистов, которые проводят два или более лечения. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Как зовут специалистов, которые провели лечение стоимостью ниже среднего?", "query": "select distinct professionals.first_name , professionals.last_name from professionals join treatments where cost_of_treatment < ( select avg ( cost_of_treatment ) from treatments )", "predicted_sql": "select professionals.first_name  , professionals.last_name from professionals join treatments on treatments.professional_id = professionals.professional_id where treatments.cost_of_treatment < ( select avg ( cost_of_treatment ) from treatments )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Как зовут специалистов, которые провели лечение стоимостью ниже среднего? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какие специалисты проводили лечение, которое стоит меньше среднего? Показать их имена и фамилии.", "query": "select distinct professionals.first_name , professionals.last_name from professionals join treatments where cost_of_treatment < ( select avg ( cost_of_treatment ) from treatments )", "predicted_sql": "select professionals.first_name  , professionals.last_name from professionals join treatments on treatments.professional_id = professionals.professional_id where treatments.cost_of_treatment < ( select avg ( cost_of_treatment ) from treatments )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какие специалисты проводили лечение, которое стоит меньше среднего? Показать их имена и фамилии. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Укажите дату каждого лечения вместе с именем специалиста, который его проводил.", "query": "select treatments.date_of_treatment , professionals.first_name from treatments join professionals on treatments.professional_id = professionals.professional_id", "predicted_sql": "select treatments.date_of_treatment  , professionals.first_name || ' ' || professionals.last_name as specialist_name from treatments inner join professionals on treatments.professional_id = professionals.professional_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Укажите дату каждого лечения вместе с именем специалиста, который его проводил. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какая дата и имя лечащего специалиста на каждом сеансе лечения?", "query": "select treatments.date_of_treatment , professionals.first_name from treatments join professionals on treatments.professional_id = professionals.professional_id", "predicted_sql": "select treatments.date_of_treatment  , professionals.first_name || ' ' || professionals.last_name as treating_specialist_name from treatments inner join professionals on treatments.professional_id = professionals.professional_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какая дата и имя лечащего специалиста на каждом сеансе лечения? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Отображать стоимость каждого лечения и соответствующее описание типа лечения.", "query": "select treatments.cost_of_treatment , treatment_types.treatment_type_description from treatments join treatment_types on treatments.treatment_type_code = treatment_types.treatment_type_code", "predicted_sql": "select treatments.cost_of_treatment  , treatment_types.treatment_type_description from treatments join treatment_types on treatments.treatment_type_code = treatment_types.treatment_type_code", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Отображать стоимость каждого лечения и соответствующее описание типа лечения. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какова стоимость и описание каждого вида лечения?", "query": "select treatments.cost_of_treatment , treatment_types.treatment_type_description from treatments join treatment_types on treatments.treatment_type_code = treatment_types.treatment_type_code", "predicted_sql": "select treatments.treatment_type_code  , treatment_types.treatment_type_description  , treatments.cost_of_treatment from treatments join treatment_types on treatments.treatment_type_code = treatment_types.treatment_type_code", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какова стоимость и описание каждого вида лечения? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Перечислите имя, фамилию каждого владельца и размер его собаки.", "query": "select owners.first_name , owners.last_name , dogs.size_code from owners join dogs on owners.owner_id = dogs.owner_id", "predicted_sql": "select owners.first_name  , owners.last_name  , sizes.size_description from owners join dogs on dogs.owner_id = owners.owner_id join sizes on dogs.size_code = sizes.size_code", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Перечислите имя, фамилию каждого владельца и размер его собаки. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какое имя, фамилия и размер собаки каждого владельца?", "query": "select owners.first_name , owners.last_name , dogs.size_code from owners join dogs on owners.owner_id = dogs.owner_id", "predicted_sql": "select owners.first_name  , owners.last_name  , sizes.size_description from owners join dogs on dogs.owner_id = owners.owner_id join sizes on dogs.size_code = sizes.size_code", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какое имя, фамилия и размер собаки каждого владельца? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Перечислите пары имени владельца и клички собаки.", "query": "select owners.first_name , dogs.name from owners join dogs on owners.owner_id = dogs.owner_id", "predicted_sql": "select owners.first_name  , dogs.name from owners join dogs on dogs.owner_id = owners.owner_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Перечислите пары имени владельца и клички собаки. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Как зовут каждого владельца и как зовут их собак?", "query": "select owners.first_name , dogs.name from owners join dogs on owners.owner_id = dogs.owner_id", "predicted_sql": "select owners.first_name  , owners.last_name  , dogs.name from owners join dogs on dogs.owner_id = owners.owner_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Как зовут каждого владельца и как зовут их собак? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Перечислите клички собак самой редкой породы и даты их лечения.", "query": "select dogs.name , treatments.date_of_treatment from dogs join treatments on dogs.dog_id = treatments.dog_id where dogs.breed_code = ( select breed_code from dogs group by breed_code order by count ( * ) asc limit 1 )", "predicted_sql": "select dogs.name  , treatments.date_of_treatment from dogs join breeds on dogs.breed_code = breeds.breed_code join treatments on treatments.dog_id = dogs.dog_id where breeds.breed_code = ( select breed_code from breeds order by breed_code asc limit 1 ) order by treatments.date_of_treatment asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Перечислите клички собак самой редкой породы и даты их лечения. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какие собаки самой редкой породы? Показывать их клички и даты лечения.", "query": "select dogs.name , treatments.date_of_treatment from dogs join treatments on dogs.dog_id = treatments.dog_id where dogs.breed_code = ( select breed_code from dogs group by breed_code order by count ( * ) asc limit 1 )", "predicted_sql": "select dogs.name  , treatments.date_of_treatment from dogs join breeds on dogs.breed_code = breeds.breed_code join treatments on treatments.dog_id = dogs.dog_id where breeds.breed_name = ( select breed_name from breeds group by breed_name having count ( * ) = 1 )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какие собаки самой редкой породы? Показывать их клички и даты лечения. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какие собаки принадлежат жителю Воронежской области? Покажи имя владельца и кличку собаки.", "query": "select owners.first_name , dogs.name from owners join dogs on owners.owner_id = dogs.owner_id where owners.state = 'Воронежская область'", "predicted_sql": "select owners.first_name  , owners.last_name  , dogs.name from owners join dogs on dogs.owner_id = owners.owner_id where owners.state = 'Воронежская область'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какие собаки принадлежат жителю Воронежской области? Покажи имя владельца и кличку собаки. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найдите имена владельцев, живущих в Воронежской области, и клички принадлежащих им собак.", "query": "select owners.first_name , dogs.name from owners join dogs on owners.owner_id = dogs.owner_id where owners.state = 'Воронежская область'", "predicted_sql": "select owners.first_name  , dogs.name from owners join dogs on dogs.owner_id = owners.owner_id where owners.state = 'Воронежская область'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найдите имена владельцев, живущих в Воронежской области, и клички принадлежащих им собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какая дата прибытия и дата отъезда собак, прошедших курс лечения?", "query": "select distinct dogs.date_arrived , dogs.date_departed from dogs join treatments on dogs.dog_id = treatments.dog_id", "predicted_sql": "select dogs.date_arrived  , dogs.date_departed from dogs join treatments on dogs.dog_id = treatments.dog_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какая дата прибытия и дата отъезда собак, прошедших курс лечения? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найдите дату прибытия и дату отъезда собак, прошедших курс лечения.", "query": "select distinct dogs.date_arrived , dogs.date_departed from dogs join treatments on dogs.dog_id = treatments.dog_id", "predicted_sql": "select dogs.date_arrived  , dogs.date_departed from dogs join treatments on dogs.dog_id = treatments.dog_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найдите дату прибытия и дату отъезда собак, прошедших курс лечения. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Укажите фамилию владельца самой молодой собаки.", "query": "select owners.last_name from owners join dogs on owners.owner_id = dogs.owner_id where dogs.age = ( select max ( age ) from dogs )", "predicted_sql": "select owners.last_name from dogs join owners on dogs.owner_id = owners.owner_id where dogs.age = ( select min ( age ) from dogs )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Укажите фамилию владельца самой молодой собаки. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Кому принадлежит самая молодая собака? Назови мне его или ее фамилию.", "query": "select owners.last_name from owners join dogs on owners.owner_id = dogs.owner_id where dogs.age = ( select max ( age ) from dogs )", "predicted_sql": "select owners.last_name from dogs inner join owners on dogs.owner_id = owners.owner_id where dogs.age = ( select min ( age ) from dogs )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Кому принадлежит самая молодая собака? Назови мне его или ее фамилию. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Перечислите адреса электронной почты специалистов, проживающих в Воронежской области или Московской области.", "query": "select email_address from professionals where state = 'Московская область' or state = 'Воронежская область'", "predicted_sql": "select professionals.email_address from professionals where professionals.state = 'Воронежская область' or professionals.state = 'Московская область'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Перечислите адреса электронной почты специалистов, проживающих в Воронежской области или Московской области. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какие адреса электронных почт у специалистов, проживающих в Воронежской области или Московской области?", "query": "select email_address from professionals where state = 'Московская область' or state = 'Воронежская область'", "predicted_sql": "select professionals.email_address from professionals where professionals.state = 'Воронежская область' or professionals.state = 'Московская область'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какие адреса электронных почт у специалистов, проживающих в Воронежской области или Московской области? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какая дата прибытия и дата отъезда всех собак?", "query": "select date_arrived , date_departed from dogs", "predicted_sql": "select dogs.date_arrived  , dogs.date_departed from dogs", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какая дата прибытия и дата отъезда всех собак? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Укажите дату прибытия и дату отъезда для всех собак.", "query": "select date_arrived , date_departed from dogs", "predicted_sql": "select dogs.date_arrived  , dogs.date_departed from dogs", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Укажите дату прибытия и дату отъезда для всех собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Сколько собак прошли какое-либо лечение?", "query": "select count ( distinct dog_id ) from treatments", "predicted_sql": "select count ( distinct dogs.dog_id ) from dogs join treatments on dogs.dog_id = treatments.dog_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Сколько собак прошли какое-либо лечение? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Подсчитайте количество собак, прошедших курс лечения.", "query": "select count ( distinct dog_id ) from treatments", "predicted_sql": "select count ( distinct dogs.dog_id ) from dogs join treatments on dogs.dog_id = treatments.dog_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Подсчитайте количество собак, прошедших курс лечения. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Сколько специалистов лечили собак?", "query": "select count ( distinct professional_id ) from treatments", "predicted_sql": "select count ( distinct professionals.professional_id ) from professionals join treatments on treatments.professional_id = professionals.professional_id join dogs on dogs.dog_id = treatments.dog_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Сколько специалистов лечили собак? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найдите количество специалистов, которые когда-либо лечили собак.", "query": "select count ( distinct professional_id ) from treatments", "predicted_sql": "select count ( distinct professionals.professional_id ) from professionals join treatments on treatments.professional_id = professionals.professional_id join dogs on dogs.dog_id = treatments.dog_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найдите количество специалистов, которые когда-либо лечили собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какие специалисты живут в городе, где есть подстрока «Великий»? Перечислите его или ее должность, улицу, город и штат.", "query": "select role_code , street , city , state from professionals where city like '%Великий%'", "predicted_sql": "select professionals.role_code  , professionals.street  , professionals.city  , professionals.state from professionals where professionals.city like '%Великий%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какие специалисты живут в городе, где есть подстрока «Великий»? Перечислите его или ее должность, улицу, город и штат. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найдите должность, улицу, город и штат специалистов, живущих в городе, который содержит подстроку «Великий».", "query": "select role_code , street , city , state from professionals where city like '%Великий%'", "predicted_sql": "select professionals.role_code  , professionals.street  , professionals.city  , professionals.state from professionals where professionals.city like '%Великий%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найдите должность, улицу, город и штат специалистов, живущих в городе, который содержит подстроку «Великий». \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какие владельцы проживают в области, в названии которого есть подстрока «автономная»? Укажите их имя, фамилию и адрес электронной почты.", "query": "select first_name , last_name , email_address from owners where state like '%автономная%'", "predicted_sql": "select owners.first_name  , owners.last_name  , owners.email_address from owners where owners.state like '%автономная%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какие владельцы проживают в области, в названии которого есть подстрока «автономная»? Укажите их имя, фамилию и адрес электронной почты. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найти имя, фамилию и адрес электронной почты владельцев, проживающих в области, в названии которого содержится подстрока «автономная».", "query": "select first_name , last_name , email_address from owners where state like '%автономная%'", "predicted_sql": "select owners.first_name  , owners.last_name  , owners.email_address from owners where owners.state like '%автономная%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найти имя, фамилию и адрес электронной почты владельцев, проживающих в области, в названии которого содержится подстрока «автономная». \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Сколько собак имеют возраст ниже среднего?", "query": "select count ( * ) from dogs where age < ( select avg ( age ) from dogs )", "predicted_sql": "select count ( * ) from dogs where age < ( select avg ( age ) from dogs )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Сколько собак имеют возраст ниже среднего? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Подсчитайте количество собак возраста ниже среднего.", "query": "select count ( * ) from dogs where age < ( select avg ( age ) from dogs )", "predicted_sql": "select count ( * ) from dogs where age < ( select avg ( age ) from dogs )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Подсчитайте количество собак возраста ниже среднего. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Сколько стоило самое последнее лечение?", "query": "select cost_of_treatment from treatments order by date_of_treatment desc limit 1", "predicted_sql": "select treatments.cost_of_treatment from treatments order by treatments.date_of_treatment desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Сколько стоило самое последнее лечение? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Покажите мне стоимость последнего проведенного лечения.", "query": "select cost_of_treatment from treatments order by date_of_treatment desc limit 1", "predicted_sql": "select treatments.cost_of_treatment from treatments order by treatments.date_of_treatment desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Покажите мне стоимость последнего проведенного лечения. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Сколько собак не прошли никакого лечения?", "query": "select count ( * ) from dogs where dog_id not in ( select dog_id from treatments )", "predicted_sql": "select count ( dog_id ) from dogs where dog_id not in ( select dog_id from treatments )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Сколько собак не прошли никакого лечения? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Назовите мне количество собак, которые не получали никакого лечения.", "query": "select count ( * ) from dogs where dog_id not in ( select dog_id from treatments )", "predicted_sql": "select count ( dog_id ) from dogs where dog_id not in ( select dog_id from treatments )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Назовите мне количество собак, которые не получали никакого лечения. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Сколько владельцев временно не имеют собак?", "query": "select count ( * ) from owners where owner_id not in ( select owner_id from dogs )", "predicted_sql": "select count ( * ) from owners where owner_id not in ( select owner_id from dogs where date_departed is null )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Сколько владельцев временно не имеют собак? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Количество владельцев, у которых на данный момент нет собак.", "query": "select count ( * ) from owners where owner_id not in ( select owner_id from dogs )", "predicted_sql": "select count ( owners.owner_id ) from owners left join dogs on owners.owner_id = dogs.owner_id where dogs.dog_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Количество владельцев, у которых на данный момент нет собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Сколько специалистов не лечили собак?", "query": "select count ( * ) from professionals where professional_id not in ( select professional_id from treatments )", "predicted_sql": "select count ( professionals.professional_id ) from professionals left join treatments on professionals.professional_id = treatments.professional_id where treatments.treatment_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Сколько специалистов не лечили собак? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найдите количество специалистов, которые не лечили собак.", "query": "select count ( * ) from professionals where professional_id not in ( select professional_id from treatments )", "predicted_sql": "select count ( professionals.professional_id ) from professionals where professionals.professional_id not in ( select distinct professional_id from treatments )", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найдите количество специалистов, которые не лечили собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Перечисли кличку, возраст и вес брошенных собак? 1 означает да, а 0 означает нет.", "query": "select name , age , weight from dogs where abandoned_yn = 1", "predicted_sql": "select dogs.name  , dogs.age  , dogs.weight from dogs where dogs.abandoned_yn = 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Перечисли кличку, возраст и вес брошенных собак? 1 означает да, а 0 означает нет. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какова кличка, возраст и вес брошенных собак? Обратите внимание, что 1 означает «да», а 0 означает «нет» в таблицах.", "query": "select name , age , weight from dogs where abandoned_yn = 1", "predicted_sql": "select dogs.name  , dogs.age  , dogs.weight from dogs where dogs.abandoned_yn = 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какова кличка, возраст и вес брошенных собак? Обратите внимание, что 1 означает «да», а 0 означает «нет» в таблицах. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Каков средний возраст всех собак?", "query": "select avg ( age ) from dogs", "predicted_sql": "select avg ( age ) from dogs", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Каков средний возраст всех собак? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Вычислите средний возраст всех собак.", "query": "select avg ( age ) from dogs", "predicted_sql": "select avg ( age ) from dogs", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Вычислите средний возраст всех собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Каков возраст самой старой собаки?", "query": "select max ( age ) from dogs", "predicted_sql": "select max ( age ) from dogs", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Каков возраст самой старой собаки? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Назови мне возраст самой старой собаки.", "query": "select max ( age ) from dogs", "predicted_sql": "select max ( age ) from dogs", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Назови мне возраст самой старой собаки. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Сколько стоит каждый тип начисления? Укажите тип и сумму оплаты.", "query": "select charge_type , charge_amount from charges", "predicted_sql": "select charges.charge_type  , charges.charge_amount from charges", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Сколько стоит каждый тип начисления? Укажите тип и сумму оплаты. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Покажи каждый тип начисления и его сумму.", "query": "select charge_type , charge_amount from charges", "predicted_sql": "select charges.charge_type  , sum ( charges.charge_amount ) as total_amount from charges group by charges.charge_type", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Покажи каждый тип начисления и его сумму. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Сколько стоит самый дорогой тип начисления?", "query": "select max ( charge_amount ) from charges", "predicted_sql": "select max ( charges.charge_amount ) from charges", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Сколько стоит самый дорогой тип начисления? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какая сумма платежа через самый дорогой тип начисления?", "query": "select max ( charge_amount ) from charges", "predicted_sql": "select max ( charges.charge_amount ) as max_charge_amount from charges", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какая сумма платежа через самый дорогой тип начисления? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Составьте список адресов электронной почты, сотовых и домашних телефонов всех специалистов.", "query": "select email_address , cell_number , home_phone from professionals", "predicted_sql": "select professionals.email_address  , professionals.home_phone  , professionals.cell_number from professionals", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Составьте список адресов электронной почты, сотовых и домашних телефонов всех специалистов. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Какие у каждого специалиста электронная почта, мобильный и домашний телефоны?", "query": "select email_address , cell_number , home_phone from professionals", "predicted_sql": "select professionals.email_address  , professionals.home_phone  , professionals.cell_number from professionals", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Какие у каждого специалиста электронная почта, мобильный и домашний телефоны? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Каковы все возможные комбинации породного типа и размерного типа?", "query": "select distinct breed_code , size_code from dogs", "predicted_sql": "select breeds.breed_code  , breeds.breed_name  , sizes.size_code  , sizes.size_description from breeds  , sizes", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Каковы все возможные комбинации породного типа и размерного типа? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Найдите различные сочетания типов породы и размера для собак.", "query": "select distinct breed_code , size_code from dogs", "predicted_sql": "select breeds.breed_code  , breeds.breed_name  , sizes.size_code  , sizes.size_description from breeds  , sizes  , dogs where dogs.breed_code = breeds.breed_code and dogs.size_code = sizes.size_code group by breeds.breed_code  , breeds.breed_name  , sizes.size_code  , sizes.size_description", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Найдите различные сочетания типов породы и размера для собак. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Перечислите имена всех специалистов вместе с описанием лечения, которое они сделали.", "query": "select distinct professionals.first_name , treatment_types.treatment_type_description from professionals join treatments on professionals.professional_id = treatments.professional_id join treatment_types on treatments.treatment_type_code = treatment_types.treatment_type_code", "predicted_sql": "select professionals.first_name  , professionals.last_name  , treatment_types.treatment_type_description from professionals join treatments on treatments.professional_id = professionals.professional_id join treatment_types on treatments.treatment_type_code = treatment_types.treatment_type_code", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Перечислите имена всех специалистов вместе с описанием лечения, которое они сделали. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "dog_kennels", "question": "Как зовут каждого специалиста и как он описывает проведенное лечение?", "query": "select distinct professionals.first_name , treatment_types.treatment_type_description from professionals join treatments on professionals.professional_id = treatments.professional_id join treatment_types on treatments.treatment_type_code = treatment_types.treatment_type_code", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Как зовут каждого специалиста и как он описывает проведенное лечение? \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "singer", "question": "Сколько здесь певцов?", "query": "select count ( * ) from singer", "predicted_sql": "select count ( singer_id ) from singer", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Сколько здесь певцов? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Сколько певцов?", "query": "select count ( * ) from singer", "predicted_sql": "select count ( * ) from singer", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Сколько певцов? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Перечислите имена певцов в порядке возрастания их чистых активов.", "query": "select name from singer order by net_worth_millions asc", "predicted_sql": "select singer.name from singer order by singer.net_worth_millions asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Перечислите имена певцов в порядке возрастания их чистых активов. \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Как зовут певцов в порядке возрастающей чистой стоимости?", "query": "select name from singer order by net_worth_millions asc", "predicted_sql": "select singer.name from singer order by singer.net_worth_millions asc", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Как зовут певцов в порядке возрастающей чистой стоимости? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Какой год рождения и гражданство певцов?", "query": "select birth_year , citizenship from singer", "predicted_sql": "select singer.birth_year  , singer.citizenship from singer", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Какой год рождения и гражданство певцов? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Какие годы рождения и гражданства певцов?", "query": "select birth_year , citizenship from singer", "predicted_sql": "select singer.birth_year  , singer.citizenship from singer", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Какие годы рождения и гражданства певцов? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Перечислите имена певцов, гражданство которых не \"Россия\".", "query": "select name from singer where citizenship != 'Россия'", "predicted_sql": "select singer.name from singer where singer.citizenship <> 'Россия'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship ( Россия ) | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Перечислите имена певцов, гражданство которых не \"Россия\". \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Как зовут певцов, не являющихся гражданами России?", "query": "select name from singer where citizenship != 'Россия'", "predicted_sql": "select singer.name from singer where singer.citizenship <> 'Russia'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Как зовут певцов, не являющихся гражданами России? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Укажите имена певцов, чей год рождения - 1948 или 1949", "query": "select name from singer where birth_year = 1948 or birth_year = 1949", "predicted_sql": "select singer.name from singer where singer.birth_year = 1948 or singer.birth_year = 1949", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Укажите имена певцов, чей год рождения - 1948 или 1949 \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Как зовут певцов, чьи годы рождения - 1948 или 1949?", "query": "select name from singer where birth_year = 1948 or birth_year = 1949", "predicted_sql": "select singer.name from singer where singer.birth_year = 1948 or singer.birth_year = 1949", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Как зовут певцов, чьи годы рождения - 1948 или 1949? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Как зовут певца с самым большим состоянием?", "query": "select name from singer order by net_worth_millions desc limit 1", "predicted_sql": "select singer.name from singer order by singer.net_worth_millions desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Как зовут певца с самым большим состоянием? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Как зовут певца, который стоит больше всего?", "query": "select name from singer order by net_worth_millions desc limit 1", "predicted_sql": "select singer.name from singer order by singer.net_worth_millions desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Как зовут певца, который стоит больше всего? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Покажите различное гражданство певцов и количество певцов каждого гражданства.", "query": "select citizenship , count ( * ) from singer group by citizenship", "predicted_sql": "select singer.citizenship  , count ( singer.singer_id ) as count from singer group by singer.citizenship", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Покажите различное гражданство певцов и количество певцов каждого гражданства. \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Сколько певцов каждого гражданства?", "query": "select citizenship , count ( * ) from singer group by citizenship", "predicted_sql": "select singer.citizenship  , count ( singer.singer_id ) as count from singer group by singer.citizenship", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Сколько певцов каждого гражданства? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Покажите, пожалуйста, наиболее распространенное гражданство среди певцов.", "query": "select citizenship from singer group by citizenship order by count ( * ) desc limit 1", "predicted_sql": "select singer.citizenship from singer group by singer.citizenship order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Покажите, пожалуйста, наиболее распространенное гражданство среди певцов. \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Какое гражданство у певцов наиболее распространено?", "query": "select citizenship from singer group by citizenship order by count ( * ) desc limit 1", "predicted_sql": "select singer.citizenship from singer group by singer.citizenship order by count ( * ) desc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Какое гражданство у певцов наиболее распространено? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Покажите различное гражданство и максимальный собственный капитал певцов каждого гражданства.", "query": "select citizenship , max ( net_worth_millions ) from singer group by citizenship", "predicted_sql": "select singer.citizenship  , max ( singer.net_worth_millions ) from singer group by singer.citizenship", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Покажите различное гражданство и максимальный собственный капитал певцов каждого гражданства. \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Каков максимальный собственный капитал для каждого гражданства?", "query": "select citizenship , max ( net_worth_millions ) from singer group by citizenship", "predicted_sql": "select singer.citizenship  , max ( singer.net_worth_millions ) as max_net_worth from singer group by singer.citizenship", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Каков максимальный собственный капитал для каждого гражданства? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Показать названия песен и имена певцов.", "query": "select song.title , singer.name from singer join song on singer.singer_id = song.singer_id", "predicted_sql": "select song.title  , singer.name from song join singer on song.singer_id = singer.singer_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Показать названия песен и имена певцов. \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Какие названия песен и имена певцов?", "query": "select song.title , singer.name from singer join song on singer.singer_id = song.singer_id", "predicted_sql": "select song.title  , singer.name from song join singer on song.singer_id = singer.singer_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Какие названия песен и имена певцов? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Покажите разные имена певцов, у которых есть песни с продажами более 300000.", "query": "select distinct singer.name from singer join song on singer.singer_id = song.singer_id where song.sales > 300000", "predicted_sql": "select distinct singer.name from singer join song on song.singer_id = singer.singer_id where song.sales > 300000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Покажите разные имена певцов, у которых есть песни с продажами более 300000. \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Какие имена у певцов, у которых продажи более 300000?", "query": "select distinct singer.name from singer join song on singer.singer_id = song.singer_id where song.sales > 300000", "predicted_sql": "select singer.name from singer join song on song.singer_id = singer.singer_id where song.sales > 300000", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Какие имена у певцов, у которых продажи более 300000? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Покажите имена певцов, у которых есть более одной песни.", "query": "select singer.name from singer join song on singer.singer_id = song.singer_id group by singer.name having count ( * ) > 1", "predicted_sql": "select singer.name from singer join song on singer.singer_id = song.singer_id group by singer.name having count ( song.song_id ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Покажите имена певцов, у которых есть более одной песни. \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Как зовут певцов, у которых есть более одной песни?", "query": "select singer.name from singer join song on singer.singer_id = song.singer_id group by singer.name having count ( * ) > 1", "predicted_sql": "select singer.name from singer join song on singer.singer_id = song.singer_id group by singer.name having count ( song.song_id ) > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Как зовут певцов, у которых есть более одной песни? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Покажите имена певцов и общий объем продаж их песен.", "query": "select singer.name , sum ( song.sales ) from singer join song on singer.singer_id = song.singer_id group by singer.name", "predicted_sql": "select singer.name  , sum ( song.sales ) as total_sales from singer join song on song.singer_id = singer.singer_id group by singer.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Покажите имена певцов и общий объем продаж их песен. \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Каков общий объем продаж песен каждого певца?", "query": "select singer.name , sum ( song.sales ) from singer join song on singer.singer_id = song.singer_id group by singer.name", "predicted_sql": "select singer.name  , sum ( song.sales ) as total_sales from singer join song on song.singer_id = singer.singer_id group by singer.name", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Каков общий объем продаж песен каждого певца? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Перечислите имена певцов, у которых нет песен.", "query": "select name from singer where singer_id not in ( select singer_id from song )", "predicted_sql": "select singer.name from singer left join song on singer.singer_id = song.singer_id where song.singer_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Перечислите имена певцов, у которых нет песен. \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Как зовут всех певцов, у которых нет песен?", "query": "select name from singer where singer_id not in ( select singer_id from song )", "predicted_sql": "select singer.name from singer left join song on singer.singer_id = song.singer_id where song.song_id is null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Как зовут всех певцов, у которых нет песен? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Показать гражданство певцов с годом рождения до 1945 года и после 1955 года.", "query": "select citizenship from singer where birth_year < 1945 intersect select citizenship from singer where birth_year > 1955", "predicted_sql": "select singer.citizenship from singer where singer.birth_year < 1945 or singer.birth_year > 1955", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Показать гражданство певцов с годом рождения до 1945 года и после 1955 года. \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "singer", "question": "Какое гражданство имеют певцы, родившиеся до 1945 года и после 1955 года?", "query": "select citizenship from singer where birth_year < 1945 intersect select citizenship from singer where birth_year > 1955", "predicted_sql": "select singer.citizenship from singer where singer.birth_year < 1945 or singer.birth_year > 1955", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | singer : singer.singer_id , singer.name , singer.birth_year , singer.net_worth_millions , singer.citizenship | song : song.song_id , song.title , song.singer_id , song.sales , song.highest_position | song.singer_id = singer.singer_id# \n ### Какое гражданство имеют певцы, родившиеся до 1945 года и после 1955 года? \n SELECT\n        ", "tc_original": ["singer.*", "singer.singer_id", "singer.name", "singer.birth_year", "singer.net_worth_millions", "singer.citizenship", "song.*", "song.song_id", "song.title", "song.singer_id", "song.sales", "song.highest_position"]}
{"db_id": "real_estate_properties", "question": "Сколько всего доступных функций?", "query": "select count ( * ) from other_available_features", "predicted_sql": "select count ( * ) from other_available_features", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_feature_types : ref_feature_types.feature_type_code , ref_feature_types.feature_type_name | ref_property_types : ref_property_types.property_type_code , ref_property_types.property_type_description | other_available_features : other_available_features.feature_id , other_available_features.feature_type_code , other_available_features.feature_name , other_available_features.feature_description | properties : properties.property_id , properties.property_type_code , properties.date_on_market , properties.date_sold , properties.property_name , properties.property_address , properties.room_count , properties.vendor_requested_price , properties.buyer_offered_price , properties.agreed_selling_price , properties.apt_feature_1 , properties.apt_feature_2 , properties.apt_feature_3 , properties.fld_feature_1 , properties.fld_feature_2 , properties.fld_feature_3 , properties.hse_feature_1 , properties.hse_feature_2 , properties.hse_feature_3 , properties.oth_feature_1 , properties.oth_feature_2 , properties.oth_feature_3 , properties.shp_feature_1 , properties.shp_feature_2 , properties.shp_feature_3 , properties.other_property_details | other_property_features : other_property_features.property_id , other_property_features.feature_id , other_property_features.property_feature_description | other_available_features.feature_type_code = ref_feature_types.feature_type_code | properties.property_type_code = ref_property_types.property_type_code | other_property_features.property_id = properties.property_id | other_property_features.feature_id = other_available_features.feature_id# \n ### Сколько всего доступных функций? \n SELECT\n        ", "tc_original": ["ref_feature_types.*", "ref_feature_types.feature_type_code", "ref_feature_types.feature_type_name", "ref_property_types.*", "ref_property_types.property_type_code", "ref_property_types.property_type_description", "other_available_features.*", "other_available_features.feature_id", "other_available_features.feature_type_code", "other_available_features.feature_name", "other_available_features.feature_description", "properties.*", "properties.property_id", "properties.property_type_code", "properties.date_on_market", "properties.date_sold", "properties.property_name", "properties.property_address", "properties.room_count", "properties.vendor_requested_price", "properties.buyer_offered_price", "properties.agreed_selling_price", "properties.apt_feature_1", "properties.apt_feature_2", "properties.apt_feature_3", "properties.fld_feature_1", "properties.fld_feature_2", "properties.fld_feature_3", "properties.hse_feature_1", "properties.hse_feature_2", "properties.hse_feature_3", "properties.oth_feature_1", "properties.oth_feature_2", "properties.oth_feature_3", "properties.shp_feature_1", "properties.shp_feature_2", "properties.shp_feature_3", "properties.other_property_details", "other_property_features.*", "other_property_features.property_id", "other_property_features.feature_id", "other_property_features.property_feature_description"]}
{"db_id": "real_estate_properties", "question": "Как называется функция AirCon?", "query": "select ref_feature_types.feature_type_name from other_available_features join ref_feature_types on other_available_features.feature_type_code = ref_feature_types.feature_type_code where other_available_features.feature_name = 'AirCon'", "predicted_sql": "select other_available_features.feature_name from other_available_features where other_available_features.feature_type_code = 'AirCon'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_feature_types : ref_feature_types.feature_type_code , ref_feature_types.feature_type_name | ref_property_types : ref_property_types.property_type_code , ref_property_types.property_type_description | other_available_features : other_available_features.feature_id , other_available_features.feature_type_code , other_available_features.feature_name ( AirCon ) , other_available_features.feature_description | properties : properties.property_id , properties.property_type_code , properties.date_on_market , properties.date_sold , properties.property_name , properties.property_address , properties.room_count , properties.vendor_requested_price , properties.buyer_offered_price , properties.agreed_selling_price , properties.apt_feature_1 , properties.apt_feature_2 , properties.apt_feature_3 , properties.fld_feature_1 , properties.fld_feature_2 , properties.fld_feature_3 , properties.hse_feature_1 , properties.hse_feature_2 , properties.hse_feature_3 , properties.oth_feature_1 , properties.oth_feature_2 , properties.oth_feature_3 , properties.shp_feature_1 , properties.shp_feature_2 , properties.shp_feature_3 , properties.other_property_details | other_property_features : other_property_features.property_id , other_property_features.feature_id , other_property_features.property_feature_description | other_available_features.feature_type_code = ref_feature_types.feature_type_code | properties.property_type_code = ref_property_types.property_type_code | other_property_features.property_id = properties.property_id | other_property_features.feature_id = other_available_features.feature_id# \n ### Как называется функция AirCon? \n SELECT\n        ", "tc_original": ["ref_feature_types.*", "ref_feature_types.feature_type_code", "ref_feature_types.feature_type_name", "ref_property_types.*", "ref_property_types.property_type_code", "ref_property_types.property_type_description", "other_available_features.*", "other_available_features.feature_id", "other_available_features.feature_type_code", "other_available_features.feature_name", "other_available_features.feature_description", "properties.*", "properties.property_id", "properties.property_type_code", "properties.date_on_market", "properties.date_sold", "properties.property_name", "properties.property_address", "properties.room_count", "properties.vendor_requested_price", "properties.buyer_offered_price", "properties.agreed_selling_price", "properties.apt_feature_1", "properties.apt_feature_2", "properties.apt_feature_3", "properties.fld_feature_1", "properties.fld_feature_2", "properties.fld_feature_3", "properties.hse_feature_1", "properties.hse_feature_2", "properties.hse_feature_3", "properties.oth_feature_1", "properties.oth_feature_2", "properties.oth_feature_3", "properties.shp_feature_1", "properties.shp_feature_2", "properties.shp_feature_3", "properties.other_property_details", "other_property_features.*", "other_property_features.property_id", "other_property_features.feature_id", "other_property_features.property_feature_description"]}
{"db_id": "real_estate_properties", "question": "Показать описания типов свойств для свойств, принадлежащих этому коду.", "query": "select ref_property_types.property_type_description from properties join ref_property_types on properties.property_type_code = ref_property_types.property_type_code group by properties.property_type_code", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_feature_types : ref_feature_types.feature_type_code , ref_feature_types.feature_type_name | ref_property_types : ref_property_types.property_type_code , ref_property_types.property_type_description | other_available_features : other_available_features.feature_id , other_available_features.feature_type_code , other_available_features.feature_name , other_available_features.feature_description | properties : properties.property_id , properties.property_type_code , properties.date_on_market , properties.date_sold , properties.property_name , properties.property_address , properties.room_count , properties.vendor_requested_price , properties.buyer_offered_price , properties.agreed_selling_price , properties.apt_feature_1 , properties.apt_feature_2 , properties.apt_feature_3 , properties.fld_feature_1 , properties.fld_feature_2 , properties.fld_feature_3 , properties.hse_feature_1 , properties.hse_feature_2 , properties.hse_feature_3 , properties.oth_feature_1 , properties.oth_feature_2 , properties.oth_feature_3 , properties.shp_feature_1 , properties.shp_feature_2 , properties.shp_feature_3 , properties.other_property_details | other_property_features : other_property_features.property_id , other_property_features.feature_id , other_property_features.property_feature_description | other_available_features.feature_type_code = ref_feature_types.feature_type_code | properties.property_type_code = ref_property_types.property_type_code | other_property_features.property_id = properties.property_id | other_property_features.feature_id = other_available_features.feature_id# \n ### Показать описания типов свойств для свойств, принадлежащих этому коду. \n SELECT\n        ", "tc_original": ["ref_feature_types.*", "ref_feature_types.feature_type_code", "ref_feature_types.feature_type_name", "ref_property_types.*", "ref_property_types.property_type_code", "ref_property_types.property_type_description", "other_available_features.*", "other_available_features.feature_id", "other_available_features.feature_type_code", "other_available_features.feature_name", "other_available_features.feature_description", "properties.*", "properties.property_id", "properties.property_type_code", "properties.date_on_market", "properties.date_sold", "properties.property_name", "properties.property_address", "properties.room_count", "properties.vendor_requested_price", "properties.buyer_offered_price", "properties.agreed_selling_price", "properties.apt_feature_1", "properties.apt_feature_2", "properties.apt_feature_3", "properties.fld_feature_1", "properties.fld_feature_2", "properties.fld_feature_3", "properties.hse_feature_1", "properties.hse_feature_2", "properties.hse_feature_3", "properties.oth_feature_1", "properties.oth_feature_2", "properties.oth_feature_3", "properties.shp_feature_1", "properties.shp_feature_2", "properties.shp_feature_3", "properties.other_property_details", "other_property_features.*", "other_property_features.property_id", "other_property_features.feature_id", "other_property_features.property_feature_description"]}
{"db_id": "real_estate_properties", "question": "Как называются гаражи или пабы с более чем одной комнатой?", "query": "select property_name from properties where property_type_code = 'Гараж' union select property_name from properties where property_type_code = 'Паб' and room_count > 1", "predicted_sql": "select properties.property_name from properties join ref_property_types on properties.property_type_code = ref_property_types.property_type_code where ref_property_types.property_type_description = 'Гараж' or ref_property_types.property_type_description = 'Паб' and properties.room_count > 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_feature_types : ref_feature_types.feature_type_code , ref_feature_types.feature_type_name | ref_property_types : ref_property_types.property_type_code ( Гараж , Паб ) , ref_property_types.property_type_description ( Гараж ) | other_available_features : other_available_features.feature_id , other_available_features.feature_type_code , other_available_features.feature_name , other_available_features.feature_description | properties : properties.property_id , properties.property_type_code ( Гараж , Паб ) , properties.date_on_market , properties.date_sold , properties.property_name , properties.property_address , properties.room_count , properties.vendor_requested_price , properties.buyer_offered_price , properties.agreed_selling_price , properties.apt_feature_1 , properties.apt_feature_2 , properties.apt_feature_3 , properties.fld_feature_1 , properties.fld_feature_2 , properties.fld_feature_3 , properties.hse_feature_1 , properties.hse_feature_2 , properties.hse_feature_3 , properties.oth_feature_1 , properties.oth_feature_2 , properties.oth_feature_3 , properties.shp_feature_1 , properties.shp_feature_2 , properties.shp_feature_3 , properties.other_property_details | other_property_features : other_property_features.property_id , other_property_features.feature_id , other_property_features.property_feature_description | other_available_features.feature_type_code = ref_feature_types.feature_type_code | properties.property_type_code = ref_property_types.property_type_code | other_property_features.property_id = properties.property_id | other_property_features.feature_id = other_available_features.feature_id# \n ### Как называются гаражи или пабы с более чем одной комнатой? \n SELECT\n        ", "tc_original": ["ref_feature_types.*", "ref_feature_types.feature_type_code", "ref_feature_types.feature_type_name", "ref_property_types.*", "ref_property_types.property_type_code", "ref_property_types.property_type_description", "other_available_features.*", "other_available_features.feature_id", "other_available_features.feature_type_code", "other_available_features.feature_name", "other_available_features.feature_description", "properties.*", "properties.property_id", "properties.property_type_code", "properties.date_on_market", "properties.date_sold", "properties.property_name", "properties.property_address", "properties.room_count", "properties.vendor_requested_price", "properties.buyer_offered_price", "properties.agreed_selling_price", "properties.apt_feature_1", "properties.apt_feature_2", "properties.apt_feature_3", "properties.fld_feature_1", "properties.fld_feature_2", "properties.fld_feature_3", "properties.hse_feature_1", "properties.hse_feature_2", "properties.hse_feature_3", "properties.oth_feature_1", "properties.oth_feature_2", "properties.oth_feature_3", "properties.shp_feature_1", "properties.shp_feature_2", "properties.shp_feature_3", "properties.other_property_details", "other_property_features.*", "other_property_features.property_id", "other_property_features.feature_id", "other_property_features.property_feature_description"]}
{"db_id": "tvshow", "question": "Количество телеканалов без оплаты по числу просмотров", "query": "select count ( * ) from tv_channel where pay_per_view_ppv = 'нет'", "predicted_sql": "select count ( tv_channel.id ) from tv_channel where tv_channel.pay_per_view_ppv = 0", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | tv_channel : tv_channel.id , tv_channel.series_name , tv_channel.country , tv_channel.language , tv_channel.content , tv_channel.pixel_aspect_ratio_par , tv_channel.hight_definition_tv , tv_channel.pay_per_view_ppv , tv_channel.package_option | tv_series : tv_series.id , tv_series.episode , tv_series.air_date , tv_series.rating , tv_series.share , tv_series.18_49_rating_share , tv_series.viewers_m , tv_series.weekly_rank , tv_series.channel | cartoon : cartoon.id , cartoon.title , cartoon.directed_by , cartoon.written_by , cartoon.original_air_date , cartoon.production_code , cartoon.channel | tv_series.channel = tv_channel.id | cartoon.channel = tv_channel.id# \n ### Количество телеканалов без оплаты по числу просмотров \n SELECT\n        ", "tc_original": ["tv_channel.*", "tv_channel.id", "tv_channel.series_name", "tv_channel.country", "tv_channel.language", "tv_channel.content", "tv_channel.pixel_aspect_ratio_par", "tv_channel.hight_definition_tv", "tv_channel.pay_per_view_ppv", "tv_channel.package_option", "tv_series.*", "tv_series.id", "tv_series.episode", "tv_series.air_date", "tv_series.rating", "tv_series.share", "tv_series.18_49_rating_share", "tv_series.viewers_m", "tv_series.weekly_rank", "tv_series.channel", "cartoon.*", "cartoon.id", "cartoon.title", "cartoon.directed_by", "cartoon.written_by", "cartoon.original_air_date", "cartoon.production_code", "cartoon.channel"]}
{"db_id": "world_1", "question": "Каков для всех стран средний процент людей, говорящих на официальном языке?", "query": "select avg ( percentage ) from countrylanguage where isofficial = 'T'", "predicted_sql": "select avg ( countrylanguage.percentage ) from countrylanguage where countrylanguage.isofficial = 'T'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каков для всех стран средний процент людей, говорящих на официальном языке? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Каков процент людей, говорящих на официальном языке в KAZ?", "query": "select percentage from countrylanguage where isofficial = 'T' and countrycode = 'KAZ'", "predicted_sql": "select ( countrylanguage.percentage / city.population ) * 100 from countrylanguage join city on city.countrycode = countrylanguage.countrycode where city.countrycode = 'KAZ' and countrylanguage.isofficial = 'T'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode ( KAZ ) , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code ( KAZ ) , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode ( KAZ ) , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Каков процент людей, говорящих на официальном языке в KAZ? \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "world_1", "question": "Выведите мне различные коды стран, в которых более 10 процентов людей не говорят на государственном языке.", "query": "select distinct ( countrycode ) from countrylanguage where isofficial = 'F' and percentage > 10", "predicted_sql": "select distinct country.code from country join countrylanguage on countrylanguage.countrycode = country.code where countrylanguage.isofficial = 'F' and countrylanguage.percentage > 10", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | city : city.id , city.name , city.countrycode , city.district , city.population | sqlite_sequence : sqlite_sequence.name , sqlite_sequence.seq | country : country.code , country.name , country.continent , country.region , country.surfacearea , country.indepyear , country.population , country.lifeexpectancy , country.gnp , country.gnpold , country.localname , country.governmentform , country.headofstate , country.capital , country.code2 | countrylanguage : countrylanguage.countrycode , countrylanguage.language , countrylanguage.isofficial , countrylanguage.percentage | city.countrycode = country.code | countrylanguage.countrycode = country.code# \n ### Выведите мне различные коды стран, в которых более 10 процентов людей не говорят на государственном языке. \n SELECT\n        ", "tc_original": ["city.*", "city.id", "city.name", "city.countrycode", "city.district", "city.population", "sqlite_sequence.*", "sqlite_sequence.name", "sqlite_sequence.seq", "country.*", "country.code", "country.name", "country.continent", "country.region", "country.surfacearea", "country.indepyear", "country.population", "country.lifeexpectancy", "country.gnp", "country.gnpold", "country.localname", "country.governmentform", "country.headofstate", "country.capital", "country.code2", "countrylanguage.*", "countrylanguage.countrycode", "countrylanguage.language", "countrylanguage.isofficial", "countrylanguage.percentage"]}
{"db_id": "employee_hire_evaluation", "question": "Показать id всех магазинов с вакансиями с частичной занятостью", "query": "select distinct ( shop_id ) from hiring where is_full_time = 'F'", "predicted_sql": "select shop.shop_id from shop join hiring on shop.shop_id = hiring.shop_id where hiring.is_full_time = 0", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | employee : employee.employee_id , employee.name , employee.age , employee.city | shop : shop.shop_id , shop.name , shop.location , shop.district , shop.number_products , shop.manager_name | hiring : hiring.shop_id , hiring.employee_id , hiring.start_from , hiring.is_full_time | evaluation : evaluation.employee_id , evaluation.year_awarded , evaluation.bonus | hiring.employee_id = employee.employee_id | hiring.shop_id = shop.shop_id | evaluation.employee_id = employee.employee_id# \n ### Показать id всех магазинов с вакансиями с частичной занятостью \n SELECT\n        ", "tc_original": ["employee.*", "employee.employee_id", "employee.name", "employee.age", "employee.city", "shop.*", "shop.shop_id", "shop.name", "shop.location", "shop.district", "shop.number_products", "shop.manager_name", "hiring.*", "hiring.shop_id", "hiring.employee_id", "hiring.start_from", "hiring.is_full_time", "evaluation.*", "evaluation.employee_id", "evaluation.year_awarded", "evaluation.bonus"]}
{"db_id": "orchestra", "question": "Показать идентификаторы всех дебатов с положительным выигрышем", "query": "select min ( attendance ) from show where result = 'T'", "predicted_sql": "select show.show_id from show where show.result = 'win'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | conductor : conductor.conductor_id , conductor.name , conductor.age , conductor.nationality , conductor.year_of_work | orchestra : orchestra.orchestra_id , orchestra.orchestra , orchestra.conductor_id , orchestra.record_company , orchestra.year_of_founded , orchestra.major_record_format | performance : performance.performance_id , performance.orchestra_id , performance.type , performance.date , performance.official_ratings_(millions) , performance.weekly_rank , performance.share | show : show.show_id , show.performance_id , show.if_first_show , show.result , show.attendance | orchestra.conductor_id = conductor.conductor_id | performance.orchestra_id = orchestra.orchestra_id | show.performance_id = performance.performance_id# \n ### Показать идентификаторы всех дебатов с положительным выигрышем \n SELECT\n        ", "tc_original": ["conductor.*", "conductor.conductor_id", "conductor.name", "conductor.age", "conductor.nationality", "conductor.year_of_work", "orchestra.*", "orchestra.orchestra_id", "orchestra.orchestra", "orchestra.conductor_id", "orchestra.record_company", "orchestra.year_of_founded", "orchestra.major_record_format", "performance.*", "performance.performance_id", "performance.orchestra_id", "performance.type", "performance.date", "performance.official_ratings_(millions)", "performance.weekly_rank", "performance.share", "show.*", "show.show_id", "show.performance_id", "show.if_first_show", "show.result", "show.attendance"]}
{"db_id": "dog_kennels", "question": "Пожалуйста, перечисли клички всех собак, являющихся самками.", "query": "select name from dogs where gender = '1'", "predicted_sql": "select dogs.name from dogs where dogs.gender = 'female'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | breeds : breeds.breed_code , breeds.breed_name | charges : charges.charge_id , charges.charge_type , charges.charge_amount | sizes : sizes.size_code , sizes.size_description | treatment_types : treatment_types.treatment_type_code , treatment_types.treatment_type_description | owners : owners.owner_id , owners.first_name , owners.last_name , owners.street , owners.city , owners.state , owners.zip_code , owners.email_address , owners.home_phone , owners.cell_number | dogs : dogs.dog_id , dogs.owner_id , dogs.abandoned_yn , dogs.breed_code , dogs.size_code , dogs.name , dogs.age , dogs.date_of_birth , dogs.gender , dogs.weight , dogs.date_arrived , dogs.date_adopted , dogs.date_departed | professionals : professionals.professional_id , professionals.role_code , professionals.first_name , professionals.street , professionals.city , professionals.state , professionals.zip_code , professionals.last_name , professionals.email_address , professionals.home_phone , professionals.cell_number | treatments : treatments.treatment_id , treatments.dog_id , treatments.professional_id , treatments.treatment_type_code , treatments.date_of_treatment , treatments.cost_of_treatment | dogs.owner_id = owners.owner_id | dogs.owner_id = owners.owner_id | dogs.size_code = sizes.size_code | dogs.breed_code = breeds.breed_code | treatments.dog_id = dogs.dog_id | treatments.professional_id = professionals.professional_id | treatments.treatment_type_code = treatment_types.treatment_type_code# \n ### Пожалуйста, перечисли клички всех собак, являющихся самками. \n SELECT\n        ", "tc_original": ["breeds.*", "breeds.breed_code", "breeds.breed_name", "charges.*", "charges.charge_id", "charges.charge_type", "charges.charge_amount", "sizes.*", "sizes.size_code", "sizes.size_description", "treatment_types.*", "treatment_types.treatment_type_code", "treatment_types.treatment_type_description", "owners.*", "owners.owner_id", "owners.first_name", "owners.last_name", "owners.street", "owners.city", "owners.state", "owners.zip_code", "owners.email_address", "owners.home_phone", "owners.cell_number", "dogs.*", "dogs.dog_id", "dogs.owner_id", "dogs.abandoned_yn", "dogs.breed_code", "dogs.size_code", "dogs.name", "dogs.age", "dogs.date_of_birth", "dogs.gender", "dogs.weight", "dogs.date_arrived", "dogs.date_adopted", "dogs.date_departed", "professionals.*", "professionals.professional_id", "professionals.role_code", "professionals.first_name", "professionals.street", "professionals.city", "professionals.state", "professionals.zip_code", "professionals.last_name", "professionals.email_address", "professionals.home_phone", "professionals.cell_number", "treatments.*", "treatments.treatment_id", "treatments.dog_id", "treatments.professional_id", "treatments.treatment_type_code", "treatments.date_of_treatment", "treatments.cost_of_treatment"]}
{"db_id": "concert_singer", "question": "Количество певиц", "query": "select count ( * ) from singer where singer.is_male = 'F'", "predicted_sql": "select count ( * ) from singer where singer.is_male = 0", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Количество певиц \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "battle_death", "question": "Кто из латинских главнокомандующих участвовал в сражения в апреле 1205 года?", "query": "select distinct ( latin_commander ) from battle where date like '%Апрел%' and date like '%1205%'", "predicted_sql": "select battle.latin_commander from battle where battle.date = '1205-04'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Кто из латинских главнокомандующих участвовал в сражения в апреле 1205 года? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Как много сражений состоялось в период с 1205 по 1207 годы включительно?", "query": "select count ( distinct id ) from battle where date like '%1205%' or date like '%1206%' or date like '%1207%'", "predicted_sql": "select count ( * ) from battle where date >= '1205-01-01' and date <= '1207-12-31'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Как много сражений состоялось в период с 1205 по 1207 годы включительно? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "course_teach", "question": "Количество курсов, начавшихся в мае", "query": "select count ( distinct course_id ) from course where staring_date like '%Мая%'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Количество курсов, начавшихся в мае \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Выведи названия курсов, начавшихся 14го Мая", "query": "select distinct ( course ) from course where staring_date = '14 Мая'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Выведи названия курсов, начавшихся 14го Мая \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "course_teach", "question": "Какой минимальный балл был поставлен за курс от 9 мая?", "query": "select min ( grade ) from course_arrange join course on course_arrange.course_id = course.course_id where staring_date like '%9 Мая%'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | course : course.course_id , course.staring_date ( 9 Мая ) , course.course | teacher : teacher.teacher_id , teacher.name , teacher.age , teacher.hometown | course_arrange : course_arrange.course_id , course_arrange.teacher_id , course_arrange.grade | course_arrange.teacher_id = teacher.teacher_id | course_arrange.course_id = course.course_id# \n ### Какой минимальный балл был поставлен за курс от 9 мая? \n SELECT\n        ", "tc_original": ["course.*", "course.course_id", "course.staring_date", "course.course", "teacher.*", "teacher.teacher_id", "teacher.name", "teacher.age", "teacher.hometown", "course_arrange.*", "course_arrange.course_id", "course_arrange.teacher_id", "course_arrange.grade"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Id шаблонов действующих с 2005 по 2008 год", "query": "select template_id from templates where date_effective_from like '%2005%' and date_effective_to like '%2008%'", "predicted_sql": "select templates.template_id from templates where templates.date_effective_from >= '2005-01-01' and templates.date_effective_to <= '2008-12-31'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Id шаблонов действующих с 2005 по 2008 год \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какие ID у шаблонов действующих с 2005-11-12 по 2008-01-05?", "query": "select template_id from templates where date_effective_from like '%2005-11-12%' and date_effective_to like '%2008-01-05%'", "predicted_sql": "select templates.template_id from templates where templates.date_effective_from >= '2005-11-12' and templates.date_effective_to <= '2008-01-05'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какие ID у шаблонов действующих с 2005-11-12 по 2008-01-05? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Количество шаблонов, вступивших в силу в период с 2010 по 2012 год", "query": "select count ( distinct template_id ) from templates where date_effective_from like '%2010%' or date_effective_from like '%2011%' or date_effective_from like '%2012%'", "predicted_sql": "select count ( * ) from templates where date_effective_from >= '2010-01-01' and date_effective_to <= '2012-12-31'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Количество шаблонов, вступивших в силу в период с 2010 по 2012 год \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "Какой ID у шаблона, вступившего в силу самым первым?", "query": "select template_id from templates where date_effective_from in ( select min ( date_effective_from ) from templates )", "predicted_sql": "select templates.template_id from templates order by templates.date_effective_from asc limit 1", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### Какой ID у шаблона, вступившего в силу самым первым? \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "concert_singer", "question": "Выведите все пары id концертов и стадионов.", "query": "select concert_id , stadium_id from concert", "predicted_sql": "select concert.concert_id  , stadium.stadium_id from concert join stadium on concert.stadium_id = stadium.stadium_id", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | stadium : stadium.stadium_id , stadium.location , stadium.name , stadium.capacity , stadium.highest , stadium.lowest , stadium.average | singer : singer.singer_id , singer.name , singer.country , singer.song_name , singer.song_release_year , singer.age , singer.is_male | concert : concert.concert_id , concert.concert_name , concert.theme , concert.stadium_id , concert.year | singer_in_concert : singer_in_concert.concert_id , singer_in_concert.singer_id | concert.stadium_id = stadium.stadium_id | singer_in_concert.singer_id = singer.singer_id | singer_in_concert.concert_id = concert.concert_id# \n ### Выведите все пары id концертов и стадионов. \n SELECT\n        ", "tc_original": ["stadium.*", "stadium.stadium_id", "stadium.location", "stadium.name", "stadium.capacity", "stadium.highest", "stadium.lowest", "stadium.average", "singer.*", "singer.singer_id", "singer.name", "singer.country", "singer.song_name", "singer.song_release_year", "singer.age", "singer.is_male", "concert.*", "concert.concert_id", "concert.concert_name", "concert.theme", "concert.stadium_id", "concert.year", "singer_in_concert.*", "singer_in_concert.concert_id", "singer_in_concert.singer_id"]}
{"db_id": "wta_1", "question": "Имена победителей и проигравших на матче №222.", "query": "select winner_name , loser_name from matches where match_num = 222", "predicted_sql": "select matches.winner_name  , matches.loser_name from matches where matches.match_num = 222", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Имена победителей и проигравших на матче №222. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Выведи id и даты турниров с Мироном Сивовым", "query": "select tourney_date , tourney_id from matches where winner_name = 'Мирон Сивов' or loser_name = 'Мирон Сивов'", "predicted_sql": "select matches.tourney_id  , matches.tourney_date from players join matches on matches.winner_id = players.player_id where players.last_name = 'Сивов' and players.first_name = 'Мирон'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Выведи id и даты турниров с Мироном Сивовым \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Сколько было матчей, в которых рост проигравшего больше роста победителя.", "query": "select count ( * ) from matches where loser_ht > winner_ht", "predicted_sql": "select count ( * ) from matches where matches.loser_ht > matches.winner_ht", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Сколько было матчей, в которых рост проигравшего больше роста победителя. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "wta_1", "question": "Количество матчей, в которых проигравший был выше победителя.", "query": "select count ( * ) from matches where loser_ht > winner_ht", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | players : players.player_id , players.first_name , players.last_name , players.hand , players.birth_date , players.country_code | matches : matches.best_of , matches.draw_size , matches.loser_age , matches.loser_entry , matches.loser_hand , matches.loser_ht , matches.loser_id , matches.loser_ioc , matches.loser_name , matches.loser_rank , matches.loser_rank_points , matches.loser_seed , matches.match_num , matches.minutes , matches.round , matches.score , matches.surface , matches.tourney_date , matches.tourney_id , matches.tourney_level , matches.tourney_name , matches.winner_age , matches.winner_entry , matches.winner_hand , matches.winner_ht , matches.winner_id , matches.winner_ioc , matches.winner_name , matches.winner_rank , matches.winner_rank_points , matches.winner_seed , matches.year | rankings : rankings.ranking_date , rankings.ranking , rankings.player_id , rankings.ranking_points , rankings.tours | matches.winner_id = players.player_id | matches.loser_id = players.player_id | rankings.player_id = players.player_id# \n ### Количество матчей, в которых проигравший был выше победителя. \n SELECT\n        ", "tc_original": ["players.*", "players.player_id", "players.first_name", "players.last_name", "players.hand", "players.birth_date", "players.country_code", "matches.*", "matches.best_of", "matches.draw_size", "matches.loser_age", "matches.loser_entry", "matches.loser_hand", "matches.loser_ht", "matches.loser_id", "matches.loser_ioc", "matches.loser_name", "matches.loser_rank", "matches.loser_rank_points", "matches.loser_seed", "matches.match_num", "matches.minutes", "matches.round", "matches.score", "matches.surface", "matches.tourney_date", "matches.tourney_id", "matches.tourney_level", "matches.tourney_name", "matches.winner_age", "matches.winner_entry", "matches.winner_hand", "matches.winner_ht", "matches.winner_id", "matches.winner_ioc", "matches.winner_name", "matches.winner_rank", "matches.winner_rank_points", "matches.winner_seed", "matches.year", "rankings.*", "rankings.ranking_date", "rankings.ranking", "rankings.player_id", "rankings.ranking_points", "rankings.tours"]}
{"db_id": "network_1", "question": "У скольких школьников есть друзья?", "query": "select count ( distinct student_id ) from friend", "predicted_sql": "select count ( distinct student_id ) from friend", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### У скольких школьников есть друзья? \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "network_1", "question": "Идентификаторы старшеклассников, с которыми Лев находится в дружбе.", "query": "select friend_id from highschooler join friend on highschooler.id = friend.friend_id where highschooler.name = 'Лев'", "predicted_sql": "select friend.friend_id from friend join highschooler on friend.friend_id = highschooler.id where highschooler.name = 'Лев'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | highschooler : highschooler.id , highschooler.name ( Лев ) , highschooler.grade | friend : friend.student_id , friend.friend_id | likes : likes.student_id , likes.liked_id | friend.friend_id = highschooler.id | friend.student_id = highschooler.id | likes.student_id = highschooler.id | likes.liked_id = highschooler.id# \n ### Идентификаторы старшеклассников, с которыми Лев находится в дружбе. \n SELECT\n        ", "tc_original": ["highschooler.*", "highschooler.id", "highschooler.name", "highschooler.grade", "friend.*", "friend.student_id", "friend.friend_id", "likes.*", "likes.student_id", "likes.liked_id"]}
{"db_id": "student_transcripts_tracking", "question": "Описания всех курсов по экономике", "query": "select course_description from courses where course_name = 'экономика'", "predicted_sql": "select courses.course_description from courses where courses.course_name like '%экономика%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Описания всех курсов по экономике \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Имя, фамилия и отчество студентов, записавшихся на курсы по экономике", "query": "select first_name , middle_name , last_name from students join student_enrolment on students.student_id = student_enrolment.student_id join student_enrolment_courses on student_enrolment.student_enrolment_id = student_enrolment_courses.student_enrolment_id join courses on student_enrolment_courses.course_id = courses.course_id where courses.course_name = 'экономика'", "predicted_sql": "sql placeholder", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Имя, фамилия и отчество студентов, записавшихся на курсы по экономике \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Нужны номера телефонов студентов с курсов по искусственному интеллекту.", "query": "select cell_mobile_number from students join student_enrolment on students.student_id = student_enrolment.student_id join student_enrolment_courses on student_enrolment.student_enrolment_id = student_enrolment_courses.student_enrolment_id join courses on student_enrolment_courses.course_id = courses.course_id where courses.course_name = 'ai'", "predicted_sql": "select students.cell_mobile_number from students join student_enrolment on student_enrolment.student_id = students.student_id join student_enrolment_courses on student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id join courses on courses.course_id = student_enrolment_courses.course_id where courses.course_name = 'Artificial Intelligence'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Нужны номера телефонов студентов с курсов по искусственному интеллекту. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "student_transcripts_tracking", "question": "Фамилии студентов, у которых различаются города текущего проживания и регистрации.", "query": "select distinct ( last_name ) from students join addresses as current on students.current_address_id = current.address_id join addresses as permanent on students.permanent_address_id = permanent.address_id where current.city != permanent.city", "predicted_sql": "select students.last_name from students join addresses as current_address on students.current_address_id = current_address.address_id join addresses as permanent_address on students.permanent_address_id = permanent_address.address_id where current_address.city <> permanent_address.city", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Фамилии студентов, у которых различаются города текущего проживания и регистрации. \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
{"db_id": "battle_death", "question": "Сравни количество побед", "query": "select count ( * ) , result from battle where result = 'Bulgarian victory' or result = 'Latin victory' group by result", "predicted_sql": "select count ( * ) from battle where battle.result = 'victory'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Сравни количество побед \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Сколько боев окончились перемирием?", "query": "select count ( * ) from battle where result = 'Two Year Truce' or result = 'Перемирие'", "predicted_sql": "select count ( * ) from battle where result = 'Перемирие'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result ( Перемирие ) | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Сколько боев окончились перемирием? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Кто с кем из латинских и болгарских командиров пересекался в боях?", "query": "select latin_commander , bulgarian_commander from battle", "predicted_sql": "select battle.latin_commander  , battle.bulgarian_commander from battle", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Кто с кем из латинских и болгарских командиров пересекался в боях? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Перечислить все конфигурации типы и диспозиций судов, задействованных в битвах на Ла-Манше", "query": "select distinct ship_type , disposition_of_ship from ship where location = 'English Channel' or location = 'Ла-Манш'", "predicted_sql": "select ship.ship_type  , ship.disposition_of_ship from ship join battle on ship.lost_in_battle = battle.id where ship.location = 'Ла-Манш'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location ( Ла-Манш ) , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Перечислить все конфигурации типы и диспозиций судов, задействованных в битвах на Ла-Манше \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Список всех локаций и количество потопленных там судов", "query": "select location , sum ( lost_in_battle ) from ship group by location", "predicted_sql": "select ship.location  , count ( ship.lost_in_battle ) as num_ships_lost from ship group by ship.location", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Список всех локаций и количество потопленных там судов \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Сколько всего было потоплено кораблей?", "query": "select sum ( lost_in_battle ) from ship", "predicted_sql": "select count ( ship.id ) from ship where ship.lost_in_battle is not null", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Сколько всего было потоплено кораблей? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Как много сражений выиграл каждый из болгарских командиров?", "query": "select count ( distinct name ) , bulgarian_commander from battle where result = 'Bulgarian victory' group by latin_commander", "predicted_sql": "select battle.bulgarian_commander  , count ( battle.result ) as victories from battle where battle.result = 'win' group by battle.bulgarian_commander", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Как много сражений выиграл каждый из болгарских командиров? \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Разбей количество потопленных кораблей по типам", "query": "select sum ( death.killed ) , ship.ship_type from death join ship on death.id = ship.id group by ship.ship_type", "predicted_sql": "select ship.ship_type  , count ( ship.lost_in_battle ) as total_ships_lost from ship group by ship.ship_type", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Разбей количество потопленных кораблей по типам \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "battle_death", "question": "Детализируй количество потопленных кораблей по их расположению.", "query": "select sum ( death.killed ) , ship.disposition_of_ship from death join ship on death.id = ship.id group by ship.disposition_of_ship", "predicted_sql": "select ship.location  , count ( ship.lost_in_battle ) as total_ships_lost from ship group by ship.location", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | battle : battle.id , battle.name , battle.date , battle.bulgarian_commander , battle.latin_commander , battle.result | ship : ship.lost_in_battle , ship.id , ship.name , ship.tonnage , ship.ship_type , ship.location , ship.disposition_of_ship | death : death.caused_by_ship_id , death.id , death.note , death.killed , death.injured | ship.lost_in_battle = battle.id | death.caused_by_ship_id = ship.id# \n ### Детализируй количество потопленных кораблей по их расположению. \n SELECT\n        ", "tc_original": ["battle.*", "battle.id", "battle.name", "battle.date", "battle.bulgarian_commander", "battle.latin_commander", "battle.result", "ship.*", "ship.lost_in_battle", "ship.id", "ship.name", "ship.tonnage", "ship.ship_type", "ship.location", "ship.disposition_of_ship", "death.*", "death.caused_by_ship_id", "death.id", "death.note", "death.killed", "death.injured"]}
{"db_id": "car_1", "question": "Максимальное количество цилиндров у моделей от chrysler lebaron medallion", "query": "select max ( cars_data.cylinders ) from cars_data join car_names on cars_data.id = car_names.makeid where car_names.make like '%chrysler%lebaron%medallion%'", "predicted_sql": "select max ( cars_data.cylinders ) from cars_data join car_names on cars_data.id = car_names.makeid join model_list on car_names.model = model_list.model join car_makers on model_list.maker = car_makers.id where car_names.make = 'chrysler lebaron medallion'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | continents : continents.contid , continents.continent | countries : countries.countryid , countries.countryname , countries.continent | car_makers : car_makers.id , car_makers.maker ( chrysler ) , car_makers.fullname ( Chrysler ) , car_makers.country | model_list : model_list.modelid , model_list.maker , model_list.model ( chrysler ) | car_names : car_names.makeid , car_names.model ( chrysler ) , car_names.make ( chrysler lebaron medallion ) | cars_data : cars_data.id , cars_data.mpg , cars_data.cylinders , cars_data.edispl , cars_data.horsepower , cars_data.weight , cars_data.accelerate , cars_data.year | countries.continent = continents.contid | car_makers.country = countries.countryid | model_list.maker = car_makers.id | car_names.model = model_list.model | cars_data.id = car_names.makeid# \n ### Максимальное количество цилиндров у моделей от chrysler lebaron medallion \n SELECT\n        ", "tc_original": ["continents.*", "continents.contid", "continents.continent", "countries.*", "countries.countryid", "countries.countryname", "countries.continent", "car_makers.*", "car_makers.id", "car_makers.maker", "car_makers.fullname", "car_makers.country", "model_list.*", "model_list.modelid", "model_list.maker", "model_list.model", "car_names.*", "car_names.makeid", "car_names.model", "car_names.make", "cars_data.*", "cars_data.id", "cars_data.mpg", "cars_data.cylinders", "cars_data.edispl", "cars_data.horsepower", "cars_data.weight", "cars_data.accelerate", "cars_data.year"]}
{"db_id": "flight_2", "question": "В какой стране находится аэропорт Тед Стивенс?", "query": "select country from airports where airportname like '%Ted%Stevens%'", "predicted_sql": "select airports.country from airports where airports.airportname = 'Тед Стивенс'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | airlines : airlines.uid , airlines.airline , airlines.abbreviation , airlines.country | airports : airports.city , airports.airportcode , airports.airportname , airports.country , airports.countryabbrev | flights : flights.airline , flights.flightno , flights.sourceairport , flights.destairport | flights.destairport = airports.airportcode | flights.sourceairport = airports.airportcode# \n ### В какой стране находится аэропорт Тед Стивенс? \n SELECT\n        ", "tc_original": ["airlines.*", "airlines.uid", "airlines.airline", "airlines.abbreviation", "airlines.country", "airports.*", "airports.city", "airports.airportcode", "airports.airportname", "airports.country", "airports.countryabbrev", "flights.*", "flights.airline", "flights.flightno", "flights.sourceairport", "flights.destairport"]}
{"db_id": "cre_Doc_Template_Mgt", "question": "ID документов, в которых можно есть что-то про работу в Google", "query": "select document_id from documents where document_name like '%Google%' or document_description like '%Coogle%'", "predicted_sql": "select documents.document_id from documents join templates on documents.template_id = templates.template_id join ref_template_types on templates.template_type_code = ref_template_types.template_type_code where ref_template_types.template_type_description like '%Google%'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | ref_template_types : ref_template_types.template_type_code , ref_template_types.template_type_description | templates : templates.template_id , templates.version_number , templates.template_type_code , templates.date_effective_from , templates.date_effective_to , templates.template_details | documents : documents.document_id , documents.template_id , documents.document_name , documents.document_description , documents.other_details | paragraphs : paragraphs.paragraph_id , paragraphs.document_id , paragraphs.paragraph_text , paragraphs.other_details | templates.template_type_code = ref_template_types.template_type_code | documents.template_id = templates.template_id | paragraphs.document_id = documents.document_id# \n ### ID документов, в которых можно есть что-то про работу в Google \n SELECT\n        ", "tc_original": ["ref_template_types.*", "ref_template_types.template_type_code", "ref_template_types.template_type_description", "templates.*", "templates.template_id", "templates.version_number", "templates.template_type_code", "templates.date_effective_from", "templates.date_effective_to", "templates.template_details", "documents.*", "documents.document_id", "documents.template_id", "documents.document_name", "documents.document_description", "documents.other_details", "paragraphs.*", "paragraphs.paragraph_id", "paragraphs.document_id", "paragraphs.paragraph_text", "paragraphs.other_details"]}
{"db_id": "museum_visit", "question": "В каком году был открыт Central Residental Museum?", "query": "select open_year from museum where name like '%Central%Residential%Museum%'", "predicted_sql": "select museum.open_year from museum where museum.name = 'Central Residental Museum'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | museum : museum.museum_id , museum.name , museum.num_of_staff , museum.open_year | visitor : visitor.id , visitor.name , visitor.level_of_membership , visitor.age | visit : visit.museum_id , visit.visitor_id , visit.num_of_ticket , visit.total_spent | visit.visitor_id = visitor.id | visit.museum_id = museum.museum_id# \n ### В каком году был открыт Central Residental Museum? \n SELECT\n        ", "tc_original": ["museum.*", "museum.museum_id", "museum.name", "museum.num_of_staff", "museum.open_year", "visitor.*", "visitor.id", "visitor.name", "visitor.level_of_membership", "visitor.age", "visit.*", "visit.museum_id", "visit.visitor_id", "visit.num_of_ticket", "visit.total_spent"]}
{"db_id": "student_transcripts_tracking", "question": "Почтовые индексы студентов, живущих на Lamar Plaza", "query": "select zip_postcode from addresses where line_1 like '%Lamar%Plaza%'", "predicted_sql": "select students.student_id from students join addresses on students.current_address_id = addresses.address_id where addresses.line_1 = 'Lamar Plaza'", "model": "gpt-3.5-turbo-0613", "prompt": "\n        ### Complete sqlite SQL query only and with no explanation \n ### Sqlite SQL tables, with their properties: \n# \n#\n         | addresses : addresses.address_id , addresses.line_1 , addresses.line_2 , addresses.line_3 , addresses.city , addresses.zip_postcode , addresses.state_province_county , addresses.country , addresses.other_address_details | courses : courses.course_id , courses.course_name , courses.course_description , courses.other_details | departments : departments.department_id , departments.department_name , departments.department_description , departments.other_details | degree_programs : degree_programs.degree_program_id , degree_programs.department_id , degree_programs.degree_summary_name , degree_programs.degree_summary_description , degree_programs.other_details | sections : sections.section_id , sections.course_id , sections.section_name , sections.section_description , sections.other_details | semesters : semesters.semester_id , semesters.semester_name , semesters.semester_description , semesters.other_details | students : students.student_id , students.current_address_id , students.permanent_address_id , students.first_name , students.middle_name , students.last_name , students.cell_mobile_number , students.email_address , students.ssn , students.date_first_registered , students.date_left , students.other_student_details | student_enrolment : student_enrolment.student_enrolment_id , student_enrolment.degree_program_id , student_enrolment.semester_id , student_enrolment.student_id , student_enrolment.other_details | student_enrolment_courses : student_enrolment_courses.student_course_id , student_enrolment_courses.course_id , student_enrolment_courses.student_enrolment_id | transcripts : transcripts.transcript_id , transcripts.transcript_date , transcripts.other_details | transcript_contents : transcript_contents.student_course_id , transcript_contents.transcript_id | degree_programs.department_id = departments.department_id | sections.course_id = courses.course_id | students.permanent_address_id = addresses.address_id | students.current_address_id = addresses.address_id | student_enrolment.student_id = students.student_id | student_enrolment.semester_id = semesters.semester_id | student_enrolment.degree_program_id = degree_programs.degree_program_id | student_enrolment_courses.student_enrolment_id = student_enrolment.student_enrolment_id | student_enrolment_courses.course_id = courses.course_id | transcript_contents.transcript_id = transcripts.transcript_id | transcript_contents.student_course_id = student_enrolment_courses.student_course_id# \n ### Почтовые индексы студентов, живущих на Lamar Plaza \n SELECT\n        ", "tc_original": ["addresses.*", "addresses.address_id", "addresses.line_1", "addresses.line_2", "addresses.line_3", "addresses.city", "addresses.zip_postcode", "addresses.state_province_county", "addresses.country", "addresses.other_address_details", "courses.*", "courses.course_id", "courses.course_name", "courses.course_description", "courses.other_details", "departments.*", "departments.department_id", "departments.department_name", "departments.department_description", "departments.other_details", "degree_programs.*", "degree_programs.degree_program_id", "degree_programs.department_id", "degree_programs.degree_summary_name", "degree_programs.degree_summary_description", "degree_programs.other_details", "sections.*", "sections.section_id", "sections.course_id", "sections.section_name", "sections.section_description", "sections.other_details", "semesters.*", "semesters.semester_id", "semesters.semester_name", "semesters.semester_description", "semesters.other_details", "students.*", "students.student_id", "students.current_address_id", "students.permanent_address_id", "students.first_name", "students.middle_name", "students.last_name", "students.cell_mobile_number", "students.email_address", "students.ssn", "students.date_first_registered", "students.date_left", "students.other_student_details", "student_enrolment.*", "student_enrolment.student_enrolment_id", "student_enrolment.degree_program_id", "student_enrolment.semester_id", "student_enrolment.student_id", "student_enrolment.other_details", "student_enrolment_courses.*", "student_enrolment_courses.student_course_id", "student_enrolment_courses.course_id", "student_enrolment_courses.student_enrolment_id", "transcripts.*", "transcripts.transcript_id", "transcripts.transcript_date", "transcripts.other_details", "transcript_contents.*", "transcript_contents.student_course_id", "transcript_contents.transcript_id"]}
